<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>connpy API documentation</title>
<meta name="description" content="Connection manager â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>connpy</code></h1>
</header>
<section id="section-intro">
<h2 id="connection-manager">Connection manager</h2>
<p>Connpy is a SSH, SFTP, Telnet, kubectl, and Docker pod connection manager and automation module for Linux, Mac, and Docker.</p>
<h3 id="features">Features</h3>
<pre><code>- Manage connections using SSH, SFTP, Telnet, kubectl, and Docker exec.
- Set contexts to manage specific nodes from specific contexts (work/home/clients/etc).
- You can generate profiles and reference them from nodes using @profilename so you don't
  need to edit multiple nodes when changing passwords or other information.
- Nodes can be stored on @folder or @subfolder@folder to organize your devices. They can
  be referenced using node@subfolder@folder or node@folder.
- If you have too many nodes, get a completion script using: conn config --completion.
  Or use fzf by installing pyfzf and running conn config --fzf true.
- Create in bulk, copy, move, export, and import nodes for easy management.
- Run automation scripts on network devices.
- Use GPT AI to help you manage your devices.
- Add plugins with your own scripts.
- Much more!
</code></pre>
<h3 id="usage">Usage</h3>
<pre><code>usage: conn [-h] [--add | --del | --mod | --show | --debug] [node|folder] [--sftp]
       conn {profile,move,mv,copy,cp,list,ls,bulk,export,import,ai,run,api,plugin,config,sync,context} ...

positional arguments:
  node|folder        node[@subfolder][@folder]
                     Connect to specific node or show all matching nodes
                     [@subfolder][@folder]
                     Show all available connections globally or in specified path

options:
  -h, --help         show this help message and exit
  -v, --version      Show version
  -a, --add          Add new node[@subfolder][@folder] or [@subfolder]@folder
  -r, --del, --rm    Delete node[@subfolder][@folder] or [@subfolder]@folder
  -e, --mod, --edit  Modify node[@subfolder][@folder]
  -s, --show         Show node[@subfolder][@folder]
  -d, --debug        Display all conections steps
  -t, --sftp         Connects using sftp instead of ssh

Commands:
  profile         Manage profiles
  move(mv)        Move node
  copy(cp)        Copy node
  list(ls)        List profiles, nodes or folders
  bulk            Add nodes in bulk
  export          Export connection folder to Yaml file
  import          Import connection folder to config from Yaml file
  ai              Make request to an AI
  run             Run scripts or commands on nodes
  api             Start and stop connpy api
  plugin          Manage plugins
  config          Manage app config
  sync            Sync config with Google
  context         Manage contexts with regex matching
</code></pre>
<h3 id="manage-profiles">Manage profiles</h3>
<pre><code>usage: conn profile [-h] (--add | --del | --mod | --show) profile

positional arguments:
  profile        Name of profile to manage

options:
  -h, --help         show this help message and exit
  -a, --add          Add new profile
  -r, --del, --rm    Delete profile
  -e, --mod, --edit  Modify profile
  -s, --show         Show profile

</code></pre>
<h3 id="examples">Examples</h3>
<pre><code>   #Add new profile
   conn profile --add office-user
   #Add new folder
   conn --add @office
   #Add new subfolder
   conn --add @datacenter@office
   #Add node to subfolder
   conn --add server@datacenter@office
   #Add node to folder
   conn --add pc@office
   #Show node information
   conn --show server@datacenter@office
   #Connect to nodes
   conn pc@office
   conn server
   #Create and set new context
   conn context -a office .*@office
   conn context --set office
   #Run a command in a node
   conn run server ls -la
</code></pre>
<h2 id="plugin-requirements-for-connpy">Plugin Requirements for Connpy</h2>
<h3 id="general-structure">General Structure</h3>
<ul>
<li>The plugin script must be a Python file.</li>
<li>Only the following top-level elements are allowed in the plugin script:</li>
<li>Class definitions</li>
<li>Function definitions</li>
<li>Import statements</li>
<li>The <code>if __name__ == "__main__":</code> block for standalone execution</li>
<li>Pass statements</li>
</ul>
<h3 id="specific-class-requirements">Specific Class Requirements</h3>
<ul>
<li>The plugin script must define specific classes with particular attributes and methods. Each class serves a distinct role within the plugin's architecture:</li>
<li><strong>Class <code>Parser</code></strong>:<ul>
<li><strong>Purpose</strong>: Handles parsing of command-line arguments.</li>
<li><strong>Requirements</strong>:</li>
<li>Must contain only one method: <code>__init__</code>.</li>
<li>The <code>__init__</code> method must initialize at least two attributes:<ul>
<li><code>self.parser</code>: An instance of <code>argparse.ArgumentParser</code>.</li>
<li><code>self.description</code>: A string containing the description of the parser.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Class <code>Entrypoint</code></strong>:<ul>
<li><strong>Purpose</strong>: Acts as the entry point for plugin execution, utilizing parsed arguments and integrating with the main application.</li>
<li><strong>Requirements</strong>:</li>
<li>Must have an <code>__init__</code> method that accepts exactly three parameters besides <code>self</code>:<ul>
<li><code>args</code>: Arguments passed to the plugin.</li>
<li>The parser instance (typically <code>self.parser</code> from the <code>Parser</code> class).</li>
<li>The Connapp instance to interact with the Connpy app.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Class <code>Preload</code></strong>:<ul>
<li><strong>Purpose</strong>: Performs any necessary preliminary setup or configuration independent of the main parsing and entry logic.</li>
</ul>
</li>
<li><strong>Requirements</strong>:<ul>
<li>Contains at least an <code>__init__</code> method that accepts parameter connapp besides <code>self</code>.</li>
</ul>
</li>
</ul>
<h3 id="class-dependencies-and-combinations">Class Dependencies and Combinations</h3>
<ul>
<li><strong>Dependencies</strong>:</li>
<li><code>Parser</code> and <code>Entrypoint</code> are interdependent and must both be present if one is included.</li>
<li><code>Preload</code> is independent and may exist alone or alongside the other classes.</li>
<li><strong>Valid Combinations</strong>:</li>
<li><code>Parser</code> and <code>Entrypoint</code> together.</li>
<li><code>Preload</code> alone.</li>
<li>All three classes (<code>Parser</code>, <code>Entrypoint</code>, <code>Preload</code>).</li>
</ul>
<h3 id="preload-modifications-and-hooks">Preload Modifications and Hooks</h3>
<p>In the <code>Preload</code> class of the plugin system, you have the ability to customize the behavior of existing classes and methods within the application through a robust hooking system. This documentation explains how to use the <code>modify</code>, <code>register_pre_hook</code>, and <code>register_post_hook</code> methods to tailor plugin functionality to your needs.</p>
<h4 id="modifying-classes-with-modify">Modifying Classes with <code>modify</code></h4>
<p>The <code>modify</code> method allows you to alter instances of a class at the time they are created or after their creation. This is particularly useful for setting or modifying configuration settings, altering default behaviors, or adding new functionalities to existing classes without changing the original class definitions.</p>
<ul>
<li><strong>Usage</strong>: Modify a class to include additional configurations or changes</li>
<li><strong>Modify Method Signature</strong>:</li>
<li><code>modify(modification_method)</code>: A function that is invoked with an instance of the class as its argument. This function should perform any modifications directly on this instance.</li>
<li><strong>Modification Method Signature</strong>:</li>
<li><strong>Arguments</strong>:<ul>
<li><code>cls</code>:
This function accepts a single argument, the class instance, which it then modifies.</li>
</ul>
</li>
<li><strong>Modifiable Classes</strong>:<ul>
<li><code>connapp.config</code></li>
<li><code>connapp.node</code></li>
<li><code>connapp.nodes</code></li>
<li><code>connapp.ai</code></li>
</ul>
</li>
<li>
<p>```python
def modify_config(cls):
# Example modification: adding a new attribute or modifying an existing one
cls.new_attribute = 'New Value'</p>
<p>class Preload:
def <strong>init</strong>(self, connapp):
# Applying modification to the config class instance
connapp.config.modify(modify_config)
```</p>
</li>
</ul>
<h4 id="implementing-method-hooks">Implementing Method Hooks</h4>
<p>There are 2 methods that allows you to define custom logic to be executed before (<code>register_pre_hook</code>) or after (<code>register_post_hook</code>) the main logic of a method. This is particularly useful for logging, auditing, preprocessing inputs, postprocessing outputs or adding functionalities.</p>
<ul>
<li><strong>Usage</strong>: Register hooks to methods to execute additional logic before or after the main method execution.</li>
<li><strong>Registration Methods Signature</strong>:</li>
<li><code>register_pre_hook(pre_hook_method)</code>: A function that is invoked before the main method is executed. This function should do preprocessing of the arguments.</li>
<li><code>register_post_hook(post_hook_method)</code>: A function that is invoked after the main method is executed. This function should do postprocessing of the outputs.</li>
<li><strong>Method Signatures for Pre-Hooks</strong></li>
<li><code>pre_hook_method(*args, **kwargs)</code></li>
<li><strong>Arguments</strong>:<ul>
<li><code>*args</code>, <code>**kwargs</code>: The arguments and keyword arguments that will be passed to the method being hooked. The pre-hook function has the opportunity to inspect and modify these arguments before they are passed to the main method.</li>
</ul>
</li>
<li><strong>Return</strong>:<ul>
<li>Must return a tuple <code>(args, kwargs)</code>, which will be used as the new arguments for the main method. If the original arguments are not modified, the function should return them as received.</li>
</ul>
</li>
<li><strong>Method Signatures for Post-Hooks</strong>:</li>
<li><code>post_hook_method(*args, **kwargs)</code></li>
<li><strong>Arguments</strong>:<ul>
<li><code>*args</code>, <code>**kwargs</code>: The arguments and keyword arguments that were passed to the main method.</li>
<li><code>kwargs["result"]</code>: The value returned by the main method. This allows the post-hook to inspect and even alter the result before it is returned to the original caller.</li>
</ul>
</li>
<li><strong>Return</strong>:<ul>
<li>Can return a modified result, which will replace the original result of the main method, or simply return <code>kwargs["result"]</code> to return the original method result.
</li>
</ul>
</li>
<li>
<p>```python
def pre_processing_hook(<em>args, </em>*kwargs):
print("Pre-processing logic here")
# Modify arguments or perform any checks
return args, kwargs
# Return modified or unmodified args and kwargs</p>
<p>def post_processing_hook(<em>args, </em>*kwargs):
print("Post-processing logic here")
# Modify the result or perform any final logging or cleanup
return kwargs["result"]
# Return the modified or unmodified result</p>
<p>class Preload:
def <strong>init</strong>(self, connapp):
# Registering a pre-hook
connapp.ai.some_method.register_pre_hook(pre_processing_hook)</p>
<pre><code>    # Registering a post-hook
    connapp.node.another_method.register_post_hook(post_processing_hook)
</code></pre>
<p>```</p>
</li>
</ul>
<h3 id="executable-block">Executable Block</h3>
<ul>
<li>The plugin script can include an executable block:</li>
<li><code>if __name__ == "__main__":</code></li>
<li>This block allows the plugin to be run as a standalone script for testing or independent use.</li>
</ul>
<h3 id="script-verification">Script Verification</h3>
<ul>
<li>The <code>verify_script</code> method in <code>plugins.py</code> is used to check the plugin script's compliance with these standards.</li>
<li>Non-compliant scripts will be rejected to ensure consistency and proper functionality within the plugin system.</li>
<li></li>
</ul>
<h3 id="example-script">Example Script</h3>
<p>For a practical example of how to write a compatible plugin script, please refer to the following example:</p>
<p><a href="https://github.com/fluzzi/awspy">Example Plugin Script</a></p>
<p>This script demonstrates the required structure and implementation details according to the plugin system's standards.</p>
<h2 id="http-api">http API</h2>
<p>With the Connpy API you can run commands on devices using http requests</p>
<h3 id="1-list-nodes">1. List Nodes</h3>
<p><strong>Endpoint</strong>: <code>/list_nodes</code></p>
<p><strong>Method</strong>: <code>POST</code></p>
<p><strong>Description</strong>: This route returns a list of nodes. It can also filter the list based on a given keyword.</p>
<h4 id="request-body">Request Body:</h4>
<pre><code class="language-json">{
  &quot;filter&quot;: &quot;&lt;keyword&gt;&quot;
}
</code></pre>
<ul>
<li><code>filter</code> (optional): A keyword to filter the list of nodes. It returns only the nodes that contain the keyword. If not provided, the route will return the entire list of nodes.</li>
</ul>
<h4 id="response">Response:</h4>
<ul>
<li>A JSON array containing the filtered list of nodes.</li>
</ul>
<hr>
<h3 id="2-get-nodes">2. Get Nodes</h3>
<p><strong>Endpoint</strong>: <code>/get_nodes</code></p>
<p><strong>Method</strong>: <code>POST</code></p>
<p><strong>Description</strong>: This route returns a dictionary of nodes with all their attributes. It can also filter the nodes based on a given keyword.</p>
<h4 id="request-body_1">Request Body:</h4>
<pre><code class="language-json">{
  &quot;filter&quot;: &quot;&lt;keyword&gt;&quot;
}
</code></pre>
<ul>
<li><code>filter</code> (optional): A keyword to filter the nodes. It returns only the nodes that contain the keyword. If not provided, the route will return the entire list of nodes.</li>
</ul>
<h4 id="response_1">Response:</h4>
<ul>
<li>A JSON array containing the filtered nodes.</li>
</ul>
<hr>
<h3 id="3-run-commands">3. Run Commands</h3>
<p><strong>Endpoint</strong>: <code>/run_commands</code></p>
<p><strong>Method</strong>: <code>POST</code></p>
<p><strong>Description</strong>: This route runs commands on selected nodes based on the provided action, nodes, and commands. It also supports executing tests by providing expected results.</p>
<h4 id="request-body_2">Request Body:</h4>
<pre><code class="language-json">{
  &quot;action&quot;: &quot;&lt;action&gt;&quot;,
  &quot;nodes&quot;: &quot;&lt;nodes&gt;&quot;,
  &quot;commands&quot;: &quot;&lt;commands&gt;&quot;,
  &quot;expected&quot;: &quot;&lt;expected&gt;&quot;,
  &quot;options&quot;: &quot;&lt;options&gt;&quot;
}
</code></pre>
<ul>
<li><code>action</code> (required): The action to be performed. Possible values: <code>run</code> or <code>test</code>.</li>
<li><code><a title="connpy.nodes" href="#connpy.nodes">nodes</a></code> (required): A list of nodes or a single node on which the commands will be executed. The nodes can be specified as individual node names or a node group with the <code>@</code> prefix. Node groups can also be specified as arrays with a list of nodes inside the group.</li>
<li><code>commands</code> (required): A list of commands to be executed on the specified nodes.</li>
<li><code>expected</code> (optional, only used when the action is <code>test</code>): A single expected result for the test.</li>
<li><code>options</code> (optional): Array to pass options to the run command, options are: <code>prompt</code>, <code>parallel</code>, <code>timeout</code>
</li>
</ul>
<h4 id="response_2">Response:</h4>
<ul>
<li>A JSON object with the results of the executed commands on the nodes.</li>
</ul>
<hr>
<h3 id="4-ask-ai">4. Ask AI</h3>
<p><strong>Endpoint</strong>: <code>/ask_ai</code></p>
<p><strong>Method</strong>: <code>POST</code></p>
<p><strong>Description</strong>: This route sends to chatgpt IA a request that will parse it into an understandable output for the application and then run the request.</p>
<h4 id="request-body_3">Request Body:</h4>
<pre><code class="language-json">{
  &quot;input&quot;: &quot;&lt;user input request&gt;&quot;,
  &quot;dryrun&quot;: true or false
}
</code></pre>
<ul>
<li><code>input</code> (required): The user input requesting the AI to perform an action on some devices or get the devices list.</li>
<li><code>dryrun</code> (optional): If set to true, it will return the parameters to run the request but it won't run it. default is false.</li>
</ul>
<h4 id="response_3">Response:</h4>
<ul>
<li>A JSON array containing the action to run and the parameters and the result of the action.</li>
</ul>
<h2 id="automation-module">Automation module</h2>
<p>The automation module</p>
<h3 id="standalone-module">Standalone module</h3>
<pre><code>import connpy
router = connpy.node(&quot;uniqueName&quot;,&quot;ip/host&quot;, user=&quot;user&quot;, password=&quot;pass&quot;)
router.run([&quot;term len 0&quot;,&quot;show run&quot;])
print(router.output)
hasip = router.test(&quot;show ip int brief&quot;,&quot;1.1.1.1&quot;)
if hasip:
    print(&quot;Router has ip 1.1.1.1&quot;)
else:
    print(&quot;router does not have ip 1.1.1.1&quot;)
</code></pre>
<h3 id="using-manager-configuration">Using manager configuration</h3>
<pre><code>import connpy
conf = connpy.configfile()
device = conf.getitem(&quot;server@office&quot;)
server = connpy.node(&quot;unique name&quot;, **device, config=conf)
result = server.run([&quot;cd /&quot;, &quot;ls -la&quot;])
print(result)
</code></pre>
<h3 id="running-parallel-tasks">Running parallel tasks</h3>
<pre><code>import connpy
conf = connpy.configfile()
#You can get the nodes from the config from a folder and fitlering in it
nodes = conf.getitem(&quot;@office&quot;, [&quot;router1&quot;, &quot;router2&quot;, &quot;router3&quot;])
#You can also get each node individually:
nodes = {}
nodes[&quot;router1&quot;] = conf.getitem(&quot;router1@office&quot;)
nodes[&quot;router2&quot;] = conf.getitem(&quot;router2@office&quot;)
nodes[&quot;router10&quot;] = conf.getitem(&quot;router10@datacenter&quot;)
#Also, you can create the nodes manually:
nodes = {}
nodes[&quot;router1&quot;] = {&quot;host&quot;: &quot;1.1.1.1&quot;, &quot;user&quot;: &quot;user&quot;, &quot;password&quot;: &quot;pass1&quot;}
nodes[&quot;router2&quot;] = {&quot;host&quot;: &quot;1.1.1.2&quot;, &quot;user&quot;: &quot;user&quot;, &quot;password&quot;: &quot;pass2&quot;}
nodes[&quot;router3&quot;] = {&quot;host&quot;: &quot;1.1.1.2&quot;, &quot;user&quot;: &quot;user&quot;, &quot;password&quot;: &quot;pass3&quot;}
#Finally you run some tasks on the nodes
mynodes = connpy.nodes(nodes, config = conf)
result = mynodes.test([&quot;show ip int br&quot;], &quot;1.1.1.2&quot;)
for i in result:
    print(&quot;---&quot; + i + &quot;---&quot;)
    print(result[i])
    print()
# Or for one specific node
mynodes.router1.run([&quot;term len 0&quot;. &quot;show run&quot;], folder = &quot;/home/user/logs&quot;)
</code></pre>
<h3 id="using-variables">Using variables</h3>
<pre><code>import connpy
config = connpy.configfile()
nodes = config.getitem(&quot;@office&quot;, [&quot;router1&quot;, &quot;router2&quot;, &quot;router3&quot;])
commands = []
commands.append(&quot;config t&quot;)
commands.append(&quot;interface lo {id}&quot;)
commands.append(&quot;ip add {ip} {mask}&quot;)
commands.append(&quot;end&quot;)
variables = {}
variables[&quot;router1@office&quot;] = {&quot;ip&quot;: &quot;10.57.57.1&quot;}
variables[&quot;router2@office&quot;] = {&quot;ip&quot;: &quot;10.57.57.2&quot;}
variables[&quot;router3@office&quot;] = {&quot;ip&quot;: &quot;10.57.57.3&quot;}
variables[&quot;__global__&quot;] = {&quot;id&quot;: &quot;57&quot;}
variables[&quot;__global__&quot;][&quot;mask&quot;] =  &quot;255.255.255.255&quot;
expected = &quot;!&quot;
routers = connpy.nodes(nodes, config = config)
routers.run(commands, variables)
routers.test(&quot;ping {ip}&quot;, expected, variables)
for key in routers.result:
    print(key, ' ---&gt; ', (&quot;pass&quot; if routers.result[key] else &quot;fail&quot;))
</code></pre>
<h3 id="using-ai">Using AI</h3>
<pre><code>import connpy
conf = connpy.configfile()
organization = 'openai-org'
api_key = &quot;openai-key&quot;
myia = connpy.ai(conf, organization, api_key)
input = &quot;go to router 1 and get me the full configuration&quot;
result = myia.ask(input, dryrun = False)
print(result)
</code></pre>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="connpy.Plugins"><code class="flex name class">
<span>class <span class="ident">Plugins</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Plugins:
    def __init__(self):
        self.plugins = {}
        self.plugin_parsers = {}
        self.preloads = {}

    def verify_script(self, file_path):
        &#34;&#34;&#34;
        Verifies that a given Python script meets specific structural requirements.

        This function checks a Python script for compliance with predefined structural 
        rules. It ensures that the script contains only allowed top-level elements 
        (functions, classes, imports, pass statements, and a specific if __name__ block) 
        and that it includes mandatory classes with specific attributes and methods.

        ### Arguments:
            - file_path (str): The file path of the Python script to be verified.

        ### Returns:
            - str: A message indicating the type of violation if the script doesn&#39;t meet 
                 the requirements, or False if all requirements are met.

        ### Verifications:
            - The presence of only allowed top-level elements.
            - The existence of two specific classes: &#39;Parser&#39; and &#39;Entrypoint&#39;. and/or specific class: Preload.
            - &#39;Parser&#39; class must only have an &#39;__init__&#39; method and must assign &#39;self.parser&#39;
              and &#39;self.description&#39;.
            - &#39;Entrypoint&#39; class must have an &#39;__init__&#39; method accepting specific arguments.

        If any of these checks fail, the function returns an error message indicating 
        the reason. If the script passes all checks, the function returns False, 
        indicating successful verification.

        ### Exceptions:
                - SyntaxError: If the script contains a syntax error, it is caught and 
                               returned as a part of the error message.
        &#34;&#34;&#34;
        with open(file_path, &#39;r&#39;) as file:
            source_code = file.read()

        try:
            tree = ast.parse(source_code)
        except SyntaxError as e:
            return f&#34;Syntax error in file: {e}&#34;


        has_parser = False
        has_entrypoint = False
        has_preload = False

        for node in tree.body:
            # Allow only function definitions, class definitions, and pass statements at top-level
            if isinstance(node, ast.If):
                # Check for the &#39;if __name__ == &#34;__main__&#34;:&#39; block
                if not (isinstance(node.test, ast.Compare) and
                        isinstance(node.test.left, ast.Name) and
                        node.test.left.id == &#39;__name__&#39; and
                        isinstance(node.test.comparators[0], ast.Str) and
                        node.test.comparators[0].s == &#39;__main__&#39;):
                    return &#34;Only __name__ == __main__ If is allowed&#34;

            elif not isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.Import, ast.ImportFrom, ast.Pass)):
                return f&#34;Plugin can only have pass, functions, classes and imports. {node} is not allowed&#34;  # Reject any other AST types

            if isinstance(node, ast.ClassDef):

                if node.name == &#39;Parser&#39;:
                    has_parser = True
                    # Ensure Parser class has only the __init__ method and assigns self.parser
                    if not all(isinstance(method, ast.FunctionDef) and method.name == &#39;__init__&#39; for method in node.body):
                        return &#34;Parser class should only have __init__ method&#34;

                    # Check if &#39;self.parser&#39; and &#39;self.description&#39; are assigned in __init__ method
                    init_method = node.body[0]
                    assigned_attrs = [target.attr for expr in init_method.body if isinstance(expr, ast.Assign) for target in expr.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == &#39;self&#39;]
                    if &#39;parser&#39; not in assigned_attrs or &#39;description&#39; not in assigned_attrs:
                        return &#34;Parser class should set self.parser and self.description&#34; # &#39;self.parser&#39; or &#39;self.description&#39; not assigned in __init__

                elif node.name == &#39;Entrypoint&#39;:
                    has_entrypoint = True
                    init_method = next((item for item in node.body if isinstance(item, ast.FunctionDef) and item.name == &#39;__init__&#39;), None)
                    if not init_method or len(init_method.args.args) != 4:  # self, args, parser, conapp
                        return &#34;Entrypoint class should have method __init__ and accept only arguments: args, parser and connapp&#34;  # &#39;Entrypoint&#39; __init__ does not have correct signature

                elif node.name == &#39;Preload&#39;:
                    has_preload = True
                    init_method = next((item for item in node.body if isinstance(item, ast.FunctionDef) and item.name == &#39;__init__&#39;), None)
                    if not init_method or len(init_method.args.args) != 2:  # self, connapp
                        return &#34;Preload class should have method __init__ and accept only argument: connapp&#34;  # &#39;Preload&#39; __init__ does not have correct signature

        # Applying the combination logic based on class presence
        if has_parser and not has_entrypoint:
            return &#34;Parser requires Entrypoint class to be present.&#34;
        elif has_entrypoint and not has_parser:
            return &#34;Entrypoint requires Parser class to be present.&#34;
    
        if not (has_parser or has_entrypoint or has_preload):
            return &#34;No valid class (Parser, Entrypoint, or Preload) found.&#34;

        return False  # All requirements met, no error

    def _import_from_path(self, path):
        spec = importlib.util.spec_from_file_location(&#34;module.name&#34;, path)
        module = importlib.util.module_from_spec(spec)
        sys.modules[&#34;module.name&#34;] = module
        spec.loader.exec_module(module)
        return module

    def _import_plugins_to_argparse(self, directory, subparsers):
        for filename in os.listdir(directory):
            commands = subparsers.choices.keys()
            if filename.endswith(&#34;.py&#34;):
                root_filename = os.path.splitext(filename)[0]
                if root_filename in commands:
                    continue
                # Construct the full path
                filepath = os.path.join(directory, filename)
                check_file = self.verify_script(filepath)
                if check_file:
                    print(f&#34;Failed to load plugin: {filename}. Reason: {check_file}&#34;)
                    continue
                else:
                    self.plugins[root_filename] = self._import_from_path(filepath)
                    if hasattr(self.plugins[root_filename], &#34;Parser&#34;):
                        self.plugin_parsers[root_filename] = self.plugins[root_filename].Parser()
                        subparsers.add_parser(root_filename, parents=[self.plugin_parsers[root_filename].parser], add_help=False, description=self.plugin_parsers[root_filename].description)
                    if hasattr(self.plugins[root_filename], &#34;Preload&#34;):
                        self.preloads[root_filename] = self.plugins[root_filename]</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="connpy.Plugins.verify_script"><code class="name flex">
<span>def <span class="ident">verify_script</span></span>(<span>self, file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_script(self, file_path):
    &#34;&#34;&#34;
    Verifies that a given Python script meets specific structural requirements.

    This function checks a Python script for compliance with predefined structural 
    rules. It ensures that the script contains only allowed top-level elements 
    (functions, classes, imports, pass statements, and a specific if __name__ block) 
    and that it includes mandatory classes with specific attributes and methods.

    ### Arguments:
        - file_path (str): The file path of the Python script to be verified.

    ### Returns:
        - str: A message indicating the type of violation if the script doesn&#39;t meet 
             the requirements, or False if all requirements are met.

    ### Verifications:
        - The presence of only allowed top-level elements.
        - The existence of two specific classes: &#39;Parser&#39; and &#39;Entrypoint&#39;. and/or specific class: Preload.
        - &#39;Parser&#39; class must only have an &#39;__init__&#39; method and must assign &#39;self.parser&#39;
          and &#39;self.description&#39;.
        - &#39;Entrypoint&#39; class must have an &#39;__init__&#39; method accepting specific arguments.

    If any of these checks fail, the function returns an error message indicating 
    the reason. If the script passes all checks, the function returns False, 
    indicating successful verification.

    ### Exceptions:
            - SyntaxError: If the script contains a syntax error, it is caught and 
                           returned as a part of the error message.
    &#34;&#34;&#34;
    with open(file_path, &#39;r&#39;) as file:
        source_code = file.read()

    try:
        tree = ast.parse(source_code)
    except SyntaxError as e:
        return f&#34;Syntax error in file: {e}&#34;


    has_parser = False
    has_entrypoint = False
    has_preload = False

    for node in tree.body:
        # Allow only function definitions, class definitions, and pass statements at top-level
        if isinstance(node, ast.If):
            # Check for the &#39;if __name__ == &#34;__main__&#34;:&#39; block
            if not (isinstance(node.test, ast.Compare) and
                    isinstance(node.test.left, ast.Name) and
                    node.test.left.id == &#39;__name__&#39; and
                    isinstance(node.test.comparators[0], ast.Str) and
                    node.test.comparators[0].s == &#39;__main__&#39;):
                return &#34;Only __name__ == __main__ If is allowed&#34;

        elif not isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.Import, ast.ImportFrom, ast.Pass)):
            return f&#34;Plugin can only have pass, functions, classes and imports. {node} is not allowed&#34;  # Reject any other AST types

        if isinstance(node, ast.ClassDef):

            if node.name == &#39;Parser&#39;:
                has_parser = True
                # Ensure Parser class has only the __init__ method and assigns self.parser
                if not all(isinstance(method, ast.FunctionDef) and method.name == &#39;__init__&#39; for method in node.body):
                    return &#34;Parser class should only have __init__ method&#34;

                # Check if &#39;self.parser&#39; and &#39;self.description&#39; are assigned in __init__ method
                init_method = node.body[0]
                assigned_attrs = [target.attr for expr in init_method.body if isinstance(expr, ast.Assign) for target in expr.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == &#39;self&#39;]
                if &#39;parser&#39; not in assigned_attrs or &#39;description&#39; not in assigned_attrs:
                    return &#34;Parser class should set self.parser and self.description&#34; # &#39;self.parser&#39; or &#39;self.description&#39; not assigned in __init__

            elif node.name == &#39;Entrypoint&#39;:
                has_entrypoint = True
                init_method = next((item for item in node.body if isinstance(item, ast.FunctionDef) and item.name == &#39;__init__&#39;), None)
                if not init_method or len(init_method.args.args) != 4:  # self, args, parser, conapp
                    return &#34;Entrypoint class should have method __init__ and accept only arguments: args, parser and connapp&#34;  # &#39;Entrypoint&#39; __init__ does not have correct signature

            elif node.name == &#39;Preload&#39;:
                has_preload = True
                init_method = next((item for item in node.body if isinstance(item, ast.FunctionDef) and item.name == &#39;__init__&#39;), None)
                if not init_method or len(init_method.args.args) != 2:  # self, connapp
                    return &#34;Preload class should have method __init__ and accept only argument: connapp&#34;  # &#39;Preload&#39; __init__ does not have correct signature

    # Applying the combination logic based on class presence
    if has_parser and not has_entrypoint:
        return &#34;Parser requires Entrypoint class to be present.&#34;
    elif has_entrypoint and not has_parser:
        return &#34;Entrypoint requires Parser class to be present.&#34;

    if not (has_parser or has_entrypoint or has_preload):
        return &#34;No valid class (Parser, Entrypoint, or Preload) found.&#34;

    return False  # All requirements met, no error</code></pre>
</details>
<div class="desc"><p>Verifies that a given Python script meets specific structural requirements.</p>
<p>This function checks a Python script for compliance with predefined structural
rules. It ensures that the script contains only allowed top-level elements
(functions, classes, imports, pass statements, and a specific if <strong>name</strong> block)
and that it includes mandatory classes with specific attributes and methods.</p>
<h3 id="arguments">Arguments:</h3>
<pre><code>- file_path (str): The file path of the Python script to be verified.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>- str: A message indicating the type of violation if the script doesn't meet 
     the requirements, or False if all requirements are met.
</code></pre>
<h3 id="verifications">Verifications:</h3>
<pre><code>- The presence of only allowed top-level elements.
- The existence of two specific classes: 'Parser' and 'Entrypoint'. and/or specific class: Preload.
- 'Parser' class must only have an '__init__' method and must assign 'self.parser'
  and 'self.description'.
- 'Entrypoint' class must have an '__init__' method accepting specific arguments.
</code></pre>
<p>If any of these checks fail, the function returns an error message indicating
the reason. If the script passes all checks, the function returns False,
indicating successful verification.</p>
<h3 id="exceptions">Exceptions:</h3>
<pre><code>    - SyntaxError: If the script contains a syntax error, it is caught and 
                   returned as a part of the error message.
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="connpy.ai"><code class="flex name class">
<span>class <span class="ident">ai</span></span>
<span>(</span><span>config, org=None, api_key=None, model=None, temp=0.7)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@ClassHook
class ai:
    &#39;&#39;&#39; This class generates a ai object. Containts all the information and methods to make requests to openAI chatGPT to run actions on the application.

    ### Attributes:  

        - model        (str): Model of GPT api to use. Default is gpt-4o-mini.

        - temp       (float): Value between 0 and 1 that control the randomness 
                              of generated text, with higher values increasing 
                              creativity. Default is 0.7.

        &#39;&#39;&#39;

    def __init__(self, config, org = None, api_key = None, model = None, temp = 0.7):
        &#39;&#39;&#39; 
            
        ### Parameters:  

            - config (obj): Pass the object created with class configfile with 
                            key for decryption and extra configuration if you 
                            are using connection manager.  

        ### Optional Parameters:  

            - org     (str): A unique token identifying the user organization
                             to interact with the API.

            - api_key (str): A unique authentication token required to access 
                             and interact with the API.

            - model   (str): Model of GPT api to use. Default is gpt-4o-mini. 

            - temp  (float): Value between 0 and 1 that control the randomness 
                             of generated text, with higher values increasing 
                             creativity. Default is 0.7.
   

        &#39;&#39;&#39;
        self.config = config
        if org:
            openai.organization = org
        else:
            try: 
                openai.organization = self.config.config[&#34;openai&#34;][&#34;organization&#34;]
            except:
                raise ValueError(&#34;Missing openai organization&#34;)
        if api_key:
            openai.api_key = api_key
        else:
            try: 
                openai.api_key = self.config.config[&#34;openai&#34;][&#34;api_key&#34;]
            except:
                raise ValueError(&#34;Missing openai api_key&#34;)
        if model:
            self.model = model
        else:
            try:
                self.model = self.config.config[&#34;openai&#34;][&#34;model&#34;]
            except:
                self.model = &#34;gpt-4o-mini&#34;
        self.temp = temp
        self.__prompt = {}
        self.__prompt[&#34;original_system&#34;] = &#34;&#34;&#34;
            You are the AI chatbot and assistant of a network connection manager and automation app called connpy. When provided with user input analyze the input and extract the following information. If user wants to chat just reply and don&#39;t call a function:

            - type: Given a user input, identify the type of request they want to make. The input will represent one of two options: 

                1. &#34;command&#34; - The user wants to get information from devices by running commands.
                2. &#34;list_nodes&#34; - The user wants to get a list of nodes, devices, servers, or routers.
                The &#39;type&#39; field should reflect whether the user input is a command or a request for a list of nodes.

            - filter: One or more regex patterns indicating the device or group of devices the command should be run on. The filter can have different formats, such as:
                - hostname
                - hostname@folder
                - hostname@subfolder@folder
                - partofhostname
                - @folder
                - @subfolder@folder
                - regex_pattern

                The filter should be extracted from the user input exactly as it was provided.
                Always preserve the exact filter pattern provided by the user, with no modifications. Do not process any regex, the application can do that.

    &#34;&#34;&#34; 
        self.__prompt[&#34;original_user&#34;] = &#34;Get the IP addresses of loopback0 for all routers from w2az1 and e1.*(prod|dev) and check if they have the ip 192.168.1.1&#34;
        self.__prompt[&#34;original_assistant&#34;] = {&#34;name&#34;: &#34;get_network_device_info&#34;, &#34;arguments&#34;: &#34;{\n  \&#34;type\&#34;: \&#34;command\&#34;,\n  \&#34;filter\&#34;: [\&#34;w2az1\&#34;,\&#34;e1.*(prod|dev)\&#34;]\n}&#34;}
        self.__prompt[&#34;original_function&#34;] = {}
        self.__prompt[&#34;original_function&#34;][&#34;name&#34;] = &#34;get_network_device_info&#34;
        self.__prompt[&#34;original_function&#34;][&#34;descriptions&#34;] = &#34;You are the AI chatbot and assistant of a network connection manager and automation app called connpy. When provided with user input analyze the input and extract the information acording to the function, If user wants to chat just reply and don&#39;t call a function&#34;,
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;] = {}
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;type&#34;] = &#34;object&#34;
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;] = {}
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;type&#34;] = {}
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;type&#34;][&#34;type&#34;] = &#34;string&#34;
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;type&#34;][&#34;description&#34;] =&#34;&#34;&#34;
Categorize the user&#39;s request based on the operation they want to perform on the nodes. The requests can be classified into the following categories:

    1. &#34;command&#34; - This represents a request to retrieve specific information or configurations from nodes. An example would be: &#34;go to routers in @office and get the config&#34;.

    2. &#34;list_nodes&#34; - This is when the user wants a list of nodes. An example could be: &#34;get me the nodes in @office&#34;.
&#34;&#34;&#34;
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;type&#34;][&#34;enum&#34;] = [&#34;command&#34;, &#34;list_nodes&#34;]
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;filter&#34;] = {}
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;filter&#34;][&#34;type&#34;] = &#34;array&#34;
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;filter&#34;][&#34;items&#34;] = {}
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;filter&#34;][&#34;items&#34;][&#34;type&#34;] = &#34;string&#34;
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;filter&#34;][&#34;items&#34;][&#34;description&#34;] = &#34;&#34;&#34;One or more regex patterns indicating the device or group of devices the command should be run on.  The filter should be extracted from the user input exactly as it was provided. 
                The filter can have different formats, such as:
                - hostname
                - hostname@folder
                - hostname@subfolder@folder
                - partofhostname
                - @folder
                - @subfolder@folder
                - regex_pattern
                &#34;&#34;&#34;
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;required&#34;] = [&#34;type&#34;, &#34;filter&#34;]
        self.__prompt[&#34;command_system&#34;] = &#34;&#34;&#34;
        For each OS listed below, provide the command(s) needed to perform the specified action, depending on the device OS (e.g., Cisco IOSXR router, Linux server).
        The application knows how to connect to devices via SSH, so you only need to provide the command(s) to run after connecting. This includes access configuration mode and commiting if required.
        If the commands needed are not for the specific OS type, just send an empty list (e.g., []). 
        Note: Preserving the integrity of user-provided commands is of utmost importance. If a user has provided a specific command to run, include that command exactly as it was given, even if it&#39;s not recognized or understood. Under no circumstances should you modify or alter user-provided commands.
    &#34;&#34;&#34;
        self.__prompt[&#34;command_user&#34;]= &#34;&#34;&#34;
    input: show me the full configuration for all this devices:

    OS:
    cisco ios:
    &#34;&#34;&#34;
        self.__prompt[&#34;command_assistant&#34;] = {&#34;name&#34;: &#34;get_commands&#34;, &#34;arguments&#34;: &#34;{\n  \&#34;cisco ios\&#34;: \&#34;show running-configuration\&#34;\n}&#34;}
        self.__prompt[&#34;command_function&#34;] = {}
        self.__prompt[&#34;command_function&#34;][&#34;name&#34;] = &#34;get_commands&#34;
        self.__prompt[&#34;command_function&#34;][&#34;descriptions&#34;] = &#34;&#34;&#34; 
        For each OS listed below, provide the command(s) needed to perform the specified action, depending on the device OS (e.g., Cisco IOSXR router, Linux server).
        The application knows how to connect to devices via SSH, so you only need to provide the command(s) to run after connecting. This includes access configuration mode and commiting if required.
        If the commands needed are not for the specific OS type, just send an empty list (e.g., []). 
    &#34;&#34;&#34;
        self.__prompt[&#34;command_function&#34;][&#34;parameters&#34;] = {}
        self.__prompt[&#34;command_function&#34;][&#34;parameters&#34;][&#34;type&#34;] = &#34;object&#34;
        self.__prompt[&#34;command_function&#34;][&#34;parameters&#34;][&#34;properties&#34;] = {}
        self.__prompt[&#34;confirmation_system&#34;] = &#34;&#34;&#34;
        Please analyze the user&#39;s input and categorize it as either an affirmation or negation. Based on this analysis, respond with:

            &#39;true&#39; if the input is an affirmation like &#39;do it&#39;, &#39;go ahead&#39;, &#39;sure&#39;, etc.
            &#39;false&#39; if the input is a negation.
            &#39;none&#39; If the input does not fit into either of these categories.
            &#34;&#34;&#34;
        self.__prompt[&#34;confirmation_user&#34;] = &#34;Yes go ahead!&#34;
        self.__prompt[&#34;confirmation_assistant&#34;] = &#34;True&#34;
        self.__prompt[&#34;confirmation_function&#34;] = {}
        self.__prompt[&#34;confirmation_function&#34;][&#34;name&#34;] = &#34;get_confirmation&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;descriptions&#34;] = &#34;&#34;&#34; 
        Analize user request and respond:
    &#34;&#34;&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;] = {}
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;type&#34;] = &#34;object&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;] = {}
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;result&#34;] = {}
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;result&#34;][&#34;description&#34;] = &#34;&#34;&#34;&#39;true&#39; if the input is an affirmation like &#39;do it&#39;, &#39;go ahead&#39;, &#39;sure&#39;, etc.
&#39;false&#39; if the input is a negation.
&#39;none&#39; If the input does not fit into either of these categories&#34;&#34;&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;result&#34;][&#34;type&#34;] = &#34;string&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;result&#34;][&#34;enum&#34;] = [&#34;true&#34;, &#34;false&#34;, &#34;none&#34;]
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;response&#34;] = {}
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;response&#34;][&#34;description&#34;] = &#34;If the user don&#39;t message is not an affiramtion or negation, kindly ask the user to rephrase.&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;response&#34;][&#34;type&#34;] = &#34;string&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;required&#34;] = [&#34;result&#34;]

    @MethodHook
    def _retry_function(self, function, max_retries, backoff_num, *args):
        #Retry openai requests
        retries = 0
        while retries &lt; max_retries:
            try:
                myfunction = function(*args)
                break
            except:
                wait_time = backoff_num * (2 ** retries)
                time.sleep(wait_time)
                retries += 1
                continue
        if retries == max_retries:
            myfunction = False
        return myfunction

    @MethodHook
    def _clean_command_response(self, raw_response, node_list):
        # Parse response for command request to openAI GPT.
        info_dict = {}
        info_dict[&#34;commands&#34;] = []
        info_dict[&#34;variables&#34;] = {}
        info_dict[&#34;variables&#34;][&#34;__global__&#34;] = {}
        for key, value in node_list.items():
            newvalue = {}
            commands = raw_response[value]
            # Ensure commands is a list
            if isinstance(commands, str):
                commands = [commands]
            # Determine the number of digits required for zero-padding
            num_commands = len(commands)
            num_digits = len(str(num_commands))

            for i, e in enumerate(commands, start=1):
                # Zero-pad the command number
                command_num = f&#34;command{str(i).zfill(num_digits)}&#34;
                newvalue[command_num] = e
                if f&#34;{{command{i}}}&#34; not in info_dict[&#34;commands&#34;]:
                    info_dict[&#34;commands&#34;].append(f&#34;{{{command_num}}}&#34;)
                    info_dict[&#34;variables&#34;][&#34;__global__&#34;][command_num] = &#34;&#34;
                info_dict[&#34;variables&#34;][key] = newvalue
        return info_dict


    @MethodHook
    def _get_commands(self, user_input, nodes):
        #Send the request for commands for each device to openAI GPT.
        output_list = []
        command_function = deepcopy(self.__prompt[&#34;command_function&#34;])
        node_list = {}
        for key, value in nodes.items():
            tags = value.get(&#39;tags&#39;, {})
            try:
                if os_value := tags.get(&#39;os&#39;):
                    node_list[key] = os_value
                    output_list.append(f&#34;{os_value}&#34;)
                    command_function[&#34;parameters&#34;][&#34;properties&#34;][os_value] = {}
                    command_function[&#34;parameters&#34;][&#34;properties&#34;][os_value][&#34;type&#34;] = &#34;array&#34;
                    command_function[&#34;parameters&#34;][&#34;properties&#34;][os_value][&#34;description&#34;] = f&#34;OS: {os_value}&#34;
                    command_function[&#34;parameters&#34;][&#34;properties&#34;][os_value][&#34;items&#34;] = {}
                    command_function[&#34;parameters&#34;][&#34;properties&#34;][os_value][&#34;items&#34;][&#34;type&#34;] = &#34;string&#34; 
            except:
                pass
        output_str = &#34;\n&#34;.join(list(set(output_list)))
        command_input = f&#34;input: {user_input}\n\nOS:\n{output_str}&#34;
        message = []
        message.append({&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: dedent(self.__prompt[&#34;command_system&#34;]).strip()})
        message.append({&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: dedent(self.__prompt[&#34;command_user&#34;]).strip()})
        message.append({&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: None, &#34;function_call&#34;: self.__prompt[&#34;command_assistant&#34;]})
        message.append({&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: command_input})
        functions = [command_function]
        response = openai.ChatCompletion.create(
            model=self.model,
            messages=message,
            functions=functions,
            function_call={&#34;name&#34;: &#34;get_commands&#34;},
            temperature=self.temp
            )
        output = {}
        result = response[&#34;choices&#34;][0][&#34;message&#34;].to_dict()
        json_result = json.loads(result[&#34;function_call&#34;][&#34;arguments&#34;])
        output[&#34;response&#34;] = self._clean_command_response(json_result, node_list)
        return output

    @MethodHook
    def _get_filter(self, user_input, chat_history = None):
        #Send the request to identify the filter and other attributes from the user input to GPT.
        message = []
        message.append({&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: dedent(self.__prompt[&#34;original_system&#34;]).strip()})
        message.append({&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: dedent(self.__prompt[&#34;original_user&#34;]).strip()})
        message.append({&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: None, &#34;function_call&#34;: self.__prompt[&#34;original_assistant&#34;]})
        functions = [self.__prompt[&#34;original_function&#34;]]
        if not chat_history:
            chat_history = []
        chat_history.append({&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: user_input})
        message.extend(chat_history)
        response = openai.ChatCompletion.create(
            model=self.model,
            messages=message,
            functions=functions,
            function_call=&#34;auto&#34;,
            temperature=self.temp,
            top_p=1
            )

        def extract_quoted_strings(text):
            pattern = r&#39;[&#34;\&#39;](.*?)[&#34;\&#39;]&#39;
            matches = re.findall(pattern, text)
            return matches
        expected = extract_quoted_strings(user_input)
        output = {}
        result = response[&#34;choices&#34;][0][&#34;message&#34;].to_dict()
        if result[&#34;content&#34;]:
            output[&#34;app_related&#34;] = False
            chat_history.append({&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: result[&#34;content&#34;]})
            output[&#34;response&#34;] = result[&#34;content&#34;]
        else:
            json_result = json.loads(result[&#34;function_call&#34;][&#34;arguments&#34;])
            output[&#34;app_related&#34;] = True
            output[&#34;filter&#34;] = json_result[&#34;filter&#34;]
            output[&#34;type&#34;] = json_result[&#34;type&#34;]
            chat_history.append({&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: result[&#34;content&#34;], &#34;function_call&#34;: {&#34;name&#34;: result[&#34;function_call&#34;][&#34;name&#34;], &#34;arguments&#34;: json.dumps(json_result)}})
        output[&#34;expected&#34;] = expected
        output[&#34;chat_history&#34;] = chat_history
        return output
        
    @MethodHook
    def _get_confirmation(self, user_input):
        #Send the request to identify if user is confirming or denying the task
        message = []
        message.append({&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: user_input})
        functions = [self.__prompt[&#34;confirmation_function&#34;]]
        response = openai.ChatCompletion.create(
            model=self.model,
            messages=message,
            functions=functions,
            function_call={&#34;name&#34;: &#34;get_confirmation&#34;},
            temperature=self.temp,
            top_p=1
            )
        result = response[&#34;choices&#34;][0][&#34;message&#34;].to_dict()
        json_result = json.loads(result[&#34;function_call&#34;][&#34;arguments&#34;])
        output = {}
        if json_result[&#34;result&#34;] == &#34;true&#34;:
            output[&#34;result&#34;] = True
        elif json_result[&#34;result&#34;] == &#34;false&#34;:
            output[&#34;result&#34;] = False
        elif json_result[&#34;result&#34;] == &#34;none&#34;:
            output[&#34;result&#34;] = json_result[&#34;response&#34;]
        return output

    @MethodHook
    def confirm(self, user_input, max_retries=3, backoff_num=1):
        &#39;&#39;&#39;
        Send the user input to openAI GPT and verify if response is afirmative or negative.

        ### Parameters:  

            - user_input (str): User response confirming or denying.

        ### Optional Parameters:  

            - max_retries (int): Maximum number of retries for gpt api.
            - backoff_num (int): Backoff factor for exponential wait time
                                 between retries.

        ### Returns:  

            bool or str: True, False or str if AI coudn&#39;t understand the response
        &#39;&#39;&#39;
        result = self._retry_function(self._get_confirmation, max_retries, backoff_num, user_input)
        if result:
            output = result[&#34;result&#34;]
        else:
            output = f&#34;{self.model} api is not responding right now, please try again later.&#34;
        return output

    @MethodHook
    def ask(self, user_input, dryrun = False, chat_history = None,  max_retries=3, backoff_num=1):
        &#39;&#39;&#39;
        Send the user input to openAI GPT and parse the response to run an action in the application.

        ### Parameters:  

            - user_input (str): Request to send to openAI that will be parsed
                                and returned to execute on the application.
                                AI understands the following tasks:
                                - Run a command on a group of devices.
                                - List a group of devices.
                                - Test a command on a group of devices
                                  and verify if the output contain an
                                  expected value.

        ### Optional Parameters:  

            - dryrun       (bool): Set to true to get the arguments to use to
                                   run in the app. Default is false and it
                                   will run the actions directly.
            - chat_history (list): List in gpt api format for the chat history.
            - max_retries   (int): Maximum number of retries for gpt api.
            - backoff_num   (int): Backoff factor for exponential wait time
                                   between retries.

        ### Returns:  

            dict: Dictionary formed with the following keys:
                  - input: User input received
                  - app_related: True if GPT detected the request to be related
                    to the application.
                  - dryrun: True/False
                  - response: If the request is not related to the app. this
                    key will contain chatGPT answer.
                  - action: The action detected by the AI to run in the app.
                  - filter: If it was detected by the AI, the filter used
                    to get the list of nodes to work on.
                  - nodes: If it&#39;s not a dryrun, the list of nodes matched by
                    the filter.
                  - args: A dictionary of arguments required to run command(s)
                    on the nodes.
                  - result: A dictionary with the output of the commands or 
                    the test.
                  - chat_history: The chat history between user and chatbot.
                    It can be used as an attribute for next request.
                
                    

        &#39;&#39;&#39;
        output = {}
        output[&#34;dryrun&#34;] = dryrun
        output[&#34;input&#34;] = user_input
        original = self._retry_function(self._get_filter, max_retries, backoff_num, user_input, chat_history)
        if not original:
            output[&#34;app_related&#34;] = False
            output[&#34;response&#34;] = f&#34;{self.model} api is not responding right now, please try again later.&#34;
            return output
        output[&#34;app_related&#34;] = original[&#34;app_related&#34;]
        output[&#34;chat_history&#34;] = original[&#34;chat_history&#34;]
        if not output[&#34;app_related&#34;]:
            output[&#34;response&#34;] = original[&#34;response&#34;]
        else:
            type = original[&#34;type&#34;]
            if &#34;filter&#34; in original:
                output[&#34;filter&#34;] = original[&#34;filter&#34;]
                if not self.config.config[&#34;case&#34;]:
                    if isinstance(output[&#34;filter&#34;], list):
                        output[&#34;filter&#34;] = [item.lower() for item in output[&#34;filter&#34;]]
                    else:
                        output[&#34;filter&#34;] = output[&#34;filter&#34;].lower()
                if not dryrun or type == &#34;command&#34;:
                    thisnodes = self.config._getallnodesfull(output[&#34;filter&#34;])
                    output[&#34;nodes&#34;] = list(thisnodes.keys())
            if not type == &#34;command&#34;:
                output[&#34;action&#34;] = &#34;list_nodes&#34;
            else:
                if thisnodes:
                    commands = self._retry_function(self._get_commands, max_retries, backoff_num, user_input, thisnodes)
                else:
                    output[&#34;app_related&#34;] = False
                    filterlist = &#34;, &#34;.join(output[&#34;filter&#34;])
                    output[&#34;response&#34;] = f&#34;I&#39;m sorry, I coudn&#39;t find any device with filter{&#39;s&#39; if len(output[&#39;filter&#39;]) != 1 else &#39;&#39;}: {filterlist}.&#34;
                    return output
                if not commands:
                    output[&#34;app_related&#34;] = False
                    output[&#34;response&#34;] = f&#34;{self.model} api is not responding right now, please try again later.&#34;
                    return output
                output[&#34;args&#34;] = {}
                output[&#34;args&#34;][&#34;commands&#34;] = commands[&#34;response&#34;][&#34;commands&#34;]
                output[&#34;args&#34;][&#34;vars&#34;] = commands[&#34;response&#34;][&#34;variables&#34;]
                output[&#34;nodes&#34;] = [item for item in output[&#34;nodes&#34;] if output[&#34;args&#34;][&#34;vars&#34;].get(item)]
                if original.get(&#34;expected&#34;):
                    output[&#34;args&#34;][&#34;expected&#34;] = original[&#34;expected&#34;]
                    output[&#34;action&#34;] = &#34;test&#34;
                else:
                    output[&#34;action&#34;] = &#34;run&#34;
                if dryrun:
                    output[&#34;task&#34;] = []
                    if output[&#34;action&#34;] == &#34;test&#34;:
                        output[&#34;task&#34;].append({&#34;Task&#34;: &#34;Verify if expected value is in command(s) output&#34;})
                        output[&#34;task&#34;].append({&#34;Expected value to verify&#34;: output[&#34;args&#34;][&#34;expected&#34;]})
                    elif output[&#34;action&#34;] == &#34;run&#34;:
                        output[&#34;task&#34;].append({&#34;Task&#34;: &#34;Run command(s) on devices and return output&#34;})
                    varstocommands = deepcopy(output[&#34;args&#34;][&#34;vars&#34;])
                    del varstocommands[&#34;__global__&#34;]
                    output[&#34;task&#34;].append({&#34;Devices&#34;: varstocommands})
                if not dryrun:
                    mynodes = nodes(self.config.getitems(output[&#34;nodes&#34;]),config=self.config)
                    if output[&#34;action&#34;] == &#34;test&#34;:
                        output[&#34;result&#34;] = mynodes.test(**output[&#34;args&#34;])
                        output[&#34;logs&#34;] = mynodes.output
                    elif output[&#34;action&#34;] == &#34;run&#34;:
                        output[&#34;result&#34;] = mynodes.run(**output[&#34;args&#34;])
        return output</code></pre>
</details>
<div class="desc"><p>This class generates a ai object. Containts all the information and methods to make requests to openAI chatGPT to run actions on the application.</p>
<h3 id="attributes">Attributes:</h3>
<pre><code>- model        (str): Model of GPT api to use. Default is gpt-4o-mini.

- temp       (float): Value between 0 and 1 that control the randomness 
                      of generated text, with higher values increasing 
                      creativity. Default is 0.7.
</code></pre>
<h3 id="parameters">Parameters:</h3>
<pre><code>- config (obj): Pass the object created with class configfile with 
                key for decryption and extra configuration if you 
                are using connection manager.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- org     (str): A unique token identifying the user organization
                 to interact with the API.

- api_key (str): A unique authentication token required to access 
                 and interact with the API.

- model   (str): Model of GPT api to use. Default is gpt-4o-mini.

- temp  (float): Value between 0 and 1 that control the randomness 
                 of generated text, with higher values increasing 
                 creativity. Default is 0.7.
</code></pre></div>
<h3>Methods</h3>
<dl>
<dt id="connpy.ai.ask"><code class="name flex">
<span>def <span class="ident">ask</span></span>(<span>self, user_input, dryrun=False, chat_history=None, max_retries=3, backoff_num=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@MethodHook
def ask(self, user_input, dryrun = False, chat_history = None,  max_retries=3, backoff_num=1):
    &#39;&#39;&#39;
    Send the user input to openAI GPT and parse the response to run an action in the application.

    ### Parameters:  

        - user_input (str): Request to send to openAI that will be parsed
                            and returned to execute on the application.
                            AI understands the following tasks:
                            - Run a command on a group of devices.
                            - List a group of devices.
                            - Test a command on a group of devices
                              and verify if the output contain an
                              expected value.

    ### Optional Parameters:  

        - dryrun       (bool): Set to true to get the arguments to use to
                               run in the app. Default is false and it
                               will run the actions directly.
        - chat_history (list): List in gpt api format for the chat history.
        - max_retries   (int): Maximum number of retries for gpt api.
        - backoff_num   (int): Backoff factor for exponential wait time
                               between retries.

    ### Returns:  

        dict: Dictionary formed with the following keys:
              - input: User input received
              - app_related: True if GPT detected the request to be related
                to the application.
              - dryrun: True/False
              - response: If the request is not related to the app. this
                key will contain chatGPT answer.
              - action: The action detected by the AI to run in the app.
              - filter: If it was detected by the AI, the filter used
                to get the list of nodes to work on.
              - nodes: If it&#39;s not a dryrun, the list of nodes matched by
                the filter.
              - args: A dictionary of arguments required to run command(s)
                on the nodes.
              - result: A dictionary with the output of the commands or 
                the test.
              - chat_history: The chat history between user and chatbot.
                It can be used as an attribute for next request.
            
                

    &#39;&#39;&#39;
    output = {}
    output[&#34;dryrun&#34;] = dryrun
    output[&#34;input&#34;] = user_input
    original = self._retry_function(self._get_filter, max_retries, backoff_num, user_input, chat_history)
    if not original:
        output[&#34;app_related&#34;] = False
        output[&#34;response&#34;] = f&#34;{self.model} api is not responding right now, please try again later.&#34;
        return output
    output[&#34;app_related&#34;] = original[&#34;app_related&#34;]
    output[&#34;chat_history&#34;] = original[&#34;chat_history&#34;]
    if not output[&#34;app_related&#34;]:
        output[&#34;response&#34;] = original[&#34;response&#34;]
    else:
        type = original[&#34;type&#34;]
        if &#34;filter&#34; in original:
            output[&#34;filter&#34;] = original[&#34;filter&#34;]
            if not self.config.config[&#34;case&#34;]:
                if isinstance(output[&#34;filter&#34;], list):
                    output[&#34;filter&#34;] = [item.lower() for item in output[&#34;filter&#34;]]
                else:
                    output[&#34;filter&#34;] = output[&#34;filter&#34;].lower()
            if not dryrun or type == &#34;command&#34;:
                thisnodes = self.config._getallnodesfull(output[&#34;filter&#34;])
                output[&#34;nodes&#34;] = list(thisnodes.keys())
        if not type == &#34;command&#34;:
            output[&#34;action&#34;] = &#34;list_nodes&#34;
        else:
            if thisnodes:
                commands = self._retry_function(self._get_commands, max_retries, backoff_num, user_input, thisnodes)
            else:
                output[&#34;app_related&#34;] = False
                filterlist = &#34;, &#34;.join(output[&#34;filter&#34;])
                output[&#34;response&#34;] = f&#34;I&#39;m sorry, I coudn&#39;t find any device with filter{&#39;s&#39; if len(output[&#39;filter&#39;]) != 1 else &#39;&#39;}: {filterlist}.&#34;
                return output
            if not commands:
                output[&#34;app_related&#34;] = False
                output[&#34;response&#34;] = f&#34;{self.model} api is not responding right now, please try again later.&#34;
                return output
            output[&#34;args&#34;] = {}
            output[&#34;args&#34;][&#34;commands&#34;] = commands[&#34;response&#34;][&#34;commands&#34;]
            output[&#34;args&#34;][&#34;vars&#34;] = commands[&#34;response&#34;][&#34;variables&#34;]
            output[&#34;nodes&#34;] = [item for item in output[&#34;nodes&#34;] if output[&#34;args&#34;][&#34;vars&#34;].get(item)]
            if original.get(&#34;expected&#34;):
                output[&#34;args&#34;][&#34;expected&#34;] = original[&#34;expected&#34;]
                output[&#34;action&#34;] = &#34;test&#34;
            else:
                output[&#34;action&#34;] = &#34;run&#34;
            if dryrun:
                output[&#34;task&#34;] = []
                if output[&#34;action&#34;] == &#34;test&#34;:
                    output[&#34;task&#34;].append({&#34;Task&#34;: &#34;Verify if expected value is in command(s) output&#34;})
                    output[&#34;task&#34;].append({&#34;Expected value to verify&#34;: output[&#34;args&#34;][&#34;expected&#34;]})
                elif output[&#34;action&#34;] == &#34;run&#34;:
                    output[&#34;task&#34;].append({&#34;Task&#34;: &#34;Run command(s) on devices and return output&#34;})
                varstocommands = deepcopy(output[&#34;args&#34;][&#34;vars&#34;])
                del varstocommands[&#34;__global__&#34;]
                output[&#34;task&#34;].append({&#34;Devices&#34;: varstocommands})
            if not dryrun:
                mynodes = nodes(self.config.getitems(output[&#34;nodes&#34;]),config=self.config)
                if output[&#34;action&#34;] == &#34;test&#34;:
                    output[&#34;result&#34;] = mynodes.test(**output[&#34;args&#34;])
                    output[&#34;logs&#34;] = mynodes.output
                elif output[&#34;action&#34;] == &#34;run&#34;:
                    output[&#34;result&#34;] = mynodes.run(**output[&#34;args&#34;])
    return output</code></pre>
</details>
<div class="desc"><p>Send the user input to openAI GPT and parse the response to run an action in the application.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- user_input (str): Request to send to openAI that will be parsed
                    and returned to execute on the application.
                    AI understands the following tasks:
                    - Run a command on a group of devices.
                    - List a group of devices.
                    - Test a command on a group of devices
                      and verify if the output contain an
                      expected value.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- dryrun       (bool): Set to true to get the arguments to use to
                       run in the app. Default is false and it
                       will run the actions directly.
- chat_history (list): List in gpt api format for the chat history.
- max_retries   (int): Maximum number of retries for gpt api.
- backoff_num   (int): Backoff factor for exponential wait time
                       between retries.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>dict: Dictionary formed with the following keys:
      - input: User input received
      - app_related: True if GPT detected the request to be related
        to the application.
      - dryrun: True/False
      - response: If the request is not related to the app. this
        key will contain chatGPT answer.
      - action: The action detected by the AI to run in the app.
      - filter: If it was detected by the AI, the filter used
        to get the list of nodes to work on.
      - nodes: If it's not a dryrun, the list of nodes matched by
        the filter.
      - args: A dictionary of arguments required to run command(s)
        on the nodes.
      - result: A dictionary with the output of the commands or 
        the test.
      - chat_history: The chat history between user and chatbot.
        It can be used as an attribute for next request.
</code></pre></div>
</dd>
<dt id="connpy.ai.confirm"><code class="name flex">
<span>def <span class="ident">confirm</span></span>(<span>self, user_input, max_retries=3, backoff_num=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@MethodHook
def confirm(self, user_input, max_retries=3, backoff_num=1):
    &#39;&#39;&#39;
    Send the user input to openAI GPT and verify if response is afirmative or negative.

    ### Parameters:  

        - user_input (str): User response confirming or denying.

    ### Optional Parameters:  

        - max_retries (int): Maximum number of retries for gpt api.
        - backoff_num (int): Backoff factor for exponential wait time
                             between retries.

    ### Returns:  

        bool or str: True, False or str if AI coudn&#39;t understand the response
    &#39;&#39;&#39;
    result = self._retry_function(self._get_confirmation, max_retries, backoff_num, user_input)
    if result:
        output = result[&#34;result&#34;]
    else:
        output = f&#34;{self.model} api is not responding right now, please try again later.&#34;
    return output</code></pre>
</details>
<div class="desc"><p>Send the user input to openAI GPT and verify if response is afirmative or negative.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- user_input (str): User response confirming or denying.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- max_retries (int): Maximum number of retries for gpt api.
- backoff_num (int): Backoff factor for exponential wait time
                     between retries.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>bool or str: True, False or str if AI coudn't understand the response
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="connpy.configfile"><code class="flex name class">
<span>class <span class="ident">configfile</span></span>
<span>(</span><span>conf=None, key=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@ClassHook
class configfile:
    &#39;&#39;&#39; This class generates a configfile object. Containts a dictionary storing, config, nodes and profiles, normaly used by connection manager.

    ### Attributes:  

        - file         (str): Path/file to config file.

        - key          (str): Path/file to RSA key file.

        - config      (dict): Dictionary containing information of connection
                              manager configuration.

        - connections (dict): Dictionary containing all the nodes added to
                              connection manager.

        - profiles    (dict): Dictionary containing all the profiles added to
                              connection manager.

        - privatekey   (obj): Object containing the private key to encrypt 
                              passwords.

        - publickey    (obj): Object containing the public key to decrypt 
                              passwords.
        &#39;&#39;&#39;

    def __init__(self, conf = None, key = None):
        &#39;&#39;&#39; 
            
        ### Optional Parameters:  

            - conf (str): Path/file to config file. If left empty default
                          path is ~/.config/conn/config.json

            - key  (str): Path/file to RSA key file. If left empty default
                          path is ~/.config/conn/.osk

        &#39;&#39;&#39;
        home = os.path.expanduser(&#34;~&#34;)
        defaultdir = home + &#39;/.config/conn&#39;
        self.defaultdir = defaultdir
        Path(defaultdir).mkdir(parents=True, exist_ok=True)
        Path(f&#34;{defaultdir}/plugins&#34;).mkdir(parents=True, exist_ok=True)
        pathfile = defaultdir + &#39;/.folder&#39;
        try:
            with open(pathfile, &#34;r&#34;) as f:
                configdir = f.read().strip()
        except:
            with open(pathfile, &#34;w&#34;) as f:
                f.write(str(defaultdir))
            configdir = defaultdir
        defaultfile = configdir + &#39;/config.json&#39;
        defaultkey = configdir + &#39;/.osk&#39;
        if conf == None:
            self.file = defaultfile
        else:
            self.file = conf
        if key == None:
            self.key = defaultkey
        else:
            self.key = key
        if os.path.exists(self.file):
            config = self._loadconfig(self.file)
        else:
            config = self._createconfig(self.file)
        self.config = config[&#34;config&#34;]
        self.connections = config[&#34;connections&#34;]
        self.profiles = config[&#34;profiles&#34;]
        if not os.path.exists(self.key):
            self._createkey(self.key)
        with open(self.key) as f:
            self.privatekey = RSA.import_key(f.read())
            f.close()
        self.publickey = self.privatekey.publickey()


    def _loadconfig(self, conf):
        #Loads config file
        jsonconf = open(conf)
        jsondata = json.load(jsonconf)
        jsonconf.close()
        return jsondata

    def _createconfig(self, conf):
        #Create config file
        defaultconfig = {&#39;config&#39;: {&#39;case&#39;: False, &#39;idletime&#39;: 30, &#39;fzf&#39;: False}, &#39;connections&#39;: {}, &#39;profiles&#39;: { &#34;default&#34;: { &#34;host&#34;:&#34;&#34;, &#34;protocol&#34;:&#34;ssh&#34;, &#34;port&#34;:&#34;&#34;, &#34;user&#34;:&#34;&#34;, &#34;password&#34;:&#34;&#34;, &#34;options&#34;:&#34;&#34;, &#34;logs&#34;:&#34;&#34;, &#34;tags&#34;: &#34;&#34;, &#34;jumphost&#34;:&#34;&#34;}}}
        if not os.path.exists(conf):
            with open(conf, &#34;w&#34;) as f:
                json.dump(defaultconfig, f, indent = 4)
                f.close()
                os.chmod(conf, 0o600)
        jsonconf = open(conf)
        jsondata = json.load(jsonconf)
        jsonconf.close()
        return jsondata

    @MethodHook
    def _saveconfig(self, conf):
        #Save config file
        newconfig = {&#34;config&#34;:{}, &#34;connections&#34;: {}, &#34;profiles&#34;: {}}
        newconfig[&#34;config&#34;] = self.config
        newconfig[&#34;connections&#34;] = self.connections
        newconfig[&#34;profiles&#34;] = self.profiles
        try:
            with open(conf, &#34;w&#34;) as f:
                json.dump(newconfig, f, indent = 4)
                f.close()
        except:
            return 1
        return 0

    def _createkey(self, keyfile):
        #Create key file
        key = RSA.generate(2048)
        with open(keyfile,&#39;wb&#39;) as f:
            f.write(key.export_key(&#39;PEM&#39;))
            f.close()
            os.chmod(keyfile, 0o600)
        return key

    @MethodHook
    def _explode_unique(self, unique):
        #Divide unique name into folder, subfolder and id
        uniques = unique.split(&#34;@&#34;)
        if not unique.startswith(&#34;@&#34;):
            result = {&#34;id&#34;: uniques[0]}
        else:
            result = {}
        if len(uniques) == 2:
            result[&#34;folder&#34;] = uniques[1]
            if result[&#34;folder&#34;] == &#34;&#34;:
                return False
        elif len(uniques) == 3:
            result[&#34;folder&#34;] = uniques[2]
            result[&#34;subfolder&#34;] = uniques[1]
            if result[&#34;folder&#34;] == &#34;&#34; or result[&#34;subfolder&#34;] == &#34;&#34;:
                return False
        elif len(uniques) &gt; 3:
            return False
        return result

    @MethodHook
    def getitem(self, unique, keys = None):
        &#39;&#39;&#39;
        Get an node or a group of nodes from configfile which can be passed to node/nodes class

        ### Parameters:  

            - unique (str): Unique name of the node or folder in config using
                            connection manager style: node[@subfolder][@folder]
                            or [@subfolder]@folder

        ### Optional Parameters:  

            - keys (list): In case you pass a folder as unique, you can filter
                           nodes inside the folder passing a list.

        ### Returns:  

            dict: Dictionary containing information of node or multiple 
                  dictionaries of multiple nodes.

        &#39;&#39;&#39;
        uniques = self._explode_unique(unique)
        if unique.startswith(&#34;@&#34;):
            if uniques.keys() &gt;= {&#34;folder&#34;, &#34;subfolder&#34;}:
                folder = self.connections[uniques[&#34;folder&#34;]][uniques[&#34;subfolder&#34;]]
            else:
                folder = self.connections[uniques[&#34;folder&#34;]]
            newfolder = deepcopy(folder)
            newfolder.pop(&#34;type&#34;)
            for node in folder.keys():
                if node == &#34;type&#34;:
                    continue
                if &#34;type&#34; in newfolder[node].keys():
                    if newfolder[node][&#34;type&#34;] == &#34;subfolder&#34;:
                        newfolder.pop(node)
                    else:
                        newfolder[node].pop(&#34;type&#34;)
            if keys == None:
                newfolder = {&#34;{}{}&#34;.format(k,unique):v for k,v in newfolder.items()}
                return newfolder
            else:
                f_newfolder = dict((k, newfolder[k]) for k in keys)
                f_newfolder = {&#34;{}{}&#34;.format(k,unique):v for k,v in f_newfolder.items()}
                return f_newfolder
        else:
            if uniques.keys() &gt;= {&#34;folder&#34;, &#34;subfolder&#34;}:
                node = self.connections[uniques[&#34;folder&#34;]][uniques[&#34;subfolder&#34;]][uniques[&#34;id&#34;]]
            elif &#34;folder&#34; in uniques.keys():
                node = self.connections[uniques[&#34;folder&#34;]][uniques[&#34;id&#34;]]
            else:
                node = self.connections[uniques[&#34;id&#34;]]
            newnode = deepcopy(node)
            newnode.pop(&#34;type&#34;)
            return newnode

    @MethodHook
    def getitems(self, uniques):
        &#39;&#39;&#39;
        Get a group of nodes from configfile which can be passed to node/nodes class

        ### Parameters:  

            - uniques (str/list): String name that will match hostnames 
                                  from the connection manager. It can be a 
                                  list of strings.

        ### Returns:  

            dict: Dictionary containing information of node or multiple 
                  dictionaries of multiple nodes.

        &#39;&#39;&#39;
        nodes = {}
        if isinstance(uniques, str):
            uniques = [uniques]
        for i in uniques:
            if isinstance(i, dict):
                name = list(i.keys())[0]
                mylist = i[name]
                if not self.config[&#34;case&#34;]:
                    name = name.lower()
                    mylist = [item.lower() for item in mylist]
                this = self.getitem(name, mylist)
                nodes.update(this)
            elif i.startswith(&#34;@&#34;):
                if not self.config[&#34;case&#34;]:
                    i = i.lower()
                this = self.getitem(i)
                nodes.update(this)
            else:
                if not self.config[&#34;case&#34;]:
                    i = i.lower()
                this = self.getitem(i)
                nodes[i] = this
        return nodes


    @MethodHook
    def _connections_add(self,*, id, host, folder=&#39;&#39;, subfolder=&#39;&#39;, options=&#39;&#39;, logs=&#39;&#39;, password=&#39;&#39;, port=&#39;&#39;, protocol=&#39;&#39;, user=&#39;&#39;, tags=&#39;&#39;, jumphost=&#39;&#39;, type = &#34;connection&#34; ):
        #Add connection from config
        if folder == &#39;&#39;:
            self.connections[id] = {&#34;host&#34;: host, &#34;options&#34;: options, &#34;logs&#34;: logs, &#34;password&#34;: password, &#34;port&#34;: port, &#34;protocol&#34;: protocol, &#34;user&#34;: user, &#34;tags&#34;: tags,&#34;jumphost&#34;: jumphost,&#34;type&#34;: type}
        elif folder != &#39;&#39; and subfolder == &#39;&#39;:
            self.connections[folder][id] = {&#34;host&#34;: host, &#34;options&#34;: options, &#34;logs&#34;: logs, &#34;password&#34;: password, &#34;port&#34;: port, &#34;protocol&#34;: protocol, &#34;user&#34;: user, &#34;tags&#34;: tags, &#34;jumphost&#34;: jumphost, &#34;type&#34;: type}
        elif folder != &#39;&#39; and subfolder != &#39;&#39;:
            self.connections[folder][subfolder][id] = {&#34;host&#34;: host, &#34;options&#34;: options, &#34;logs&#34;: logs, &#34;password&#34;: password, &#34;port&#34;: port, &#34;protocol&#34;: protocol, &#34;user&#34;: user, &#34;tags&#34;: tags,  &#34;jumphost&#34;: jumphost, &#34;type&#34;: type}
            

    @MethodHook
    def _connections_del(self,*, id, folder=&#39;&#39;, subfolder=&#39;&#39;):
        #Delete connection from config
        if folder == &#39;&#39;:
            del self.connections[id]
        elif folder != &#39;&#39; and subfolder == &#39;&#39;:
            del self.connections[folder][id]
        elif folder != &#39;&#39; and subfolder != &#39;&#39;:
            del self.connections[folder][subfolder][id]

    @MethodHook
    def _folder_add(self,*, folder, subfolder = &#39;&#39;):
        #Add Folder from config
        if subfolder == &#39;&#39;:
            if folder not in self.connections:
                self.connections[folder] = {&#34;type&#34;: &#34;folder&#34;}
        else:
            if subfolder not in self.connections[folder]:
                self.connections[folder][subfolder] = {&#34;type&#34;: &#34;subfolder&#34;}

    @MethodHook
    def _folder_del(self,*, folder, subfolder=&#39;&#39;):
        #Delete folder from config
        if subfolder == &#39;&#39;:
            del self.connections[folder]
        else:
            del self.connections[folder][subfolder]


    @MethodHook
    def _profiles_add(self,*, id, host = &#39;&#39;, options=&#39;&#39;, logs=&#39;&#39;, password=&#39;&#39;, port=&#39;&#39;, protocol=&#39;&#39;, user=&#39;&#39;, tags=&#39;&#39;, jumphost=&#39;&#39; ):
        #Add profile from config
        self.profiles[id] = {&#34;host&#34;: host, &#34;options&#34;: options, &#34;logs&#34;: logs, &#34;password&#34;: password, &#34;port&#34;: port, &#34;protocol&#34;: protocol, &#34;user&#34;: user, &#34;tags&#34;: tags, &#34;jumphost&#34;: jumphost}
            

    @MethodHook
    def _profiles_del(self,*, id ):
        #Delete profile from config
        del self.profiles[id]
        
    @MethodHook
    def _getallnodes(self, filter = None):
        #get all nodes on configfile
        nodes = []
        layer1 = [k for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34;]
        folders = [k for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;folder&#34;]
        nodes.extend(layer1)
        for f in folders:
            layer2 = [k + &#34;@&#34; + f for k,v in self.connections[f].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34;]
            nodes.extend(layer2)
            subfolders = [k for k,v in self.connections[f].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;subfolder&#34;]
            for s in subfolders:
                layer3 = [k + &#34;@&#34; + s + &#34;@&#34; + f for k,v in self.connections[f][s].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34;]
                nodes.extend(layer3)
        if filter:
            if isinstance(filter, str):
                nodes = [item for item in nodes if re.search(filter, item)]
            elif isinstance(filter, list):
                nodes = [item for item in nodes if any(re.search(pattern, item) for pattern in filter)]
            else:
                raise ValueError(&#34;filter must be a string or a list of strings&#34;)
        return nodes

    @MethodHook
    def _getallnodesfull(self, filter = None, extract = True):
        #get all nodes on configfile with all their attributes.
        nodes = {}
        layer1 = {k:v for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34;}
        folders = [k for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;folder&#34;]
        nodes.update(layer1)
        for f in folders:
            layer2 = {k + &#34;@&#34; + f:v for k,v in self.connections[f].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34;}
            nodes.update(layer2)
            subfolders = [k for k,v in self.connections[f].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;subfolder&#34;]
            for s in subfolders:
                layer3 = {k + &#34;@&#34; + s + &#34;@&#34; + f:v for k,v in self.connections[f][s].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34;}
                nodes.update(layer3)
        if filter:
            if isinstance(filter, str):
                filter = &#34;^(?!.*@).+$&#34; if filter == &#34;@&#34; else filter
                nodes = {k: v for k, v in nodes.items() if re.search(filter, k)}
            elif isinstance(filter, list):
                filter = [&#34;^(?!.*@).+$&#34; if item == &#34;@&#34; else item for item in filter]
                nodes = {k: v for k, v in nodes.items() if any(re.search(pattern, k) for pattern in filter)}
            else:
                raise ValueError(&#34;filter must be a string or a list of strings&#34;)
        if extract:
            for node, keys in nodes.items():
                for key, value in keys.items():
                    profile = re.search(&#34;^@(.*)&#34;, str(value))
                    if profile:
                        try:
                            nodes[node][key] = self.profiles[profile.group(1)][key]
                        except:
                            nodes[node][key] = &#34;&#34;
                    elif value == &#39;&#39; and key == &#34;protocol&#34;:
                        try:
                            nodes[node][key] = config.profiles[&#34;default&#34;][key]
                        except:
                            nodes[node][key] = &#34;ssh&#34;
        return nodes


    @MethodHook
    def _getallfolders(self):
        #get all folders on configfile
        folders = [&#34;@&#34; + k for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;folder&#34;]
        subfolders = []
        for f in folders:
            s = [&#34;@&#34; + k + f for k,v in self.connections[f[1:]].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;subfolder&#34;]
            subfolders.extend(s)
        folders.extend(subfolders)
        return folders

    @MethodHook
    def _profileused(self, profile):
        #Check if profile is used before deleting it
        nodes = []
        layer1 = [k for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34; and (&#34;@&#34; + profile in v.values() or ( isinstance(v[&#34;password&#34;],list) and &#34;@&#34; + profile in v[&#34;password&#34;]))]
        folders = [k for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;folder&#34;]
        nodes.extend(layer1)
        for f in folders:
            layer2 = [k + &#34;@&#34; + f for k,v in self.connections[f].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34; and (&#34;@&#34; + profile in v.values() or ( isinstance(v[&#34;password&#34;],list) and &#34;@&#34; + profile in v[&#34;password&#34;]))]
            nodes.extend(layer2)
            subfolders = [k for k,v in self.connections[f].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;subfolder&#34;]
            for s in subfolders:
                layer3 = [k + &#34;@&#34; + s + &#34;@&#34; + f for k,v in self.connections[f][s].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34; and (&#34;@&#34; + profile in v.values() or ( isinstance(v[&#34;password&#34;],list) and &#34;@&#34; + profile in v[&#34;password&#34;]))]
                nodes.extend(layer3)
        return nodes

    @MethodHook
    def encrypt(self, password, keyfile=None):
        &#39;&#39;&#39;
        Encrypts password using RSA keyfile

        ### Parameters:  

            - password (str): Plaintext password to encrypt.

        ### Optional Parameters:  

            - keyfile  (str): Path/file to keyfile. Default is config keyfile.
                              

        ### Returns:  

            str: Encrypted password.

        &#39;&#39;&#39;
        if keyfile is None:
            keyfile = self.key
        with open(keyfile) as f:
            key = RSA.import_key(f.read())
            f.close()
        publickey = key.publickey()
        encryptor = PKCS1_OAEP.new(publickey)
        password = encryptor.encrypt(password.encode(&#34;utf-8&#34;))
        return str(password)</code></pre>
</details>
<div class="desc"><p>This class generates a configfile object. Containts a dictionary storing, config, nodes and profiles, normaly used by connection manager.</p>
<h3 id="attributes">Attributes:</h3>
<pre><code>- file         (str): Path/file to config file.

- key          (str): Path/file to RSA key file.

- config      (dict): Dictionary containing information of connection
                      manager configuration.

- connections (dict): Dictionary containing all the nodes added to
                      connection manager.

- profiles    (dict): Dictionary containing all the profiles added to
                      connection manager.

- privatekey   (obj): Object containing the private key to encrypt 
                      passwords.

- publickey    (obj): Object containing the public key to decrypt 
                      passwords.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- conf (str): Path/file to config file. If left empty default
              path is ~/.config/conn/config.json

- key  (str): Path/file to RSA key file. If left empty default
              path is ~/.config/conn/.osk
</code></pre></div>
<h3>Methods</h3>
<dl>
<dt id="connpy.configfile.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>self, password, keyfile=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@MethodHook
def encrypt(self, password, keyfile=None):
    &#39;&#39;&#39;
    Encrypts password using RSA keyfile

    ### Parameters:  

        - password (str): Plaintext password to encrypt.

    ### Optional Parameters:  

        - keyfile  (str): Path/file to keyfile. Default is config keyfile.
                          

    ### Returns:  

        str: Encrypted password.

    &#39;&#39;&#39;
    if keyfile is None:
        keyfile = self.key
    with open(keyfile) as f:
        key = RSA.import_key(f.read())
        f.close()
    publickey = key.publickey()
    encryptor = PKCS1_OAEP.new(publickey)
    password = encryptor.encrypt(password.encode(&#34;utf-8&#34;))
    return str(password)</code></pre>
</details>
<div class="desc"><p>Encrypts password using RSA keyfile</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- password (str): Plaintext password to encrypt.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- keyfile  (str): Path/file to keyfile. Default is config keyfile.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>str: Encrypted password.
</code></pre></div>
</dd>
<dt id="connpy.configfile.getitem"><code class="name flex">
<span>def <span class="ident">getitem</span></span>(<span>self, unique, keys=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@MethodHook
def getitem(self, unique, keys = None):
    &#39;&#39;&#39;
    Get an node or a group of nodes from configfile which can be passed to node/nodes class

    ### Parameters:  

        - unique (str): Unique name of the node or folder in config using
                        connection manager style: node[@subfolder][@folder]
                        or [@subfolder]@folder

    ### Optional Parameters:  

        - keys (list): In case you pass a folder as unique, you can filter
                       nodes inside the folder passing a list.

    ### Returns:  

        dict: Dictionary containing information of node or multiple 
              dictionaries of multiple nodes.

    &#39;&#39;&#39;
    uniques = self._explode_unique(unique)
    if unique.startswith(&#34;@&#34;):
        if uniques.keys() &gt;= {&#34;folder&#34;, &#34;subfolder&#34;}:
            folder = self.connections[uniques[&#34;folder&#34;]][uniques[&#34;subfolder&#34;]]
        else:
            folder = self.connections[uniques[&#34;folder&#34;]]
        newfolder = deepcopy(folder)
        newfolder.pop(&#34;type&#34;)
        for node in folder.keys():
            if node == &#34;type&#34;:
                continue
            if &#34;type&#34; in newfolder[node].keys():
                if newfolder[node][&#34;type&#34;] == &#34;subfolder&#34;:
                    newfolder.pop(node)
                else:
                    newfolder[node].pop(&#34;type&#34;)
        if keys == None:
            newfolder = {&#34;{}{}&#34;.format(k,unique):v for k,v in newfolder.items()}
            return newfolder
        else:
            f_newfolder = dict((k, newfolder[k]) for k in keys)
            f_newfolder = {&#34;{}{}&#34;.format(k,unique):v for k,v in f_newfolder.items()}
            return f_newfolder
    else:
        if uniques.keys() &gt;= {&#34;folder&#34;, &#34;subfolder&#34;}:
            node = self.connections[uniques[&#34;folder&#34;]][uniques[&#34;subfolder&#34;]][uniques[&#34;id&#34;]]
        elif &#34;folder&#34; in uniques.keys():
            node = self.connections[uniques[&#34;folder&#34;]][uniques[&#34;id&#34;]]
        else:
            node = self.connections[uniques[&#34;id&#34;]]
        newnode = deepcopy(node)
        newnode.pop(&#34;type&#34;)
        return newnode</code></pre>
</details>
<div class="desc"><p>Get an node or a group of nodes from configfile which can be passed to node/nodes class</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- unique (str): Unique name of the node or folder in config using
                connection manager style: node[@subfolder][@folder]
                or [@subfolder]@folder
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- keys (list): In case you pass a folder as unique, you can filter
               nodes inside the folder passing a list.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>dict: Dictionary containing information of node or multiple 
      dictionaries of multiple nodes.
</code></pre></div>
</dd>
<dt id="connpy.configfile.getitems"><code class="name flex">
<span>def <span class="ident">getitems</span></span>(<span>self, uniques)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@MethodHook
def getitems(self, uniques):
    &#39;&#39;&#39;
    Get a group of nodes from configfile which can be passed to node/nodes class

    ### Parameters:  

        - uniques (str/list): String name that will match hostnames 
                              from the connection manager. It can be a 
                              list of strings.

    ### Returns:  

        dict: Dictionary containing information of node or multiple 
              dictionaries of multiple nodes.

    &#39;&#39;&#39;
    nodes = {}
    if isinstance(uniques, str):
        uniques = [uniques]
    for i in uniques:
        if isinstance(i, dict):
            name = list(i.keys())[0]
            mylist = i[name]
            if not self.config[&#34;case&#34;]:
                name = name.lower()
                mylist = [item.lower() for item in mylist]
            this = self.getitem(name, mylist)
            nodes.update(this)
        elif i.startswith(&#34;@&#34;):
            if not self.config[&#34;case&#34;]:
                i = i.lower()
            this = self.getitem(i)
            nodes.update(this)
        else:
            if not self.config[&#34;case&#34;]:
                i = i.lower()
            this = self.getitem(i)
            nodes[i] = this
    return nodes</code></pre>
</details>
<div class="desc"><p>Get a group of nodes from configfile which can be passed to node/nodes class</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- uniques (str/list): String name that will match hostnames 
                      from the connection manager. It can be a 
                      list of strings.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>dict: Dictionary containing information of node or multiple 
      dictionaries of multiple nodes.
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="connpy.node"><code class="flex name class">
<span>class <span class="ident">node</span></span>
<span>(</span><span>unique,<br>host,<br>options='',<br>logs='',<br>password='',<br>port='',<br>protocol='',<br>user='',<br>config='',<br>tags='',<br>jumphost='')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@ClassHook
class node:
    &#39;&#39;&#39; This class generates a node object. Containts all the information and methods to connect and interact with a device using ssh or telnet.

    ### Attributes:  

        - output (str): Output of the commands you ran with run or test 
                        method.  

        - result(bool): True if expected value is found after running 
                        the commands using test method.

        - status (int): 0 if the method run or test run succesfully.
                        1 if connection failed.
                        2 if expect timeouts without prompt or EOF.

        &#39;&#39;&#39;
    
    def __init__(self, unique, host, options=&#39;&#39;, logs=&#39;&#39;, password=&#39;&#39;, port=&#39;&#39;, protocol=&#39;&#39;, user=&#39;&#39;, config=&#39;&#39;, tags=&#39;&#39;, jumphost=&#39;&#39;):
        &#39;&#39;&#39; 
            
        ### Parameters:  

            - unique (str): Unique name to assign to the node.

            - host   (str): IP address or hostname of the node.

        ### Optional Parameters:  

            - options  (str): Additional options to pass the ssh/telnet for
                              connection.  

            - logs     (str): Path/file for storing the logs. You can use 
                              ${unique},${host}, ${port}, ${user}, ${protocol} 
                              as variables.  

            - password (str): Encrypted or plaintext password.  

            - port     (str): Port to connect to node, default 22 for ssh and 23 
                              for telnet.  

            - protocol (str): Select ssh, telnet, kubectl or docker. Default is ssh.  

            - user     (str): Username to of the node.  

            - config   (obj): Pass the object created with class configfile with 
                              key for decryption and extra configuration if you 
                              are using connection manager.  

            - tags   (dict) : Tags useful for automation and personal porpuse
                              like &#34;os&#34;, &#34;prompt&#34; and &#34;screenleght_command&#34;
                              
            - jumphost (str): Reference another node to be used as a jumphost
        &#39;&#39;&#39;
        if config == &#39;&#39;:
            self.idletime = 0
            self.key = None
        else:
            self.idletime = config.config[&#34;idletime&#34;]
            self.key = config.key
        self.unique = unique
        attr = {&#34;host&#34;: host, &#34;logs&#34;: logs, &#34;options&#34;:options, &#34;port&#34;: port, &#34;protocol&#34;: protocol, &#34;user&#34;: user, &#34;tags&#34;: tags, &#34;jumphost&#34;: jumphost}
        for key in attr:
            profile = re.search(&#34;^@(.*)&#34;, str(attr[key]))
            if profile and config != &#39;&#39;:
                try:
                    setattr(self,key,config.profiles[profile.group(1)][key])
                except:
                    setattr(self,key,&#34;&#34;)
            elif attr[key] == &#39;&#39; and key == &#34;protocol&#34;:
                try:
                    setattr(self,key,config.profiles[&#34;default&#34;][key])
                except:
                    setattr(self,key,&#34;ssh&#34;)
            else: 
                setattr(self,key,attr[key])
        if isinstance(password,list):
            self.password = []
            for i, s in enumerate(password):
                profile = re.search(&#34;^@(.*)&#34;, password[i])
                if profile and config != &#39;&#39;:
                    self.password.append(config.profiles[profile.group(1)][&#34;password&#34;])
        else:
            self.password = [password]
        if self.jumphost != &#34;&#34; and config != &#39;&#39;:
            self.jumphost = config.getitem(self.jumphost)
            for key in self.jumphost:
                profile = re.search(&#34;^@(.*)&#34;, str(self.jumphost[key]))
                if profile:
                    try:
                        self.jumphost[key] = config.profiles[profile.group(1)][key]
                    except:
                        self.jumphost[key] = &#34;&#34;
                elif self.jumphost[key] == &#39;&#39; and key == &#34;protocol&#34;:
                    try:
                        self.jumphost[key] = config.profiles[&#34;default&#34;][key]
                    except:
                        self.jumphost[key] = &#34;ssh&#34;
            if isinstance(self.jumphost[&#34;password&#34;],list):
                jumphost_password = []
                for i, s in enumerate(self.jumphost[&#34;password&#34;]):
                    profile = re.search(&#34;^@(.*)&#34;, self.jumphost[&#34;password&#34;][i])
                    if profile:
                        jumphost_password.append(config.profiles[profile.group(1)][&#34;password&#34;])
                self.jumphost[&#34;password&#34;] = jumphost_password
            else:
                self.jumphost[&#34;password&#34;] = [self.jumphost[&#34;password&#34;]]
            if self.jumphost[&#34;password&#34;] != [&#34;&#34;]:
                self.password = self.jumphost[&#34;password&#34;] + self.password

            if self.jumphost[&#34;protocol&#34;] == &#34;ssh&#34;:
                jumphost_cmd = self.jumphost[&#34;protocol&#34;] + &#34; -W %h:%p&#34;
                if self.jumphost[&#34;port&#34;] != &#39;&#39;:
                    jumphost_cmd = jumphost_cmd + &#34; -p &#34; + self.jumphost[&#34;port&#34;]
                if self.jumphost[&#34;options&#34;] != &#39;&#39;:
                    jumphost_cmd = jumphost_cmd + &#34; &#34; + self.jumphost[&#34;options&#34;]
                if self.jumphost[&#34;user&#34;] == &#39;&#39;:
                    jumphost_cmd = jumphost_cmd + &#34; {}&#34;.format(self.jumphost[&#34;host&#34;])
                else:
                    jumphost_cmd = jumphost_cmd + &#34; {}&#34;.format(&#34;@&#34;.join([self.jumphost[&#34;user&#34;],self.jumphost[&#34;host&#34;]]))
                self.jumphost = f&#34;-o ProxyCommand=\&#34;{jumphost_cmd}\&#34;&#34;
            else:
                self.jumphost = &#34;&#34;

    @MethodHook
    def _passtx(self, passwords, *, keyfile=None):
        # decrypts passwords, used by other methdos.
        dpass = []
        if keyfile is None:
            keyfile = self.key
        if keyfile is not None:
            with open(keyfile) as f:
                key = RSA.import_key(f.read())
            decryptor = PKCS1_OAEP.new(key)
        for passwd in passwords:
            if not re.match(&#39;^b[\&#34;\&#39;].+[\&#34;\&#39;]$&#39;, passwd):
                dpass.append(passwd)
            else:
                try:
                    decrypted = decryptor.decrypt(ast.literal_eval(passwd)).decode(&#34;utf-8&#34;)
                    dpass.append(decrypted)
                except:
                    raise ValueError(&#34;Missing or corrupted key&#34;)
        return dpass

    

    @MethodHook
    def _logfile(self, logfile = None):
        # translate logs variables and generate logs path.
        if logfile == None:
            logfile = self.logs
        logfile = logfile.replace(&#34;${unique}&#34;, self.unique)
        logfile = logfile.replace(&#34;${host}&#34;, self.host)
        logfile = logfile.replace(&#34;${port}&#34;, self.port)
        logfile = logfile.replace(&#34;${user}&#34;, self.user)
        logfile = logfile.replace(&#34;${protocol}&#34;, self.protocol)
        now = datetime.datetime.now()
        dateconf = re.search(r&#39;\$\{date \&#39;(.*)\&#39;}&#39;, logfile)
        if dateconf:
            logfile = re.sub(r&#39;\$\{date (.*)}&#39;,now.strftime(dateconf.group(1)), logfile)
        return logfile

    @MethodHook
    def _logclean(self, logfile, var = False):
        #Remove special ascii characters and other stuff from logfile.
        if var == False:
            t = open(logfile, &#34;r&#34;).read()
        else:
            t = logfile
        while t.find(&#34;\b&#34;) != -1:
            t = re.sub(&#39;[^\b]\b&#39;, &#39;&#39;, t)
        t = t.replace(&#34;\n&#34;,&#34;&#34;,1)
        t = t.replace(&#34;\a&#34;,&#34;&#34;)
        t = t.replace(&#39;\n\n&#39;, &#39;\n&#39;)
        t = re.sub(r&#39;.\[K&#39;, &#39;&#39;, t)
        ansi_escape = re.compile(r&#39;\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/ ]*[@-~])&#39;)
        t = ansi_escape.sub(&#39;&#39;, t)
        t = t.lstrip(&#34; \n\r&#34;)
        t = t.replace(&#34;\r&#34;,&#34;&#34;)
        t = t.replace(&#34;\x0E&#34;,&#34;&#34;)
        t = t.replace(&#34;\x0F&#34;,&#34;&#34;)
        if var == False:
            d = open(logfile, &#34;w&#34;)
            d.write(t)
            d.close()
            return
        else:
            return t

    @MethodHook
    def _savelog(self):
        &#39;&#39;&#39;Save the log buffer to the file at regular intervals if there are changes.&#39;&#39;&#39;
        t = threading.current_thread()
        prev_size = 0  # Store the previous size of the buffer

        while getattr(t, &#34;do_run&#34;, True):  # Check if thread is signaled to stop
            current_size = self.mylog.tell()  # Current size of the buffer

            # Only save if the buffer size has changed
            if current_size != prev_size:
                with open(self.logfile, &#34;w&#34;) as f:  # Use &#34;w&#34; to overwrite the file
                    f.write(self._logclean(self.mylog.getvalue().decode(), True))
                prev_size = current_size  # Update the previous size
            sleep(5)

    @MethodHook
    def _filter(self, a):
        #Set time for last input when using interact
        self.lastinput = time()
        return a

    @MethodHook
    def _keepalive(self):
        #Send keepalive ctrl+e when idletime passed without new inputs on interact
        self.lastinput = time()
        t = threading.current_thread()
        while True:
            if time() - self.lastinput &gt;= self.idletime:
                self.child.sendcontrol(&#34;e&#34;)
                self.lastinput = time()
            sleep(1)


    @MethodHook
    def interact(self, debug = False):
        &#39;&#39;&#39;
        Allow user to interact with the node directly, mostly used by connection manager.

        ### Optional Parameters:  

            - debug (bool): If True, display all the connecting information 
                            before interact. Default False.  
        &#39;&#39;&#39;
        connect = self._connect(debug = debug)
        if connect == True:
            size = re.search(&#39;columns=([0-9]+).*lines=([0-9]+)&#39;,str(os.get_terminal_size()))
            self.child.setwinsize(int(size.group(2)),int(size.group(1)))
            print(&#34;Connected to &#34; + self.unique + &#34; at &#34; + self.host + (&#34;:&#34; if self.port != &#39;&#39; else &#39;&#39;) + self.port + &#34; via: &#34; + self.protocol)
            if &#39;logfile&#39; in dir(self):
                # Initialize self.mylog
                if not &#39;mylog&#39; in dir(self):
                    self.mylog = io.BytesIO()
                self.child.logfile_read = self.mylog
                
                # Start the _savelog thread
                log_thread = threading.Thread(target=self._savelog)
                log_thread.daemon = True
                log_thread.start()
            if &#39;missingtext&#39; in dir(self):
                print(self.child.after.decode(), end=&#39;&#39;)
            if self.idletime &gt; 0:
                x = threading.Thread(target=self._keepalive)
                x.daemon = True
                x.start()
            if debug:
                print(self.mylog.getvalue().decode())
            self.child.interact(input_filter=self._filter)
            if &#39;logfile&#39; in dir(self):
                with open(self.logfile, &#34;w&#34;) as f:
                    f.write(self._logclean(self.mylog.getvalue().decode(), True))

        else:
            print(connect)
            exit(1)

    @MethodHook
    def run(self, commands, vars = None,*, folder = &#39;&#39;, prompt = r&#39;&gt;$|#$|\$$|&gt;.$|#.$|\$.$&#39;, stdout = False, timeout = 10):
        &#39;&#39;&#39;
        Run a command or list of commands on the node and return the output.

        ### Parameters:  

            - commands (str/list): Commands to run on the node. Should be 
                                   str or a list of str. You can use variables
                                   as {varname} and defining them in optional
                                   parameter vars.

        ### Optional Parameters:  

            - vars  (dict): Dictionary containing the definition of variables
                            used in commands parameter.
                            Keys: Variable names.
                            Values: strings.

        ### Optional Named Parameters:  

            - folder (str): Path where output log should be stored, leave 
                            empty to disable logging.  

            - prompt (str): Prompt to be expected after a command is finished 
                            running. Usually linux uses  &#34;&gt;&#34; or EOF while 
                            routers use &#34;&gt;&#34; or &#34;#&#34;. The default value should 
                            work for most nodes. Change it if your connection 
                            need some special symbol.  

            - stdout (bool):Set True to send the command output to stdout. 
                            default False.

            - timeout (int):Time in seconds for expect to wait for prompt/EOF.
                            default 10.

        ### Returns:  

            str: Output of the commands you ran on the node.

        &#39;&#39;&#39;
        connect = self._connect(timeout = timeout)
        now = datetime.datetime.now().strftime(&#39;%Y-%m-%d_%H%M%S&#39;)
        if connect == True:
            # Attempt to set the terminal size
            try:
                self.child.setwinsize(65535, 65535)
            except Exception:
                try:
                    self.child.setwinsize(10000, 10000)
                except Exception:
                    pass
            if &#34;prompt&#34; in self.tags:
                prompt = self.tags[&#34;prompt&#34;]
            expects = [prompt, pexpect.EOF, pexpect.TIMEOUT]
            output = &#39;&#39;
            status = &#39;&#39;
            if not isinstance(commands, list):
                commands = [commands]
            if &#34;screen_length_command&#34; in self.tags:
                commands.insert(0, self.tags[&#34;screen_length_command&#34;])
            self.mylog = io.BytesIO()
            self.child.logfile_read = self.mylog
            for c in commands:
                if vars is not None:
                    c = c.format(**vars)
                result = self.child.expect(expects, timeout = timeout)
                self.child.sendline(c)
                if result == 2:
                    break
            if not result == 2:
                result = self.child.expect(expects, timeout = timeout)
            self.child.close()
            output = self._logclean(self.mylog.getvalue().decode(), True)
            if stdout == True:
                print(output)
            if folder != &#39;&#39;:
                with open(folder + &#34;/&#34; + self.unique + &#34;_&#34; + now + &#34;.txt&#34;, &#34;w&#34;) as f:
                    f.write(output)
                    f.close()
            self.output = output
            if result == 2:
                self.status = 2
            else:
                self.status = 0
            return output
        else:
            self.output = connect
            self.status = 1
            if stdout == True:
                print(connect)
            if folder != &#39;&#39;:
                with open(folder + &#34;/&#34; + self.unique + &#34;_&#34; + now + &#34;.txt&#34;, &#34;w&#34;) as f:
                    f.write(connect)
                    f.close()
            return connect

    @MethodHook
    def test(self, commands, expected, vars = None,*, prompt = r&#39;&gt;$|#$|\$$|&gt;.$|#.$|\$.$&#39;, timeout = 10):
        &#39;&#39;&#39;
        Run a command or list of commands on the node, then check if expected value appears on the output after the last command.

        ### Parameters:  

            - commands (str/list): Commands to run on the node. Should be
                                   str or a list of str. You can use variables
                                   as {varname} and defining them in optional
                                   parameter vars.

            - expected (str)     : Expected text to appear after running 
                                   all the commands on the node.You can use
                                   variables as {varname} and defining them
                                   in optional parameter vars.

        ### Optional Parameters:  

            - vars  (dict): Dictionary containing the definition of variables
                            used in commands and expected parameters.
                            Keys: Variable names.
                            Values: strings.

        ### Optional Named Parameters: 

            - prompt (str): Prompt to be expected after a command is finished
                            running. Usually linux uses  &#34;&gt;&#34; or EOF while 
                            routers use &#34;&gt;&#34; or &#34;#&#34;. The default value should 
                            work for most nodes. Change it if your connection 
                            need some special symbol.

            - timeout (int):Time in seconds for expect to wait for prompt/EOF.
                            default 10.

        ### Returns: 
            bool: true if expected value is found after running the commands 
                  false if prompt is found before.

        &#39;&#39;&#39;
        connect = self._connect(timeout = timeout)
        if connect == True:
            # Attempt to set the terminal size
            try:
                self.child.setwinsize(65535, 65535)
            except Exception:
                try:
                    self.child.setwinsize(10000, 10000)
                except Exception:
                    pass
            if &#34;prompt&#34; in self.tags:
                prompt = self.tags[&#34;prompt&#34;]
            expects = [prompt, pexpect.EOF, pexpect.TIMEOUT]
            output = &#39;&#39;
            if not isinstance(commands, list):
                commands = [commands]
            if not isinstance(expected, list):
                expected = [expected]
            if &#34;screen_length_command&#34; in self.tags:
                commands.insert(0, self.tags[&#34;screen_length_command&#34;])
            self.mylog = io.BytesIO()
            self.child.logfile_read = self.mylog
            for c in commands:
                if vars is not None:
                    c = c.format(**vars)
                result = self.child.expect(expects, timeout = timeout)
                self.child.sendline(c)
                if result == 2:
                    break
            if not result == 2:
                result = self.child.expect(expects, timeout = timeout)
            self.child.close()
            output = self._logclean(self.mylog.getvalue().decode(), True)
            self.output = output
            if result in [0, 1]:
                # lastcommand = commands[-1]
                # if vars is not None:
                    # lastcommand = lastcommand.format(**vars)
                # last_command_index = output.rfind(lastcommand)
                # cleaned_output = output[last_command_index + len(lastcommand):].strip()
                self.result = {}
                for e in expected:
                    if vars is not None:
                        e = e.format(**vars)
                    updatedprompt = re.sub(r&#39;(?&lt;!\\)\$&#39;, &#39;&#39;, prompt)
                    newpattern = f&#34;.*({updatedprompt}).*{e}.*&#34;
                    cleaned_output = output
                    cleaned_output = re.sub(newpattern, &#39;&#39;, cleaned_output)
                    if e in cleaned_output:
                        self.result[e] = True
                    else:
                        self.result[e]= False
                self.status = 0
                return self.result
            if result == 2:
                self.result = None
                self.status = 2
                return output
        else:
            self.result = None
            self.output = connect
            self.status = 1
            return connect

    @MethodHook
    def _generate_ssh_sftp_cmd(self):
        cmd = self.protocol
        if self.idletime &gt; 0:
            cmd += &#34; -o ServerAliveInterval=&#34; + str(self.idletime)
        if self.port:
            if self.protocol == &#34;ssh&#34;:
                cmd += &#34; -p &#34; + self.port
            elif self.protocol == &#34;sftp&#34;:
                cmd += &#34; -P &#34; + self.port
        if self.options:
            cmd += &#34; &#34; + self.options
        if self.jumphost:
            cmd += &#34; &#34; + self.jumphost
        user_host = f&#34;{self.user}@{self.host}&#34; if self.user else self.host
        cmd += f&#34; {user_host}&#34;
        return cmd

    @MethodHook
    def _generate_telnet_cmd(self):
        cmd = f&#34;telnet {self.host}&#34;
        if self.port:
            cmd += f&#34; {self.port}&#34;
        if self.options:
            cmd += f&#34; {self.options}&#34;
        return cmd

    @MethodHook
    def _generate_kube_cmd(self):
        cmd = f&#34;kubectl exec {self.options} {self.host} -it --&#34;
        kube_command = self.tags.get(&#34;kube_command&#34;, &#34;/bin/bash&#34;) if isinstance(self.tags, dict) else &#34;/bin/bash&#34;
        cmd += f&#34; {kube_command}&#34;
        return cmd

    @MethodHook
    def _generate_docker_cmd(self):
        cmd = f&#34;docker {self.options} exec -it {self.host}&#34;
        docker_command = self.tags.get(&#34;docker_command&#34;, &#34;/bin/bash&#34;) if isinstance(self.tags, dict) else &#34;/bin/bash&#34;
        cmd += f&#34; {docker_command}&#34;
        return cmd

    @MethodHook
    def _get_cmd(self):
        if self.protocol in [&#34;ssh&#34;, &#34;sftp&#34;]:
            return self._generate_ssh_sftp_cmd()
        elif self.protocol == &#34;telnet&#34;:
            return self._generate_telnet_cmd()
        elif self.protocol == &#34;kubectl&#34;:
            return self._generate_kube_cmd()
        elif self.protocol == &#34;docker&#34;:
            return self._generate_docker_cmd()
        else:
            raise ValueError(f&#34;Invalid protocol: {self.protocol}&#34;)

    @MethodHook
    def _connect(self, debug=False, timeout=10, max_attempts=3):
        cmd = self._get_cmd()
        passwords = self._passtx(self.password) if self.password[0] else []
        if self.logs != &#39;&#39;:
            self.logfile = self._logfile()
        default_prompt = r&#39;&gt;$|#$|\$$|&gt;.$|#.$|\$.$&#39;
        prompt = self.tags.get(&#34;prompt&#34;, default_prompt) if isinstance(self.tags, dict) else default_prompt
        password_prompt = &#39;[p|P]assword:|[u|U]sername:&#39; if self.protocol != &#39;telnet&#39; else &#39;[p|P]assword:&#39;

        expects = {
            &#34;ssh&#34;: [&#39;yes/no&#39;, &#39;refused&#39;, &#39;supported&#39;, &#39;Invalid|[u|U]sage: ssh&#39;, &#39;ssh-keygen.*\&#34;&#39;, &#39;timeout|timed.out&#39;, &#39;unavailable&#39;, &#39;closed&#39;, password_prompt, prompt, &#39;suspend&#39;, pexpect.EOF, pexpect.TIMEOUT, &#34;No route to host&#34;, &#34;resolve hostname&#34;, &#34;no matching&#34;, &#34;[b|B]ad (owner|permissions)&#34;],
            &#34;sftp&#34;: [&#39;yes/no&#39;, &#39;refused&#39;, &#39;supported&#39;, &#39;Invalid|[u|U]sage: sftp&#39;, &#39;ssh-keygen.*\&#34;&#39;, &#39;timeout|timed.out&#39;, &#39;unavailable&#39;, &#39;closed&#39;, password_prompt, prompt, &#39;suspend&#39;, pexpect.EOF, pexpect.TIMEOUT, &#34;No route to host&#34;, &#34;resolve hostname&#34;, &#34;no matching&#34;, &#34;[b|B]ad (owner|permissions)&#34;],
            &#34;telnet&#34;: [&#39;[u|U]sername:&#39;, &#39;refused&#39;, &#39;supported&#39;, &#39;invalid|unrecognized option&#39;, &#39;ssh-keygen.*\&#34;&#39;, &#39;timeout|timed.out&#39;, &#39;unavailable&#39;, &#39;closed&#39;, password_prompt, prompt, &#39;suspend&#39;, pexpect.EOF, pexpect.TIMEOUT, &#34;No route to host&#34;, &#34;resolve hostname&#34;, &#34;no matching&#34;, &#34;[b|B]ad (owner|permissions)&#34;],
            &#34;kubectl&#34;: [&#39;[u|U]sername:&#39;, &#39;[r|R]efused&#39;, &#39;[E|e]rror&#39;, &#39;DEPRECATED&#39;, pexpect.TIMEOUT, password_prompt, prompt, pexpect.EOF, &#34;expired|invalid&#34;],
            &#34;docker&#34;: [&#39;[u|U]sername:&#39;, &#39;Cannot&#39;, &#39;[E|e]rror&#39;, &#39;failed&#39;, &#39;not a docker command&#39;, &#39;unknown&#39;, &#39;unable to resolve&#39;, pexpect.TIMEOUT, password_prompt, prompt, pexpect.EOF]
        }

        error_indices = {
            &#34;ssh&#34;: [1, 2, 3, 4, 5, 6, 7, 12, 13, 14, 15, 16],
            &#34;sftp&#34;: [1, 2, 3, 4, 5, 6, 7, 12, 13, 14, 15, 16],
            &#34;telnet&#34;: [1, 2, 3, 4, 5, 6, 7, 12, 13, 14, 15, 16],
            &#34;kubectl&#34;: [1, 2, 3, 4, 8],  # Define error indices for kube
            &#34;docker&#34;: [1, 2, 3, 4, 5, 6, 7]  # Define error indices for docker
        }

        eof_indices = {
            &#34;ssh&#34;: [8, 9, 10, 11],
            &#34;sftp&#34;: [8, 9, 10, 11],
            &#34;telnet&#34;: [8, 9, 10, 11],
            &#34;kubectl&#34;: [5, 6, 7],  # Define eof indices for kube
            &#34;docker&#34;: [8, 9, 10]  # Define eof indices for docker
        }

        initial_indices = {
            &#34;ssh&#34;: [0],
            &#34;sftp&#34;: [0],
            &#34;telnet&#34;: [0],
            &#34;kubectl&#34;: [0],  # Define special indices for kube
            &#34;docker&#34;: [0]  # Define special indices for docker
        }

        attempts = 1
        while attempts &lt;= max_attempts:
            child = pexpect.spawn(cmd)
            if debug:
                print(cmd)
                self.mylog = io.BytesIO()
                child.logfile_read = self.mylog

            endloop = False
            for i in range(len(passwords) if passwords else 1):
                while True:
                    results = child.expect(expects[self.protocol], timeout=timeout)
                    results_value = expects[self.protocol][results]
                    
                    if results in initial_indices[self.protocol]:
                        if self.protocol in [&#34;ssh&#34;, &#34;sftp&#34;]:
                            child.sendline(&#39;yes&#39;)
                        elif self.protocol in [&#34;telnet&#34;, &#34;kubectl&#34;, &#34;docker&#34;]:
                            if self.user:
                                child.sendline(self.user)
                            else:
                                self.missingtext = True
                                break
                    
                    elif results in error_indices[self.protocol]:
                        child.terminate()
                        if results_value == pexpect.TIMEOUT and attempts != max_attempts:
                            attempts += 1
                            endloop = True
                            break
                        else:
                            after = &#34;Connection timeout&#34; if results_value == pexpect.TIMEOUT else child.after.decode()
                            return f&#34;Connection failed code: {results}\n{child.before.decode().lstrip()}{after}{child.readline().decode()}&#34;.rstrip()
                    
                    elif results in eof_indices[self.protocol]:
                        if results_value == password_prompt:
                            if passwords:
                                child.sendline(passwords[i])
                            else:
                                self.missingtext = True
                            break
                        elif results_value == &#34;suspend&#34;:
                            child.sendline(&#34;\r&#34;)
                            sleep(2)
                        else:
                            endloop = True
                            child.sendline()
                            break
                    
                if endloop:
                    break
            if results_value == pexpect.TIMEOUT:
                continue
            else:
                break

        child.readline(0)
        self.child = child
        return True</code></pre>
</details>
<div class="desc"><p>This class generates a node object. Containts all the information and methods to connect and interact with a device using ssh or telnet.</p>
<h3 id="attributes">Attributes:</h3>
<pre><code>- output (str): Output of the commands you ran with run or test 
                method.

- result(bool): True if expected value is found after running 
                the commands using test method.

- status (int): 0 if the method run or test run succesfully.
                1 if connection failed.
                2 if expect timeouts without prompt or EOF.
</code></pre>
<h3 id="parameters">Parameters:</h3>
<pre><code>- unique (str): Unique name to assign to the node.

- host   (str): IP address or hostname of the node.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- options  (str): Additional options to pass the ssh/telnet for
                  connection.

- logs     (str): Path/file for storing the logs. You can use 
                  ${unique},${host}, ${port}, ${user}, ${protocol} 
                  as variables.

- password (str): Encrypted or plaintext password.

- port     (str): Port to connect to node, default 22 for ssh and 23 
                  for telnet.

- protocol (str): Select ssh, telnet, kubectl or docker. Default is ssh.

- user     (str): Username to of the node.

- config   (obj): Pass the object created with class configfile with 
                  key for decryption and extra configuration if you 
                  are using connection manager.

- tags   (dict) : Tags useful for automation and personal porpuse
                  like "os", "prompt" and "screenleght_command"

- jumphost (str): Reference another node to be used as a jumphost
</code></pre></div>
<h3>Methods</h3>
<dl>
<dt id="connpy.node.interact"><code class="name flex">
<span>def <span class="ident">interact</span></span>(<span>self, debug=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@MethodHook
def interact(self, debug = False):
    &#39;&#39;&#39;
    Allow user to interact with the node directly, mostly used by connection manager.

    ### Optional Parameters:  

        - debug (bool): If True, display all the connecting information 
                        before interact. Default False.  
    &#39;&#39;&#39;
    connect = self._connect(debug = debug)
    if connect == True:
        size = re.search(&#39;columns=([0-9]+).*lines=([0-9]+)&#39;,str(os.get_terminal_size()))
        self.child.setwinsize(int(size.group(2)),int(size.group(1)))
        print(&#34;Connected to &#34; + self.unique + &#34; at &#34; + self.host + (&#34;:&#34; if self.port != &#39;&#39; else &#39;&#39;) + self.port + &#34; via: &#34; + self.protocol)
        if &#39;logfile&#39; in dir(self):
            # Initialize self.mylog
            if not &#39;mylog&#39; in dir(self):
                self.mylog = io.BytesIO()
            self.child.logfile_read = self.mylog
            
            # Start the _savelog thread
            log_thread = threading.Thread(target=self._savelog)
            log_thread.daemon = True
            log_thread.start()
        if &#39;missingtext&#39; in dir(self):
            print(self.child.after.decode(), end=&#39;&#39;)
        if self.idletime &gt; 0:
            x = threading.Thread(target=self._keepalive)
            x.daemon = True
            x.start()
        if debug:
            print(self.mylog.getvalue().decode())
        self.child.interact(input_filter=self._filter)
        if &#39;logfile&#39; in dir(self):
            with open(self.logfile, &#34;w&#34;) as f:
                f.write(self._logclean(self.mylog.getvalue().decode(), True))

    else:
        print(connect)
        exit(1)</code></pre>
</details>
<div class="desc"><p>Allow user to interact with the node directly, mostly used by connection manager.</p>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- debug (bool): If True, display all the connecting information 
                before interact. Default False.
</code></pre></div>
</dd>
<dt id="connpy.node.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self,<br>commands,<br>vars=None,<br>*,<br>folder='',<br>prompt=&#x27;&gt;$|#$|\\$$|&gt;.$|#.$|\\$.$&#x27;,<br>stdout=False,<br>timeout=10)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@MethodHook
def run(self, commands, vars = None,*, folder = &#39;&#39;, prompt = r&#39;&gt;$|#$|\$$|&gt;.$|#.$|\$.$&#39;, stdout = False, timeout = 10):
    &#39;&#39;&#39;
    Run a command or list of commands on the node and return the output.

    ### Parameters:  

        - commands (str/list): Commands to run on the node. Should be 
                               str or a list of str. You can use variables
                               as {varname} and defining them in optional
                               parameter vars.

    ### Optional Parameters:  

        - vars  (dict): Dictionary containing the definition of variables
                        used in commands parameter.
                        Keys: Variable names.
                        Values: strings.

    ### Optional Named Parameters:  

        - folder (str): Path where output log should be stored, leave 
                        empty to disable logging.  

        - prompt (str): Prompt to be expected after a command is finished 
                        running. Usually linux uses  &#34;&gt;&#34; or EOF while 
                        routers use &#34;&gt;&#34; or &#34;#&#34;. The default value should 
                        work for most nodes. Change it if your connection 
                        need some special symbol.  

        - stdout (bool):Set True to send the command output to stdout. 
                        default False.

        - timeout (int):Time in seconds for expect to wait for prompt/EOF.
                        default 10.

    ### Returns:  

        str: Output of the commands you ran on the node.

    &#39;&#39;&#39;
    connect = self._connect(timeout = timeout)
    now = datetime.datetime.now().strftime(&#39;%Y-%m-%d_%H%M%S&#39;)
    if connect == True:
        # Attempt to set the terminal size
        try:
            self.child.setwinsize(65535, 65535)
        except Exception:
            try:
                self.child.setwinsize(10000, 10000)
            except Exception:
                pass
        if &#34;prompt&#34; in self.tags:
            prompt = self.tags[&#34;prompt&#34;]
        expects = [prompt, pexpect.EOF, pexpect.TIMEOUT]
        output = &#39;&#39;
        status = &#39;&#39;
        if not isinstance(commands, list):
            commands = [commands]
        if &#34;screen_length_command&#34; in self.tags:
            commands.insert(0, self.tags[&#34;screen_length_command&#34;])
        self.mylog = io.BytesIO()
        self.child.logfile_read = self.mylog
        for c in commands:
            if vars is not None:
                c = c.format(**vars)
            result = self.child.expect(expects, timeout = timeout)
            self.child.sendline(c)
            if result == 2:
                break
        if not result == 2:
            result = self.child.expect(expects, timeout = timeout)
        self.child.close()
        output = self._logclean(self.mylog.getvalue().decode(), True)
        if stdout == True:
            print(output)
        if folder != &#39;&#39;:
            with open(folder + &#34;/&#34; + self.unique + &#34;_&#34; + now + &#34;.txt&#34;, &#34;w&#34;) as f:
                f.write(output)
                f.close()
        self.output = output
        if result == 2:
            self.status = 2
        else:
            self.status = 0
        return output
    else:
        self.output = connect
        self.status = 1
        if stdout == True:
            print(connect)
        if folder != &#39;&#39;:
            with open(folder + &#34;/&#34; + self.unique + &#34;_&#34; + now + &#34;.txt&#34;, &#34;w&#34;) as f:
                f.write(connect)
                f.close()
        return connect</code></pre>
</details>
<div class="desc"><p>Run a command or list of commands on the node and return the output.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- commands (str/list): Commands to run on the node. Should be 
                       str or a list of str. You can use variables
                       as {varname} and defining them in optional
                       parameter vars.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- vars  (dict): Dictionary containing the definition of variables
                used in commands parameter.
                Keys: Variable names.
                Values: strings.
</code></pre>
<h3 id="optional-named-parameters">Optional Named Parameters:</h3>
<pre><code>- folder (str): Path where output log should be stored, leave 
                empty to disable logging.

- prompt (str): Prompt to be expected after a command is finished 
                running. Usually linux uses  "&gt;" or EOF while 
                routers use "&gt;" or "#". The default value should 
                work for most nodes. Change it if your connection 
                need some special symbol.

- stdout (bool):Set True to send the command output to stdout. 
                default False.

- timeout (int):Time in seconds for expect to wait for prompt/EOF.
                default 10.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>str: Output of the commands you ran on the node.
</code></pre></div>
</dd>
<dt id="connpy.node.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>self,<br>commands,<br>expected,<br>vars=None,<br>*,<br>prompt=&#x27;&gt;$|#$|\\$$|&gt;.$|#.$|\\$.$&#x27;,<br>timeout=10)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@MethodHook
def test(self, commands, expected, vars = None,*, prompt = r&#39;&gt;$|#$|\$$|&gt;.$|#.$|\$.$&#39;, timeout = 10):
    &#39;&#39;&#39;
    Run a command or list of commands on the node, then check if expected value appears on the output after the last command.

    ### Parameters:  

        - commands (str/list): Commands to run on the node. Should be
                               str or a list of str. You can use variables
                               as {varname} and defining them in optional
                               parameter vars.

        - expected (str)     : Expected text to appear after running 
                               all the commands on the node.You can use
                               variables as {varname} and defining them
                               in optional parameter vars.

    ### Optional Parameters:  

        - vars  (dict): Dictionary containing the definition of variables
                        used in commands and expected parameters.
                        Keys: Variable names.
                        Values: strings.

    ### Optional Named Parameters: 

        - prompt (str): Prompt to be expected after a command is finished
                        running. Usually linux uses  &#34;&gt;&#34; or EOF while 
                        routers use &#34;&gt;&#34; or &#34;#&#34;. The default value should 
                        work for most nodes. Change it if your connection 
                        need some special symbol.

        - timeout (int):Time in seconds for expect to wait for prompt/EOF.
                        default 10.

    ### Returns: 
        bool: true if expected value is found after running the commands 
              false if prompt is found before.

    &#39;&#39;&#39;
    connect = self._connect(timeout = timeout)
    if connect == True:
        # Attempt to set the terminal size
        try:
            self.child.setwinsize(65535, 65535)
        except Exception:
            try:
                self.child.setwinsize(10000, 10000)
            except Exception:
                pass
        if &#34;prompt&#34; in self.tags:
            prompt = self.tags[&#34;prompt&#34;]
        expects = [prompt, pexpect.EOF, pexpect.TIMEOUT]
        output = &#39;&#39;
        if not isinstance(commands, list):
            commands = [commands]
        if not isinstance(expected, list):
            expected = [expected]
        if &#34;screen_length_command&#34; in self.tags:
            commands.insert(0, self.tags[&#34;screen_length_command&#34;])
        self.mylog = io.BytesIO()
        self.child.logfile_read = self.mylog
        for c in commands:
            if vars is not None:
                c = c.format(**vars)
            result = self.child.expect(expects, timeout = timeout)
            self.child.sendline(c)
            if result == 2:
                break
        if not result == 2:
            result = self.child.expect(expects, timeout = timeout)
        self.child.close()
        output = self._logclean(self.mylog.getvalue().decode(), True)
        self.output = output
        if result in [0, 1]:
            # lastcommand = commands[-1]
            # if vars is not None:
                # lastcommand = lastcommand.format(**vars)
            # last_command_index = output.rfind(lastcommand)
            # cleaned_output = output[last_command_index + len(lastcommand):].strip()
            self.result = {}
            for e in expected:
                if vars is not None:
                    e = e.format(**vars)
                updatedprompt = re.sub(r&#39;(?&lt;!\\)\$&#39;, &#39;&#39;, prompt)
                newpattern = f&#34;.*({updatedprompt}).*{e}.*&#34;
                cleaned_output = output
                cleaned_output = re.sub(newpattern, &#39;&#39;, cleaned_output)
                if e in cleaned_output:
                    self.result[e] = True
                else:
                    self.result[e]= False
            self.status = 0
            return self.result
        if result == 2:
            self.result = None
            self.status = 2
            return output
    else:
        self.result = None
        self.output = connect
        self.status = 1
        return connect</code></pre>
</details>
<div class="desc"><p>Run a command or list of commands on the node, then check if expected value appears on the output after the last command.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- commands (str/list): Commands to run on the node. Should be
                       str or a list of str. You can use variables
                       as {varname} and defining them in optional
                       parameter vars.

- expected (str)     : Expected text to appear after running 
                       all the commands on the node.You can use
                       variables as {varname} and defining them
                       in optional parameter vars.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- vars  (dict): Dictionary containing the definition of variables
                used in commands and expected parameters.
                Keys: Variable names.
                Values: strings.
</code></pre>
<h3 id="optional-named-parameters">Optional Named Parameters:</h3>
<pre><code>- prompt (str): Prompt to be expected after a command is finished
                running. Usually linux uses  "&gt;" or EOF while 
                routers use "&gt;" or "#". The default value should 
                work for most nodes. Change it if your connection 
                need some special symbol.

- timeout (int):Time in seconds for expect to wait for prompt/EOF.
                default 10.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>bool: true if expected value is found after running the commands 
      false if prompt is found before.
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="connpy.nodes"><code class="flex name class">
<span>class <span class="ident">nodes</span></span>
<span>(</span><span>nodes:Â dict, config='')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@ClassHook
class nodes:
    &#39;&#39;&#39; This class generates a nodes object. Contains a list of node class objects and methods to run multiple tasks on nodes simultaneously.

    ### Attributes:  

        - nodelist (list): List of node class objects passed to the init 
                           function.  

        - output   (dict): Dictionary formed by nodes unique as keys, 
                           output of the commands you ran on the node as 
                           value. Created after running methods run or test.  

        - result   (dict): Dictionary formed by nodes unique as keys, value 
                           is True if expected value is found after running 
                           the commands, False if prompt is found before. 
                           Created after running method test.  

        - status   (dict): Dictionary formed by nodes unique as keys, value: 
                           0 if method run or test ended succesfully.
                           1 if connection failed.
                           2 if expect timeouts without prompt or EOF.

        - &lt;unique&gt; (obj):  For each item in nodelist, there is an attribute
                           generated with the node unique.
        &#39;&#39;&#39;

    def __init__(self, nodes: dict, config = &#39;&#39;):
        &#39;&#39;&#39; 
        ### Parameters:  

            - nodes (dict): Dictionary formed by node information:  
                            Keys: Unique name for each node.  
                            Mandatory Subkeys: host(str).  
                            Optional Subkeys: options(str), logs(str), password(str),
                            port(str), protocol(str), user(str).  
                            For reference on subkeys check node class.

        ### Optional Parameters:  

            - config (obj): Pass the object created with class configfile with key 
                            for decryption and extra configuration if you are using 
                            connection manager.
        &#39;&#39;&#39;
        self.nodelist = []
        self.config = config
        for n in nodes:
            this = node(n, **nodes[n], config = config)
            self.nodelist.append(this)
            setattr(self,n,this)

    
    @MethodHook
    def _splitlist(self, lst, n):
        #split a list in lists of n members.
        for i in range(0, len(lst), n):
            yield lst[i:i + n]


    @MethodHook
    def run(self, commands, vars = None,*, folder = None, prompt = None, stdout = None, parallel = 10, timeout = None):
        &#39;&#39;&#39;
        Run a command or list of commands on all the nodes in nodelist.

        ### Parameters:  

            - commands (str/list): Commands to run on the nodes. Should be str or 
                                   list of str. You can use variables as {varname}
                                   and defining them in optional parameter vars.

        ### Optional Parameters:  

            - vars  (dict): Dictionary containing the definition of variables for
                            each node, used in commands parameter.
                            Keys should be formed by nodes unique names. Use
                            special key name __global__ for global variables.
                            Subkeys: Variable names.
                            Values: strings.

        ### Optional Named Parameters:  

            - folder   (str): Path where output log should be stored, leave empty 
                              to disable logging.  

            - prompt   (str): Prompt to be expected after a command is finished 
                              running. Usually linux uses  &#34;&gt;&#34; or EOF while routers 
                              use &#34;&gt;&#34; or &#34;#&#34;. The default value should work for 
                              most nodes. Change it if your connection need some 
                              special symbol.  

            - stdout  (bool): Set True to send the command output to stdout. 
                              Default False.  

            - parallel (int): Number of nodes to run the commands simultaneously. 
                              Default is 10, if there are more nodes that this 
                              value, nodes are groups in groups with max this 
                              number of members.
            
            - timeout  (int): Time in seconds for expect to wait for prompt/EOF.
                              default 10.

        ###Returns:  

            dict: Dictionary formed by nodes unique as keys, Output of the 
                  commands you ran on the node as value.

        &#39;&#39;&#39;
        args = {}
        nodesargs = {}
        args[&#34;commands&#34;] = commands
        if folder != None:
            args[&#34;folder&#34;] = folder
            Path(folder).mkdir(parents=True, exist_ok=True)
        if prompt != None:
            args[&#34;prompt&#34;] = prompt
        if stdout != None:
            args[&#34;stdout&#34;] = stdout
        if timeout != None:
            args[&#34;timeout&#34;] = timeout
        output = {}
        status = {}
        tasks = []
        for n in self.nodelist:
            nodesargs[n.unique] = deepcopy(args)
            if vars != None:
                nodesargs[n.unique][&#34;vars&#34;] = {}
                if &#34;__global__&#34; in vars.keys():
                    nodesargs[n.unique][&#34;vars&#34;].update(vars[&#34;__global__&#34;])
                if n.unique in vars.keys():
                    nodesargs[n.unique][&#34;vars&#34;].update(vars[n.unique])
            tasks.append(threading.Thread(target=n.run, kwargs=nodesargs[n.unique]))
        taskslist = list(self._splitlist(tasks, parallel))
        for t in taskslist:
            for i in t:
                i.start()
            for i in t:
                i.join()
        for i in self.nodelist:
            output[i.unique] = i.output
            status[i.unique] = i.status
        self.output = output
        self.status = status
        return output

    @MethodHook
    def test(self, commands, expected, vars = None,*, prompt = None, parallel = 10, timeout = None):
        &#39;&#39;&#39;
        Run a command or list of commands on all the nodes in nodelist, then check if expected value appears on the output after the last command.

        ### Parameters:  

            - commands (str/list): Commands to run on the node. Should be str or 
                                   list of str.  

            - expected (str)     : Expected text to appear after running all the 
                                   commands on the node.

        ### Optional Parameters:  

            - vars  (dict): Dictionary containing the definition of variables for
                            each node, used in commands and expected parameters.
                            Keys should be formed by nodes unique names. Use
                            special key name __global__ for global variables.
                            Subkeys: Variable names.
                            Values: strings.

        ### Optional Named Parameters:  

            - prompt   (str): Prompt to be expected after a command is finished 
                              running. Usually linux uses  &#34;&gt;&#34; or EOF while 
                              routers use &#34;&gt;&#34; or &#34;#&#34;. The default value should 
                              work for most nodes. Change it if your connection 
                              need some special symbol.


            - parallel (int): Number of nodes to run the commands simultaneously. 
                              Default is 10, if there are more nodes that this 
                              value, nodes are groups in groups with max this 
                              number of members.

            - timeout  (int): Time in seconds for expect to wait for prompt/EOF.
                              default 10.

        ### Returns:  

            dict: Dictionary formed by nodes unique as keys, value is True if 
                  expected value is found after running the commands, False 
                  if prompt is found before.

        &#39;&#39;&#39;
        args = {}
        nodesargs = {}
        args[&#34;commands&#34;] = commands
        args[&#34;expected&#34;] = expected
        if prompt != None:
            args[&#34;prompt&#34;] = prompt
        if timeout != None:
            args[&#34;timeout&#34;] = timeout
        output = {}
        result = {}
        status = {}
        tasks = []
        for n in self.nodelist:
            nodesargs[n.unique] = deepcopy(args)
            if vars != None:
                nodesargs[n.unique][&#34;vars&#34;] = {}
                if &#34;__global__&#34; in vars.keys():
                    nodesargs[n.unique][&#34;vars&#34;].update(vars[&#34;__global__&#34;])
                if n.unique in vars.keys():
                    nodesargs[n.unique][&#34;vars&#34;].update(vars[n.unique])
            tasks.append(threading.Thread(target=n.test, kwargs=nodesargs[n.unique]))
        taskslist = list(self._splitlist(tasks, parallel))
        for t in taskslist:
            for i in t:
                i.start()
            for i in t:
                i.join()
        for i in self.nodelist:
            result[i.unique] = i.result
            output[i.unique] = i.output
            status[i.unique] = i.status
        self.output = output
        self.result = result
        self.status = status
        return result</code></pre>
</details>
<div class="desc"><p>This class generates a nodes object. Contains a list of node class objects and methods to run multiple tasks on nodes simultaneously.</p>
<h3 id="attributes">Attributes:</h3>
<pre><code>- nodelist (list): List of node class objects passed to the init 
                   function.

- output   (dict): Dictionary formed by nodes unique as keys, 
                   output of the commands you ran on the node as 
                   value. Created after running methods run or test.

- result   (dict): Dictionary formed by nodes unique as keys, value 
                   is True if expected value is found after running 
                   the commands, False if prompt is found before. 
                   Created after running method test.

- status   (dict): Dictionary formed by nodes unique as keys, value: 
                   0 if method run or test ended succesfully.
                   1 if connection failed.
                   2 if expect timeouts without prompt or EOF.

- &lt;unique&gt; (obj):  For each item in nodelist, there is an attribute
                   generated with the node unique.
</code></pre>
<h3 id="parameters">Parameters:</h3>
<pre><code>- nodes (dict): Dictionary formed by node information:  
                Keys: Unique name for each node.  
                Mandatory Subkeys: host(str).  
                Optional Subkeys: options(str), logs(str), password(str),
                port(str), protocol(str), user(str).  
                For reference on subkeys check node class.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- config (obj): Pass the object created with class configfile with key 
                for decryption and extra configuration if you are using 
                connection manager.
</code></pre></div>
<h3>Methods</h3>
<dl>
<dt id="connpy.nodes.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self,<br>commands,<br>vars=None,<br>*,<br>folder=None,<br>prompt=None,<br>stdout=None,<br>parallel=10,<br>timeout=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@MethodHook
def run(self, commands, vars = None,*, folder = None, prompt = None, stdout = None, parallel = 10, timeout = None):
    &#39;&#39;&#39;
    Run a command or list of commands on all the nodes in nodelist.

    ### Parameters:  

        - commands (str/list): Commands to run on the nodes. Should be str or 
                               list of str. You can use variables as {varname}
                               and defining them in optional parameter vars.

    ### Optional Parameters:  

        - vars  (dict): Dictionary containing the definition of variables for
                        each node, used in commands parameter.
                        Keys should be formed by nodes unique names. Use
                        special key name __global__ for global variables.
                        Subkeys: Variable names.
                        Values: strings.

    ### Optional Named Parameters:  

        - folder   (str): Path where output log should be stored, leave empty 
                          to disable logging.  

        - prompt   (str): Prompt to be expected after a command is finished 
                          running. Usually linux uses  &#34;&gt;&#34; or EOF while routers 
                          use &#34;&gt;&#34; or &#34;#&#34;. The default value should work for 
                          most nodes. Change it if your connection need some 
                          special symbol.  

        - stdout  (bool): Set True to send the command output to stdout. 
                          Default False.  

        - parallel (int): Number of nodes to run the commands simultaneously. 
                          Default is 10, if there are more nodes that this 
                          value, nodes are groups in groups with max this 
                          number of members.
        
        - timeout  (int): Time in seconds for expect to wait for prompt/EOF.
                          default 10.

    ###Returns:  

        dict: Dictionary formed by nodes unique as keys, Output of the 
              commands you ran on the node as value.

    &#39;&#39;&#39;
    args = {}
    nodesargs = {}
    args[&#34;commands&#34;] = commands
    if folder != None:
        args[&#34;folder&#34;] = folder
        Path(folder).mkdir(parents=True, exist_ok=True)
    if prompt != None:
        args[&#34;prompt&#34;] = prompt
    if stdout != None:
        args[&#34;stdout&#34;] = stdout
    if timeout != None:
        args[&#34;timeout&#34;] = timeout
    output = {}
    status = {}
    tasks = []
    for n in self.nodelist:
        nodesargs[n.unique] = deepcopy(args)
        if vars != None:
            nodesargs[n.unique][&#34;vars&#34;] = {}
            if &#34;__global__&#34; in vars.keys():
                nodesargs[n.unique][&#34;vars&#34;].update(vars[&#34;__global__&#34;])
            if n.unique in vars.keys():
                nodesargs[n.unique][&#34;vars&#34;].update(vars[n.unique])
        tasks.append(threading.Thread(target=n.run, kwargs=nodesargs[n.unique]))
    taskslist = list(self._splitlist(tasks, parallel))
    for t in taskslist:
        for i in t:
            i.start()
        for i in t:
            i.join()
    for i in self.nodelist:
        output[i.unique] = i.output
        status[i.unique] = i.status
    self.output = output
    self.status = status
    return output</code></pre>
</details>
<div class="desc"><p>Run a command or list of commands on all the nodes in nodelist.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- commands (str/list): Commands to run on the nodes. Should be str or 
                       list of str. You can use variables as {varname}
                       and defining them in optional parameter vars.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- vars  (dict): Dictionary containing the definition of variables for
                each node, used in commands parameter.
                Keys should be formed by nodes unique names. Use
                special key name __global__ for global variables.
                Subkeys: Variable names.
                Values: strings.
</code></pre>
<h3 id="optional-named-parameters">Optional Named Parameters:</h3>
<pre><code>- folder   (str): Path where output log should be stored, leave empty 
                  to disable logging.

- prompt   (str): Prompt to be expected after a command is finished 
                  running. Usually linux uses  "&gt;" or EOF while routers 
                  use "&gt;" or "#". The default value should work for 
                  most nodes. Change it if your connection need some 
                  special symbol.

- stdout  (bool): Set True to send the command output to stdout. 
                  Default False.

- parallel (int): Number of nodes to run the commands simultaneously. 
                  Default is 10, if there are more nodes that this 
                  value, nodes are groups in groups with max this 
                  number of members.

- timeout  (int): Time in seconds for expect to wait for prompt/EOF.
                  default 10.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>dict: Dictionary formed by nodes unique as keys, Output of the 
      commands you ran on the node as value.
</code></pre></div>
</dd>
<dt id="connpy.nodes.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>self, commands, expected, vars=None, *, prompt=None, parallel=10, timeout=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@MethodHook
def test(self, commands, expected, vars = None,*, prompt = None, parallel = 10, timeout = None):
    &#39;&#39;&#39;
    Run a command or list of commands on all the nodes in nodelist, then check if expected value appears on the output after the last command.

    ### Parameters:  

        - commands (str/list): Commands to run on the node. Should be str or 
                               list of str.  

        - expected (str)     : Expected text to appear after running all the 
                               commands on the node.

    ### Optional Parameters:  

        - vars  (dict): Dictionary containing the definition of variables for
                        each node, used in commands and expected parameters.
                        Keys should be formed by nodes unique names. Use
                        special key name __global__ for global variables.
                        Subkeys: Variable names.
                        Values: strings.

    ### Optional Named Parameters:  

        - prompt   (str): Prompt to be expected after a command is finished 
                          running. Usually linux uses  &#34;&gt;&#34; or EOF while 
                          routers use &#34;&gt;&#34; or &#34;#&#34;. The default value should 
                          work for most nodes. Change it if your connection 
                          need some special symbol.


        - parallel (int): Number of nodes to run the commands simultaneously. 
                          Default is 10, if there are more nodes that this 
                          value, nodes are groups in groups with max this 
                          number of members.

        - timeout  (int): Time in seconds for expect to wait for prompt/EOF.
                          default 10.

    ### Returns:  

        dict: Dictionary formed by nodes unique as keys, value is True if 
              expected value is found after running the commands, False 
              if prompt is found before.

    &#39;&#39;&#39;
    args = {}
    nodesargs = {}
    args[&#34;commands&#34;] = commands
    args[&#34;expected&#34;] = expected
    if prompt != None:
        args[&#34;prompt&#34;] = prompt
    if timeout != None:
        args[&#34;timeout&#34;] = timeout
    output = {}
    result = {}
    status = {}
    tasks = []
    for n in self.nodelist:
        nodesargs[n.unique] = deepcopy(args)
        if vars != None:
            nodesargs[n.unique][&#34;vars&#34;] = {}
            if &#34;__global__&#34; in vars.keys():
                nodesargs[n.unique][&#34;vars&#34;].update(vars[&#34;__global__&#34;])
            if n.unique in vars.keys():
                nodesargs[n.unique][&#34;vars&#34;].update(vars[n.unique])
        tasks.append(threading.Thread(target=n.test, kwargs=nodesargs[n.unique]))
    taskslist = list(self._splitlist(tasks, parallel))
    for t in taskslist:
        for i in t:
            i.start()
        for i in t:
            i.join()
    for i in self.nodelist:
        result[i.unique] = i.result
        output[i.unique] = i.output
        status[i.unique] = i.status
    self.output = output
    self.result = result
    self.status = status
    return result</code></pre>
</details>
<div class="desc"><p>Run a command or list of commands on all the nodes in nodelist, then check if expected value appears on the output after the last command.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- commands (str/list): Commands to run on the node. Should be str or 
                       list of str.

- expected (str)     : Expected text to appear after running all the 
                       commands on the node.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- vars  (dict): Dictionary containing the definition of variables for
                each node, used in commands and expected parameters.
                Keys should be formed by nodes unique names. Use
                special key name __global__ for global variables.
                Subkeys: Variable names.
                Values: strings.
</code></pre>
<h3 id="optional-named-parameters">Optional Named Parameters:</h3>
<pre><code>- prompt   (str): Prompt to be expected after a command is finished 
                  running. Usually linux uses  "&gt;" or EOF while 
                  routers use "&gt;" or "#". The default value should 
                  work for most nodes. Change it if your connection 
                  need some special symbol.


- parallel (int): Number of nodes to run the commands simultaneously. 
                  Default is 10, if there are more nodes that this 
                  value, nodes are groups in groups with max this 
                  number of members.

- timeout  (int): Time in seconds for expect to wait for prompt/EOF.
                  default 10.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>dict: Dictionary formed by nodes unique as keys, value is True if 
      expected value is found after running the commands, False 
      if prompt is found before.
</code></pre></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#connection-manager">Connection manager</a><ul>
<li><a href="#features">Features</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#manage-profiles">Manage profiles</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</li>
<li><a href="#plugin-requirements-for-connpy">Plugin Requirements for Connpy</a><ul>
<li><a href="#general-structure">General Structure</a></li>
<li><a href="#specific-class-requirements">Specific Class Requirements</a></li>
<li><a href="#class-dependencies-and-combinations">Class Dependencies and Combinations</a></li>
<li><a href="#preload-modifications-and-hooks">Preload Modifications and Hooks</a><ul>
<li><a href="#modifying-classes-with-modify">Modifying Classes with modify</a></li>
<li><a href="#implementing-method-hooks">Implementing Method Hooks</a></li>
</ul>
</li>
<li><a href="#executable-block">Executable Block</a></li>
<li><a href="#script-verification">Script Verification</a></li>
<li><a href="#example-script">Example Script</a></li>
</ul>
</li>
<li><a href="#http-api">http API</a><ul>
<li><a href="#1-list-nodes">1. List Nodes</a><ul>
<li><a href="#request-body">Request Body:</a></li>
<li><a href="#response">Response:</a></li>
</ul>
</li>
<li><a href="#2-get-nodes">2. Get Nodes</a><ul>
<li><a href="#request-body_1">Request Body:</a></li>
<li><a href="#response_1">Response:</a></li>
</ul>
</li>
<li><a href="#3-run-commands">3. Run Commands</a><ul>
<li><a href="#request-body_2">Request Body:</a></li>
<li><a href="#response_2">Response:</a></li>
</ul>
</li>
<li><a href="#4-ask-ai">4. Ask AI</a><ul>
<li><a href="#request-body_3">Request Body:</a></li>
<li><a href="#response_3">Response:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#automation-module">Automation module</a><ul>
<li><a href="#standalone-module">Standalone module</a></li>
<li><a href="#using-manager-configuration">Using manager configuration</a></li>
<li><a href="#running-parallel-tasks">Running parallel tasks</a></li>
<li><a href="#using-variables">Using variables</a></li>
<li><a href="#using-ai">Using AI</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="connpy.Plugins" href="#connpy.Plugins">Plugins</a></code></h4>
<ul class="">
<li><code><a title="connpy.Plugins.verify_script" href="#connpy.Plugins.verify_script">verify_script</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="connpy.ai" href="#connpy.ai">ai</a></code></h4>
<ul class="">
<li><code><a title="connpy.ai.ask" href="#connpy.ai.ask">ask</a></code></li>
<li><code><a title="connpy.ai.confirm" href="#connpy.ai.confirm">confirm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="connpy.configfile" href="#connpy.configfile">configfile</a></code></h4>
<ul class="">
<li><code><a title="connpy.configfile.encrypt" href="#connpy.configfile.encrypt">encrypt</a></code></li>
<li><code><a title="connpy.configfile.getitem" href="#connpy.configfile.getitem">getitem</a></code></li>
<li><code><a title="connpy.configfile.getitems" href="#connpy.configfile.getitems">getitems</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="connpy.node" href="#connpy.node">node</a></code></h4>
<ul class="">
<li><code><a title="connpy.node.interact" href="#connpy.node.interact">interact</a></code></li>
<li><code><a title="connpy.node.run" href="#connpy.node.run">run</a></code></li>
<li><code><a title="connpy.node.test" href="#connpy.node.test">test</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="connpy.nodes" href="#connpy.nodes">nodes</a></code></h4>
<ul class="">
<li><code><a title="connpy.nodes.run" href="#connpy.nodes.run">run</a></code></li>
<li><code><a title="connpy.nodes.test" href="#connpy.nodes.test">test</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
