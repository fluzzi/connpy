<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>connpy API documentation</title>
<meta name="description" content="Connection manager â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>connpy</code></h1>
</header>
<section id="section-intro">
<h2 id="connection-manager">Connection manager</h2>
<p>Connpy is a connection manager that allows you to store nodes to connect them fast and password free.</p>
<h3 id="features">Features</h3>
<pre><code>- You can generate profiles and reference them from nodes using @profilename 
  so you dont need to edit multiple nodes when changing password or other 
  information.
- Nodes can be stored on @folder or @subfolder@folder to organize your 
  devices. Then can be referenced using node@subfolder@folder or node@folder
- If you have too many nodes. Get completion script using: conn config 
  --completion, or use fzf installing pyfzf and running conn config --fzf true
- Much more!
</code></pre>
<h3 id="usage">Usage</h3>
<pre><code>usage: conn [-h] [--add | --del | --mod | --show | --debug] [node|folder] [--sftp]
       conn {profile,move,mv,copy,cp,list,ls,bulk,export,import,ai,run,api,plugin,config} ...

positional arguments:
  node|folder    node[@subfolder][@folder]
                 Connect to specific node or show all matching nodes
                 [@subfolder][@folder]
                 Show all available connections globaly or in specified path
Options:
  -h, --help         show this help message and exit
  -v, --version      Show version
  -a, --add          Add new node[@subfolder][@folder] or [@subfolder]@folder
  -r, --del, --rm    Delete node[@subfolder][@folder] or [@subfolder]@folder
  -e, --mod, --edit  Modify node[@subfolder][@folder]
  -s, --show         Show node[@subfolder][@folder]
  -d, --debug        Display all conections steps
  -t, --sftp         Connects using sftp instead of ssh

Commands:
  profile         Manage profiles
  move(mv)        Move node
  copy(cp)        Copy node
  list(ls)        List profiles, nodes or folders
  bulk            Add nodes in bulk
  export          Export connection folder to Yaml file
  import          Import connection folder to config from Yaml file
  ai              Make request to an AI
  run             Run scripts or commands on nodes
  api             Start and stop connpy api
  plugin          Manage plugins
  config          Manage app config
</code></pre>
<h3 id="manage-profiles">Manage profiles</h3>
<pre><code>usage: conn profile [-h] (--add | --del | --mod | --show) profile

positional arguments:
  profile        Name of profile to manage

options:
  -h, --help         show this help message and exit
  -a, --add          Add new profile
  -r, --del, --rm    Delete profile
  -e, --mod, --edit  Modify profile
  -s, --show         Show profile

</code></pre>
<h3 id="examples">Examples</h3>
<pre><code>   conn profile --add office-user
   conn --add @office
   conn --add @datacenter@office
   conn --add server@datacenter@office
   conn --add pc@office
   conn --show server@datacenter@office
   conn pc@office
   conn server
</code></pre>
<h2 id="plugin-requirements-for-connpy">Plugin Requirements for Connpy</h2>
<h3 id="general-structure">General Structure</h3>
<ul>
<li>The plugin script must be a Python file.</li>
<li>Only the following top-level elements are allowed in the plugin script:</li>
<li>Class definitions</li>
<li>Function definitions</li>
<li>Import statements</li>
<li>The <code>if __name__ == "__main__":</code> block for standalone execution</li>
<li>Pass statements</li>
</ul>
<h3 id="specific-class-requirements">Specific Class Requirements</h3>
<ul>
<li>The plugin script must define at least two specific classes:</li>
<li><strong>Class <code>Parser</code></strong>:<ul>
<li>Must contain only one method: <code>__init__</code>.</li>
<li>The <code>__init__</code> method must initialize at least two attributes:</li>
<li><code>self.parser</code>: An instance of <code>argparse.ArgumentParser</code>.</li>
<li><code>self.description</code>: A string containing the description of the parser.</li>
</ul>
</li>
<li><strong>Class <code>Entrypoint</code></strong>:<ul>
<li>Must have an <code>__init__</code> method that accepts exactly three parameters besides <code>self</code>:</li>
<li><code>args</code>: Arguments passed to the plugin.</li>
<li>The parser instance (typically <code>self.parser</code> from the <code>Parser</code> class).</li>
<li>The Connapp instance to interact with the Connpy app.</li>
</ul>
</li>
</ul>
<h3 id="executable-block">Executable Block</h3>
<ul>
<li>The plugin script can include an executable block:</li>
<li><code>if __name__ == "__main__":</code></li>
<li>This block allows the plugin to be run as a standalone script for testing or independent use.</li>
</ul>
<h3 id="script-verification">Script Verification</h3>
<ul>
<li>The <code>verify_script</code> method in <code>plugins.py</code> is used to check the plugin script's compliance with these standards.</li>
<li>Non-compliant scripts will be rejected to ensure consistency and proper functionality within the plugin system.</li>
<li></li>
</ul>
<h3 id="example-script">Example Script</h3>
<p>For a practical example of how to write a compatible plugin script, please refer to the following example:</p>
<p><a href="https://github.com/fluzzi/awspy">Example Plugin Script</a></p>
<p>This script demonstrates the required structure and implementation details according to the plugin system's standards.</p>
<h2 id="http-api">http API</h2>
<p>With the Connpy API you can run commands on devices using http requests</p>
<h3 id="1-list-nodes">1. List Nodes</h3>
<p><strong>Endpoint</strong>: <code>/list_nodes</code></p>
<p><strong>Method</strong>: <code>POST</code></p>
<p><strong>Description</strong>: This route returns a list of nodes. It can also filter the list based on a given keyword.</p>
<h4 id="request-body">Request Body:</h4>
<pre><code class="language-json">{
  &quot;filter&quot;: &quot;&lt;keyword&gt;&quot;
}
</code></pre>
<ul>
<li><code>filter</code> (optional): A keyword to filter the list of nodes. It returns only the nodes that contain the keyword. If not provided, the route will return the entire list of nodes.</li>
</ul>
<h4 id="response">Response:</h4>
<ul>
<li>A JSON array containing the filtered list of nodes.</li>
</ul>
<hr>
<h3 id="2-get-nodes">2. Get Nodes</h3>
<p><strong>Endpoint</strong>: <code>/get_nodes</code></p>
<p><strong>Method</strong>: <code>POST</code></p>
<p><strong>Description</strong>: This route returns a dictionary of nodes with all their attributes. It can also filter the nodes based on a given keyword.</p>
<h4 id="request-body_1">Request Body:</h4>
<pre><code class="language-json">{
  &quot;filter&quot;: &quot;&lt;keyword&gt;&quot;
}
</code></pre>
<ul>
<li><code>filter</code> (optional): A keyword to filter the nodes. It returns only the nodes that contain the keyword. If not provided, the route will return the entire list of nodes.</li>
</ul>
<h4 id="response_1">Response:</h4>
<ul>
<li>A JSON array containing the filtered nodes.</li>
</ul>
<hr>
<h3 id="3-run-commands">3. Run Commands</h3>
<p><strong>Endpoint</strong>: <code>/run_commands</code></p>
<p><strong>Method</strong>: <code>POST</code></p>
<p><strong>Description</strong>: This route runs commands on selected nodes based on the provided action, nodes, and commands. It also supports executing tests by providing expected results.</p>
<h4 id="request-body_2">Request Body:</h4>
<pre><code class="language-json">{
  &quot;action&quot;: &quot;&lt;action&gt;&quot;,
  &quot;nodes&quot;: &quot;&lt;nodes&gt;&quot;,
  &quot;commands&quot;: &quot;&lt;commands&gt;&quot;,
  &quot;expected&quot;: &quot;&lt;expected&gt;&quot;,
  &quot;options&quot;: &quot;&lt;options&gt;&quot;
}
</code></pre>
<ul>
<li><code>action</code> (required): The action to be performed. Possible values: <code>run</code> or <code>test</code>.</li>
<li><code><a title="connpy.nodes" href="#connpy.nodes">nodes</a></code> (required): A list of nodes or a single node on which the commands will be executed. The nodes can be specified as individual node names or a node group with the <code>@</code> prefix. Node groups can also be specified as arrays with a list of nodes inside the group.</li>
<li><code>commands</code> (required): A list of commands to be executed on the specified nodes.</li>
<li><code>expected</code> (optional, only used when the action is <code>test</code>): A single expected result for the test.</li>
<li><code>options</code> (optional): Array to pass options to the run command, options are: <code>prompt</code>, <code>parallel</code>, <code>timeout</code>
</li>
</ul>
<h4 id="response_2">Response:</h4>
<ul>
<li>A JSON object with the results of the executed commands on the nodes.</li>
</ul>
<hr>
<h3 id="4-ask-ai">4. Ask AI</h3>
<p><strong>Endpoint</strong>: <code>/ask_ai</code></p>
<p><strong>Method</strong>: <code>POST</code></p>
<p><strong>Description</strong>: This route sends to chatgpt IA a request that will parse it into an understandable output for the application and then run the request.</p>
<h4 id="request-body_3">Request Body:</h4>
<pre><code class="language-json">{
  &quot;input&quot;: &quot;&lt;user input request&gt;&quot;,
  &quot;dryrun&quot;: true or false
}
</code></pre>
<ul>
<li><code>input</code> (required): The user input requesting the AI to perform an action on some devices or get the devices list.</li>
<li><code>dryrun</code> (optional): If set to true, it will return the parameters to run the request but it won't run it. default is false.</li>
</ul>
<h4 id="response_3">Response:</h4>
<ul>
<li>A JSON array containing the action to run and the parameters and the result of the action.</li>
</ul>
<h2 id="automation-module">Automation module</h2>
<p>The automation module</p>
<h3 id="standalone-module">Standalone module</h3>
<pre><code>import connpy
router = connpy.node(&quot;uniqueName&quot;,&quot;ip/host&quot;, user=&quot;user&quot;, password=&quot;pass&quot;)
router.run([&quot;term len 0&quot;,&quot;show run&quot;])
print(router.output)
hasip = router.test(&quot;show ip int brief&quot;,&quot;1.1.1.1&quot;)
if hasip:
    print(&quot;Router has ip 1.1.1.1&quot;)
else:
    print(&quot;router does not have ip 1.1.1.1&quot;)
</code></pre>
<h3 id="using-manager-configuration">Using manager configuration</h3>
<pre><code>import connpy
conf = connpy.configfile()
device = conf.getitem(&quot;server@office&quot;)
server = connpy.node(&quot;unique name&quot;, **device, config=conf)
result = server.run([&quot;cd /&quot;, &quot;ls -la&quot;])
print(result)
</code></pre>
<h3 id="running-parallel-tasks">Running parallel tasks</h3>
<pre><code>import connpy
conf = connpy.configfile()
#You can get the nodes from the config from a folder and fitlering in it
nodes = conf.getitem(&quot;@office&quot;, [&quot;router1&quot;, &quot;router2&quot;, &quot;router3&quot;])
#You can also get each node individually:
nodes = {}
nodes[&quot;router1&quot;] = conf.getitem(&quot;router1@office&quot;)
nodes[&quot;router2&quot;] = conf.getitem(&quot;router2@office&quot;)
nodes[&quot;router10&quot;] = conf.getitem(&quot;router10@datacenter&quot;)
#Also, you can create the nodes manually:
nodes = {}
nodes[&quot;router1&quot;] = {&quot;host&quot;: &quot;1.1.1.1&quot;, &quot;user&quot;: &quot;user&quot;, &quot;password&quot;: &quot;pass1&quot;}
nodes[&quot;router2&quot;] = {&quot;host&quot;: &quot;1.1.1.2&quot;, &quot;user&quot;: &quot;user&quot;, &quot;password&quot;: &quot;pass2&quot;}
nodes[&quot;router3&quot;] = {&quot;host&quot;: &quot;1.1.1.2&quot;, &quot;user&quot;: &quot;user&quot;, &quot;password&quot;: &quot;pass3&quot;}
#Finally you run some tasks on the nodes
mynodes = connpy.nodes(nodes, config = conf)
result = mynodes.test([&quot;show ip int br&quot;], &quot;1.1.1.2&quot;)
for i in result:
    print(&quot;---&quot; + i + &quot;---&quot;)
    print(result[i])
    print()
# Or for one specific node
mynodes.router1.run([&quot;term len 0&quot;. &quot;show run&quot;], folder = &quot;/home/user/logs&quot;)
</code></pre>
<h3 id="using-variables">Using variables</h3>
<pre><code>import connpy
config = connpy.configfile()
nodes = config.getitem(&quot;@office&quot;, [&quot;router1&quot;, &quot;router2&quot;, &quot;router3&quot;])
commands = []
commands.append(&quot;config t&quot;)
commands.append(&quot;interface lo {id}&quot;)
commands.append(&quot;ip add {ip} {mask}&quot;)
commands.append(&quot;end&quot;)
variables = {}
variables[&quot;router1@office&quot;] = {&quot;ip&quot;: &quot;10.57.57.1&quot;}
variables[&quot;router2@office&quot;] = {&quot;ip&quot;: &quot;10.57.57.2&quot;}
variables[&quot;router3@office&quot;] = {&quot;ip&quot;: &quot;10.57.57.3&quot;}
variables[&quot;__global__&quot;] = {&quot;id&quot;: &quot;57&quot;}
variables[&quot;__global__&quot;][&quot;mask&quot;] =  &quot;255.255.255.255&quot;
expected = &quot;!&quot;
routers = connpy.nodes(nodes, config = config)
routers.run(commands, variables)
routers.test(&quot;ping {ip}&quot;, expected, variables)
for key in routers.result:
    print(key, ' ---&gt; ', (&quot;pass&quot; if routers.result[key] else &quot;fail&quot;))
</code></pre>
<h3 id="using-ai">Using AI</h3>
<pre><code>import connpy
conf = connpy.configfile()
organization = 'openai-org'
api_key = &quot;openai-key&quot;
myia = ai(conf, organization, api_key)
input = &quot;go to router 1 and get me the full configuration&quot;
result = myia.ask(input, dryrun = False)
print(result)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
&#39;&#39;&#39;
## Connection manager

Connpy is a connection manager that allows you to store nodes to connect them fast and password free.

### Features
    - You can generate profiles and reference them from nodes using @profilename 
      so you dont need to edit multiple nodes when changing password or other 
      information.
    - Nodes can be stored on @folder or @subfolder@folder to organize your 
      devices. Then can be referenced using node@subfolder@folder or node@folder
    - If you have too many nodes. Get completion script using: conn config 
      --completion, or use fzf installing pyfzf and running conn config --fzf true
    - Much more!

### Usage
```
usage: conn [-h] [--add | --del | --mod | --show | --debug] [node|folder] [--sftp]
       conn {profile,move,mv,copy,cp,list,ls,bulk,export,import,ai,run,api,plugin,config} ...

positional arguments:
  node|folder    node[@subfolder][@folder]
                 Connect to specific node or show all matching nodes
                 [@subfolder][@folder]
                 Show all available connections globaly or in specified path
Options:
  -h, --help         show this help message and exit
  -v, --version      Show version
  -a, --add          Add new node[@subfolder][@folder] or [@subfolder]@folder
  -r, --del, --rm    Delete node[@subfolder][@folder] or [@subfolder]@folder
  -e, --mod, --edit  Modify node[@subfolder][@folder]
  -s, --show         Show node[@subfolder][@folder]
  -d, --debug        Display all conections steps
  -t, --sftp         Connects using sftp instead of ssh

Commands:
  profile         Manage profiles
  move(mv)        Move node
  copy(cp)        Copy node
  list(ls)        List profiles, nodes or folders
  bulk            Add nodes in bulk
  export          Export connection folder to Yaml file
  import          Import connection folder to config from Yaml file
  ai              Make request to an AI
  run             Run scripts or commands on nodes
  api             Start and stop connpy api
  plugin          Manage plugins
  config          Manage app config
```

###   Manage profiles
```
usage: conn profile [-h] (--add | --del | --mod | --show) profile

positional arguments:
  profile        Name of profile to manage

options:
  -h, --help         show this help message and exit
  -a, --add          Add new profile
  -r, --del, --rm    Delete profile
  -e, --mod, --edit  Modify profile
  -s, --show         Show profile

```

###   Examples
```
   conn profile --add office-user
   conn --add @office
   conn --add @datacenter@office
   conn --add server@datacenter@office
   conn --add pc@office
   conn --show server@datacenter@office
   conn pc@office
   conn server
``` 
## Plugin Requirements for Connpy
### General Structure
- The plugin script must be a Python file.
- Only the following top-level elements are allowed in the plugin script:
  - Class definitions
  - Function definitions
  - Import statements
  - The `if __name__ == &#34;__main__&#34;:` block for standalone execution
  - Pass statements

### Specific Class Requirements
- The plugin script must define at least two specific classes:
  1. **Class `Parser`**:
     - Must contain only one method: `__init__`.
     - The `__init__` method must initialize at least two attributes:
       - `self.parser`: An instance of `argparse.ArgumentParser`.
       - `self.description`: A string containing the description of the parser.
  2. **Class `Entrypoint`**:
     - Must have an `__init__` method that accepts exactly three parameters besides `self`:
       - `args`: Arguments passed to the plugin.
       - The parser instance (typically `self.parser` from the `Parser` class).
       - The Connapp instance to interact with the Connpy app.

### Executable Block
- The plugin script can include an executable block:
  - `if __name__ == &#34;__main__&#34;:`
  - This block allows the plugin to be run as a standalone script for testing or independent use.

### Script Verification
- The `verify_script` method in `plugins.py` is used to check the plugin script&#39;s compliance with these standards.
- Non-compliant scripts will be rejected to ensure consistency and proper functionality within the plugin system.
- 
### Example Script

For a practical example of how to write a compatible plugin script, please refer to the following example:

[Example Plugin Script](https://github.com/fluzzi/awspy)

This script demonstrates the required structure and implementation details according to the plugin system&#39;s standards.

## http API
With the Connpy API you can run commands on devices using http requests

### 1. List Nodes

**Endpoint**: `/list_nodes`

**Method**: `POST`

**Description**: This route returns a list of nodes. It can also filter the list based on a given keyword.

#### Request Body:

```json
{
  &#34;filter&#34;: &#34;&lt;keyword&gt;&#34;
}
```

* `filter` (optional): A keyword to filter the list of nodes. It returns only the nodes that contain the keyword. If not provided, the route will return the entire list of nodes.

#### Response:

- A JSON array containing the filtered list of nodes.

---

### 2. Get Nodes

**Endpoint**: `/get_nodes`

**Method**: `POST`

**Description**: This route returns a dictionary of nodes with all their attributes. It can also filter the nodes based on a given keyword.

#### Request Body:

```json
{
  &#34;filter&#34;: &#34;&lt;keyword&gt;&#34;
}
```

* `filter` (optional): A keyword to filter the nodes. It returns only the nodes that contain the keyword. If not provided, the route will return the entire list of nodes.

#### Response:

- A JSON array containing the filtered nodes.

---

### 3. Run Commands

**Endpoint**: `/run_commands`

**Method**: `POST`

**Description**: This route runs commands on selected nodes based on the provided action, nodes, and commands. It also supports executing tests by providing expected results.

#### Request Body:

```json
{
  &#34;action&#34;: &#34;&lt;action&gt;&#34;,
  &#34;nodes&#34;: &#34;&lt;nodes&gt;&#34;,
  &#34;commands&#34;: &#34;&lt;commands&gt;&#34;,
  &#34;expected&#34;: &#34;&lt;expected&gt;&#34;,
  &#34;options&#34;: &#34;&lt;options&gt;&#34;
}
```

* `action` (required): The action to be performed. Possible values: `run` or `test`.
* `nodes` (required): A list of nodes or a single node on which the commands will be executed. The nodes can be specified as individual node names or a node group with the `@` prefix. Node groups can also be specified as arrays with a list of nodes inside the group.
* `commands` (required): A list of commands to be executed on the specified nodes.
* `expected` (optional, only used when the action is `test`): A single expected result for the test.
* `options` (optional): Array to pass options to the run command, options are: `prompt`, `parallel`, `timeout`  

#### Response:

- A JSON object with the results of the executed commands on the nodes.

---

### 4. Ask AI

**Endpoint**: `/ask_ai`

**Method**: `POST`

**Description**: This route sends to chatgpt IA a request that will parse it into an understandable output for the application and then run the request.

#### Request Body:

```json
{
  &#34;input&#34;: &#34;&lt;user input request&gt;&#34;,
  &#34;dryrun&#34;: true or false
}
```

* `input` (required): The user input requesting the AI to perform an action on some devices or get the devices list.
* `dryrun` (optional): If set to true, it will return the parameters to run the request but it won&#39;t run it. default is false.

#### Response:

- A JSON array containing the action to run and the parameters and the result of the action.

## Automation module
The automation module
### Standalone module
```
import connpy
router = connpy.node(&#34;uniqueName&#34;,&#34;ip/host&#34;, user=&#34;user&#34;, password=&#34;pass&#34;)
router.run([&#34;term len 0&#34;,&#34;show run&#34;])
print(router.output)
hasip = router.test(&#34;show ip int brief&#34;,&#34;1.1.1.1&#34;)
if hasip:
    print(&#34;Router has ip 1.1.1.1&#34;)
else:
    print(&#34;router does not have ip 1.1.1.1&#34;)
```

### Using manager configuration
```
import connpy
conf = connpy.configfile()
device = conf.getitem(&#34;server@office&#34;)
server = connpy.node(&#34;unique name&#34;, **device, config=conf)
result = server.run([&#34;cd /&#34;, &#34;ls -la&#34;])
print(result)
```
### Running parallel tasks 
```
import connpy
conf = connpy.configfile()
#You can get the nodes from the config from a folder and fitlering in it
nodes = conf.getitem(&#34;@office&#34;, [&#34;router1&#34;, &#34;router2&#34;, &#34;router3&#34;])
#You can also get each node individually:
nodes = {}
nodes[&#34;router1&#34;] = conf.getitem(&#34;router1@office&#34;)
nodes[&#34;router2&#34;] = conf.getitem(&#34;router2@office&#34;)
nodes[&#34;router10&#34;] = conf.getitem(&#34;router10@datacenter&#34;)
#Also, you can create the nodes manually:
nodes = {}
nodes[&#34;router1&#34;] = {&#34;host&#34;: &#34;1.1.1.1&#34;, &#34;user&#34;: &#34;user&#34;, &#34;password&#34;: &#34;pass1&#34;}
nodes[&#34;router2&#34;] = {&#34;host&#34;: &#34;1.1.1.2&#34;, &#34;user&#34;: &#34;user&#34;, &#34;password&#34;: &#34;pass2&#34;}
nodes[&#34;router3&#34;] = {&#34;host&#34;: &#34;1.1.1.2&#34;, &#34;user&#34;: &#34;user&#34;, &#34;password&#34;: &#34;pass3&#34;}
#Finally you run some tasks on the nodes
mynodes = connpy.nodes(nodes, config = conf)
result = mynodes.test([&#34;show ip int br&#34;], &#34;1.1.1.2&#34;)
for i in result:
    print(&#34;---&#34; + i + &#34;---&#34;)
    print(result[i])
    print()
# Or for one specific node
mynodes.router1.run([&#34;term len 0&#34;. &#34;show run&#34;], folder = &#34;/home/user/logs&#34;)
```
### Using variables
```
import connpy
config = connpy.configfile()
nodes = config.getitem(&#34;@office&#34;, [&#34;router1&#34;, &#34;router2&#34;, &#34;router3&#34;])
commands = []
commands.append(&#34;config t&#34;)
commands.append(&#34;interface lo {id}&#34;)
commands.append(&#34;ip add {ip} {mask}&#34;)
commands.append(&#34;end&#34;)
variables = {}
variables[&#34;router1@office&#34;] = {&#34;ip&#34;: &#34;10.57.57.1&#34;}
variables[&#34;router2@office&#34;] = {&#34;ip&#34;: &#34;10.57.57.2&#34;}
variables[&#34;router3@office&#34;] = {&#34;ip&#34;: &#34;10.57.57.3&#34;}
variables[&#34;__global__&#34;] = {&#34;id&#34;: &#34;57&#34;}
variables[&#34;__global__&#34;][&#34;mask&#34;] =  &#34;255.255.255.255&#34;
expected = &#34;!&#34;
routers = connpy.nodes(nodes, config = config)
routers.run(commands, variables)
routers.test(&#34;ping {ip}&#34;, expected, variables)
for key in routers.result:
    print(key, &#39; ---&gt; &#39;, (&#34;pass&#34; if routers.result[key] else &#34;fail&#34;))
```
### Using AI
```
import connpy
conf = connpy.configfile()
organization = &#39;openai-org&#39;
api_key = &#34;openai-key&#34;
myia = ai(conf, organization, api_key)
input = &#34;go to router 1 and get me the full configuration&#34;
result = myia.ask(input, dryrun = False)
print(result)
```
&#39;&#39;&#39;
from .core import node,nodes
from .configfile import configfile
from .connapp import connapp
from .api import *
from .ai import ai
from .plugins import Plugins
from ._version import __version__
from pkg_resources import get_distribution

__all__ = [&#34;node&#34;, &#34;nodes&#34;, &#34;configfile&#34;, &#34;connapp&#34;, &#34;ai&#34;, &#34;Plugins&#34;]
__author__ = &#34;Federico Luzzi&#34;
__pdoc__ = {
    &#39;core&#39;: False,
    &#39;completion&#39;: False,
    &#39;api&#39;: False,
    &#39;plugins&#39;: False
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="connpy.Plugins"><code class="flex name class">
<span>class <span class="ident">Plugins</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Plugins:
    def __init__(self):
        self.plugins = {}
        self.plugin_parsers = {}

    def verify_script(self, file_path):
        &#34;&#34;&#34;
        Verifies that a given Python script meets specific structural requirements.

        This function checks a Python script for compliance with predefined structural 
        rules. It ensures that the script contains only allowed top-level elements 
        (functions, classes, imports, pass statements, and a specific if __name__ block) 
        and that it includes mandatory classes with specific attributes and methods.

        ### Arguments:
            - file_path (str): The file path of the Python script to be verified.

        ### Returns:
            - str: A message indicating the type of violation if the script doesn&#39;t meet 
                 the requirements, or False if all requirements are met.

        ### Verifications:
            - The presence of only allowed top-level elements.
            - The existence of two specific classes: &#39;Parser&#39; and &#39;Entrypoint&#39;.
            - &#39;Parser&#39; class must only have an &#39;__init__&#39; method and must assign &#39;self.parser&#39;
              and &#39;self.description&#39;.
            - &#39;Entrypoint&#39; class must have an &#39;__init__&#39; method accepting specific arguments.

        If any of these checks fail, the function returns an error message indicating 
        the reason. If the script passes all checks, the function returns False, 
        indicating successful verification.

        ### Exceptions:
                - SyntaxError: If the script contains a syntax error, it is caught and 
                               returned as a part of the error message.
        &#34;&#34;&#34;
        with open(file_path, &#39;r&#39;) as file:
            source_code = file.read()

        try:
            tree = ast.parse(source_code)
        except SyntaxError as e:
            return f&#34;Syntax error in file: {e}&#34;

        required_classes = {&#39;Parser&#39;, &#39;Entrypoint&#39;}
        found_classes = set()

        for node in tree.body:
            # Allow only function definitions, class definitions, and pass statements at top-level
            if isinstance(node, ast.If):
                # Check for the &#39;if __name__ == &#34;__main__&#34;:&#39; block
                if not (isinstance(node.test, ast.Compare) and
                        isinstance(node.test.left, ast.Name) and
                        node.test.left.id == &#39;__name__&#39; and
                        isinstance(node.test.comparators[0], ast.Str) and
                        node.test.comparators[0].s == &#39;__main__&#39;):
                    return &#34;Only __name__ == __main__ If is allowed&#34;

            elif not isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.Import, ast.ImportFrom, ast.Pass)):
                return f&#34;Plugin can only have pass, functions, classes and imports. {node} is not allowed&#34;  # Reject any other AST types

            if isinstance(node, ast.ClassDef) and node.name in required_classes:
                found_classes.add(node.name)

                if node.name == &#39;Parser&#39;:
                    # Ensure Parser class has only the __init__ method and assigns self.parser
                    if not all(isinstance(method, ast.FunctionDef) and method.name == &#39;__init__&#39; for method in node.body):
                        return &#34;Parser class should only have __init__ method&#34;

                    # Check if &#39;self.parser&#39; and &#39;self.description&#39; are assigned in __init__ method
                    init_method = node.body[0]
                    assigned_attrs = [target.attr for expr in init_method.body if isinstance(expr, ast.Assign) for target in expr.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == &#39;self&#39;]
                    if &#39;parser&#39; not in assigned_attrs or &#39;description&#39; not in assigned_attrs:
                        return &#34;Parser class should set self.parser and self.description&#34; # &#39;self.parser&#39; or &#39;self.description&#39; not assigned in __init__

                elif node.name == &#39;Entrypoint&#39;:
                    init_method = next((item for item in node.body if isinstance(item, ast.FunctionDef) and item.name == &#39;__init__&#39;), None)
                    if not init_method or len(init_method.args.args) != 4:  # self, args, parser, conapp
                        return &#34;Entrypoint class should accept only arguments: args, parser and connapp&#34;  # &#39;Entrypoint&#39; __init__ does not have correct signature

        if required_classes == found_classes:
            return False
        else:
            return &#34;Classes Entrypoint and Parser are mandatory&#34;

    def _import_from_path(self, path):
        spec = importlib.util.spec_from_file_location(&#34;module.name&#34;, path)
        module = importlib.util.module_from_spec(spec)
        sys.modules[&#34;module.name&#34;] = module
        spec.loader.exec_module(module)
        return module

    def _import_plugins_to_argparse(self, directory, subparsers):
        for filename in os.listdir(directory):
            commands = subparsers.choices.keys()
            if filename.endswith(&#34;.py&#34;):
                root_filename = os.path.splitext(filename)[0]
                if root_filename in commands:
                    continue
                # Construct the full path
                filepath = os.path.join(directory, filename)
                check_file = self.verify_script(filepath)
                if check_file:
                    continue
                else:
                    self.plugins[root_filename] = self._import_from_path(filepath)
                    self.plugin_parsers[root_filename] = self.plugins[root_filename].Parser()
                    subparsers.add_parser(root_filename, parents=[self.plugin_parsers[root_filename].parser], add_help=False, description=self.plugin_parsers[root_filename].description)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="connpy.Plugins.verify_script"><code class="name flex">
<span>def <span class="ident">verify_script</span></span>(<span>self, file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Verifies that a given Python script meets specific structural requirements.</p>
<p>This function checks a Python script for compliance with predefined structural
rules. It ensures that the script contains only allowed top-level elements
(functions, classes, imports, pass statements, and a specific if <strong>name</strong> block)
and that it includes mandatory classes with specific attributes and methods.</p>
<h3 id="arguments">Arguments:</h3>
<pre><code>- file_path (str): The file path of the Python script to be verified.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>- str: A message indicating the type of violation if the script doesn't meet 
     the requirements, or False if all requirements are met.
</code></pre>
<h3 id="verifications">Verifications:</h3>
<pre><code>- The presence of only allowed top-level elements.
- The existence of two specific classes: 'Parser' and 'Entrypoint'.
- 'Parser' class must only have an '__init__' method and must assign 'self.parser'
  and 'self.description'.
- 'Entrypoint' class must have an '__init__' method accepting specific arguments.
</code></pre>
<p>If any of these checks fail, the function returns an error message indicating
the reason. If the script passes all checks, the function returns False,
indicating successful verification.</p>
<h3 id="exceptions">Exceptions:</h3>
<pre><code>    - SyntaxError: If the script contains a syntax error, it is caught and 
                   returned as a part of the error message.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_script(self, file_path):
    &#34;&#34;&#34;
    Verifies that a given Python script meets specific structural requirements.

    This function checks a Python script for compliance with predefined structural 
    rules. It ensures that the script contains only allowed top-level elements 
    (functions, classes, imports, pass statements, and a specific if __name__ block) 
    and that it includes mandatory classes with specific attributes and methods.

    ### Arguments:
        - file_path (str): The file path of the Python script to be verified.

    ### Returns:
        - str: A message indicating the type of violation if the script doesn&#39;t meet 
             the requirements, or False if all requirements are met.

    ### Verifications:
        - The presence of only allowed top-level elements.
        - The existence of two specific classes: &#39;Parser&#39; and &#39;Entrypoint&#39;.
        - &#39;Parser&#39; class must only have an &#39;__init__&#39; method and must assign &#39;self.parser&#39;
          and &#39;self.description&#39;.
        - &#39;Entrypoint&#39; class must have an &#39;__init__&#39; method accepting specific arguments.

    If any of these checks fail, the function returns an error message indicating 
    the reason. If the script passes all checks, the function returns False, 
    indicating successful verification.

    ### Exceptions:
            - SyntaxError: If the script contains a syntax error, it is caught and 
                           returned as a part of the error message.
    &#34;&#34;&#34;
    with open(file_path, &#39;r&#39;) as file:
        source_code = file.read()

    try:
        tree = ast.parse(source_code)
    except SyntaxError as e:
        return f&#34;Syntax error in file: {e}&#34;

    required_classes = {&#39;Parser&#39;, &#39;Entrypoint&#39;}
    found_classes = set()

    for node in tree.body:
        # Allow only function definitions, class definitions, and pass statements at top-level
        if isinstance(node, ast.If):
            # Check for the &#39;if __name__ == &#34;__main__&#34;:&#39; block
            if not (isinstance(node.test, ast.Compare) and
                    isinstance(node.test.left, ast.Name) and
                    node.test.left.id == &#39;__name__&#39; and
                    isinstance(node.test.comparators[0], ast.Str) and
                    node.test.comparators[0].s == &#39;__main__&#39;):
                return &#34;Only __name__ == __main__ If is allowed&#34;

        elif not isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.Import, ast.ImportFrom, ast.Pass)):
            return f&#34;Plugin can only have pass, functions, classes and imports. {node} is not allowed&#34;  # Reject any other AST types

        if isinstance(node, ast.ClassDef) and node.name in required_classes:
            found_classes.add(node.name)

            if node.name == &#39;Parser&#39;:
                # Ensure Parser class has only the __init__ method and assigns self.parser
                if not all(isinstance(method, ast.FunctionDef) and method.name == &#39;__init__&#39; for method in node.body):
                    return &#34;Parser class should only have __init__ method&#34;

                # Check if &#39;self.parser&#39; and &#39;self.description&#39; are assigned in __init__ method
                init_method = node.body[0]
                assigned_attrs = [target.attr for expr in init_method.body if isinstance(expr, ast.Assign) for target in expr.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == &#39;self&#39;]
                if &#39;parser&#39; not in assigned_attrs or &#39;description&#39; not in assigned_attrs:
                    return &#34;Parser class should set self.parser and self.description&#34; # &#39;self.parser&#39; or &#39;self.description&#39; not assigned in __init__

            elif node.name == &#39;Entrypoint&#39;:
                init_method = next((item for item in node.body if isinstance(item, ast.FunctionDef) and item.name == &#39;__init__&#39;), None)
                if not init_method or len(init_method.args.args) != 4:  # self, args, parser, conapp
                    return &#34;Entrypoint class should accept only arguments: args, parser and connapp&#34;  # &#39;Entrypoint&#39; __init__ does not have correct signature

    if required_classes == found_classes:
        return False
    else:
        return &#34;Classes Entrypoint and Parser are mandatory&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="connpy.ai"><code class="flex name class">
<span>class <span class="ident">ai</span></span>
<span>(</span><span>config, org=None, api_key=None, model=None, temp=0.7)</span>
</code></dt>
<dd>
<div class="desc"><p>This class generates a ai object. Containts all the information and methods to make requests to openAI chatGPT to run actions on the application.</p>
<h3 id="attributes">Attributes:</h3>
<pre><code>- model        (str): Model of GPT api to use. Default is gpt-3.5-turbo.

- temp       (float): Value between 0 and 1 that control the randomness 
                      of generated text, with higher values increasing 
                      creativity. Default is 0.7.
</code></pre>
<h3 id="parameters">Parameters:</h3>
<pre><code>- config (obj): Pass the object created with class configfile with 
                key for decryption and extra configuration if you 
                are using connection manager.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- org     (str): A unique token identifying the user organization
                 to interact with the API.

- api_key (str): A unique authentication token required to access 
                 and interact with the API.

- model   (str): Model of GPT api to use. Default is gpt-3.5-turbo.

- temp  (float): Value between 0 and 1 that control the randomness 
                 of generated text, with higher values increasing 
                 creativity. Default is 0.7.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ai:
    &#39;&#39;&#39; This class generates a ai object. Containts all the information and methods to make requests to openAI chatGPT to run actions on the application.

    ### Attributes:  

        - model        (str): Model of GPT api to use. Default is gpt-3.5-turbo.

        - temp       (float): Value between 0 and 1 that control the randomness 
                              of generated text, with higher values increasing 
                              creativity. Default is 0.7.

        &#39;&#39;&#39;

    def __init__(self, config, org = None, api_key = None, model = None, temp = 0.7):
        &#39;&#39;&#39; 
            
        ### Parameters:  

            - config (obj): Pass the object created with class configfile with 
                            key for decryption and extra configuration if you 
                            are using connection manager.  

        ### Optional Parameters:  

            - org     (str): A unique token identifying the user organization
                             to interact with the API.

            - api_key (str): A unique authentication token required to access 
                             and interact with the API.

            - model   (str): Model of GPT api to use. Default is gpt-3.5-turbo. 

            - temp  (float): Value between 0 and 1 that control the randomness 
                             of generated text, with higher values increasing 
                             creativity. Default is 0.7.
   

        &#39;&#39;&#39;
        self.config = config
        if org:
            openai.organization = org
        else:
            try: 
                openai.organization = self.config.config[&#34;openai&#34;][&#34;organization&#34;]
            except:
                raise ValueError(&#34;Missing openai organization&#34;)
        if api_key:
            openai.api_key = api_key
        else:
            try: 
                openai.api_key = self.config.config[&#34;openai&#34;][&#34;api_key&#34;]
            except:
                raise ValueError(&#34;Missing openai api_key&#34;)
        if model:
            self.model = model
        else:
            try:
                self.model = self.config.config[&#34;openai&#34;][&#34;model&#34;]
            except:
                self.model = &#34;gpt-3.5-turbo&#34;
        self.temp = temp
        self.__prompt = {}
        self.__prompt[&#34;original_system&#34;] = &#34;&#34;&#34;
            You are the AI chatbot and assistant of a network connection manager and automation app called connpy. When provided with user input analyze the input and extract the following information. If user wants to chat just reply and don&#39;t call a function:

            - type: Given a user input, identify the type of request they want to make. The input will represent one of two options: 

                1. &#34;command&#34; - The user wants to get information from devices by running commands.
                2. &#34;list_nodes&#34; - The user wants to get a list of nodes, devices, servers, or routers.
                The &#39;type&#39; field should reflect whether the user input is a command or a request for a list of nodes.

            - filter: One or more regex patterns indicating the device or group of devices the command should be run on. The filter can have different formats, such as:
                - hostname
                - hostname@folder
                - hostname@subfolder@folder
                - partofhostname
                - @folder
                - @subfolder@folder
                - regex_pattern

                The filter should be extracted from the user input exactly as it was provided.
                Always preserve the exact filter pattern provided by the user, with no modifications. Do not process any regex, the application can do that.

    &#34;&#34;&#34; 
        self.__prompt[&#34;original_user&#34;] = &#34;Get the IP addresses of loopback0 for all routers from w2az1 and e1.*(prod|dev) and check if they have the ip 192.168.1.1&#34;
        self.__prompt[&#34;original_assistant&#34;] = {&#34;name&#34;: &#34;get_network_device_info&#34;, &#34;arguments&#34;: &#34;{\n  \&#34;type\&#34;: \&#34;command\&#34;,\n  \&#34;filter\&#34;: [\&#34;w2az1\&#34;,\&#34;e1.*(prod|dev)\&#34;]\n}&#34;}
        self.__prompt[&#34;original_function&#34;] = {}
        self.__prompt[&#34;original_function&#34;][&#34;name&#34;] = &#34;get_network_device_info&#34;
        self.__prompt[&#34;original_function&#34;][&#34;descriptions&#34;] = &#34;You are the AI chatbot and assistant of a network connection manager and automation app called connpy. When provided with user input analyze the input and extract the information acording to the function, If user wants to chat just reply and don&#39;t call a function&#34;,
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;] = {}
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;type&#34;] = &#34;object&#34;
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;] = {}
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;type&#34;] = {}
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;type&#34;][&#34;type&#34;] = &#34;string&#34;
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;type&#34;][&#34;description&#34;] =&#34;&#34;&#34;
Categorize the user&#39;s request based on the operation they want to perform on the nodes. The requests can be classified into the following categories:

    1. &#34;command&#34; - This represents a request to retrieve specific information or configurations from nodes. An example would be: &#34;go to routers in @office and get the config&#34;.

    2. &#34;list_nodes&#34; - This is when the user wants a list of nodes. An example could be: &#34;get me the nodes in @office&#34;.
&#34;&#34;&#34;
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;type&#34;][&#34;enum&#34;] = [&#34;command&#34;, &#34;list_nodes&#34;]
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;filter&#34;] = {}
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;filter&#34;][&#34;type&#34;] = &#34;array&#34;
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;filter&#34;][&#34;items&#34;] = {}
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;filter&#34;][&#34;items&#34;][&#34;type&#34;] = &#34;string&#34;
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;filter&#34;][&#34;items&#34;][&#34;description&#34;] = &#34;&#34;&#34;One or more regex patterns indicating the device or group of devices the command should be run on.  The filter should be extracted from the user input exactly as it was provided. 
                The filter can have different formats, such as:
                - hostname
                - hostname@folder
                - hostname@subfolder@folder
                - partofhostname
                - @folder
                - @subfolder@folder
                - regex_pattern
                &#34;&#34;&#34;
        self.__prompt[&#34;original_function&#34;][&#34;parameters&#34;][&#34;required&#34;] = [&#34;type&#34;, &#34;filter&#34;]
        self.__prompt[&#34;command_system&#34;] = &#34;&#34;&#34;
        For each OS listed below, provide the command(s) needed to perform the specified action, depending on the device OS (e.g., Cisco IOSXR router, Linux server).
        The application knows how to connect to devices via SSH, so you only need to provide the command(s) to run after connecting. 
        If the commands needed are not for the specific OS type, just send an empty list (e.g., []). 
        Note: Preserving the integrity of user-provided commands is of utmost importance. If a user has provided a specific command to run, include that command exactly as it was given, even if it&#39;s not recognized or understood. Under no circumstances should you modify or alter user-provided commands.
    &#34;&#34;&#34;
        self.__prompt[&#34;command_user&#34;]= &#34;&#34;&#34;
    input: show me the full configuration for all this devices:

    OS:
    cisco ios:
    &#34;&#34;&#34;
        self.__prompt[&#34;command_assistant&#34;] = {&#34;name&#34;: &#34;get_commands&#34;, &#34;arguments&#34;: &#34;{\n  \&#34;cisco ios\&#34;: \&#34;show running-configuration\&#34;\n}&#34;}
        self.__prompt[&#34;command_function&#34;] = {}
        self.__prompt[&#34;command_function&#34;][&#34;name&#34;] = &#34;get_commands&#34;
        self.__prompt[&#34;command_function&#34;][&#34;descriptions&#34;] = &#34;&#34;&#34; 
        For each OS listed below, provide the command(s) needed to perform the specified action, depending on the device OS (e.g., Cisco IOSXR router, Linux server).
        The application knows how to connect to devices via SSH, so you only need to provide the command(s) to run after connecting. 
        If the commands needed are not for the specific OS type, just send an empty list (e.g., []). 
    &#34;&#34;&#34;
        self.__prompt[&#34;command_function&#34;][&#34;parameters&#34;] = {}
        self.__prompt[&#34;command_function&#34;][&#34;parameters&#34;][&#34;type&#34;] = &#34;object&#34;
        self.__prompt[&#34;command_function&#34;][&#34;parameters&#34;][&#34;properties&#34;] = {}
        self.__prompt[&#34;confirmation_system&#34;] = &#34;&#34;&#34;
        Please analyze the user&#39;s input and categorize it as either an affirmation or negation. Based on this analysis, respond with:

            &#39;true&#39; if the input is an affirmation like &#39;do it&#39;, &#39;go ahead&#39;, &#39;sure&#39;, etc.
            &#39;false&#39; if the input is a negation.
            &#39;none&#39; If the input does not fit into either of these categories.
            &#34;&#34;&#34;
        self.__prompt[&#34;confirmation_user&#34;] = &#34;Yes go ahead!&#34;
        self.__prompt[&#34;confirmation_assistant&#34;] = &#34;True&#34;
        self.__prompt[&#34;confirmation_function&#34;] = {}
        self.__prompt[&#34;confirmation_function&#34;][&#34;name&#34;] = &#34;get_confirmation&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;descriptions&#34;] = &#34;&#34;&#34; 
        Analize user request and respond:
    &#34;&#34;&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;] = {}
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;type&#34;] = &#34;object&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;] = {}
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;result&#34;] = {}
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;result&#34;][&#34;description&#34;] = &#34;&#34;&#34;&#39;true&#39; if the input is an affirmation like &#39;do it&#39;, &#39;go ahead&#39;, &#39;sure&#39;, etc.
&#39;false&#39; if the input is a negation.
&#39;none&#39; If the input does not fit into either of these categories&#34;&#34;&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;result&#34;][&#34;type&#34;] = &#34;string&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;result&#34;][&#34;enum&#34;] = [&#34;true&#34;, &#34;false&#34;, &#34;none&#34;]
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;response&#34;] = {}
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;response&#34;][&#34;description&#34;] = &#34;If the user don&#39;t message is not an affiramtion or negation, kindly ask the user to rephrase.&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;properties&#34;][&#34;response&#34;][&#34;type&#34;] = &#34;string&#34;
        self.__prompt[&#34;confirmation_function&#34;][&#34;parameters&#34;][&#34;required&#34;] = [&#34;result&#34;]

    def process_string(self, s):
        if s.startswith(&#39;[&#39;) and s.endswith(&#39;]&#39;) and not (s.startswith(&#34;[&#39;&#34;) and s.endswith(&#34;&#39;]&#34;)) and not (s.startswith(&#39;[&#34;&#39;) and s.endswith(&#39;&#34;]&#39;)):
            # Extract the content inside square brackets and split by comma
            content = s[1:-1].split(&#39;,&#39;)
            # Add single quotes around each item and join them back together with commas
            new_content = &#39;, &#39;.join(f&#34;&#39;{item.strip()}&#39;&#34; for item in content)
            # Replace the old content with the new content
            s = &#39;[&#39; + new_content + &#39;]&#39;
        return s

    def _retry_function(self, function, max_retries, backoff_num, *args):
        #Retry openai requests
        retries = 0
        while retries &lt; max_retries:
            try:
                myfunction = function(*args)
                break
            except:
                wait_time = backoff_num * (2 ** retries)
                time.sleep(wait_time)
                retries += 1
                continue
        if retries == max_retries:
            myfunction = False
        return myfunction

    def _clean_command_response(self, raw_response, node_list):
        #Parse response for command request to openAI GPT.
        info_dict = {}
        info_dict[&#34;commands&#34;] = []
        info_dict[&#34;variables&#34;] = {}
        info_dict[&#34;variables&#34;][&#34;__global__&#34;] = {}
        for key, value in node_list.items():
            newvalue = {}
            commands = raw_response[value]
            for i,e in enumerate(commands, start=1):
                newvalue[f&#34;command{i}&#34;] = e
                if f&#34;{{command{i}}}&#34; not in info_dict[&#34;commands&#34;]:
                    info_dict[&#34;commands&#34;].append(f&#34;{{command{i}}}&#34;)
                    info_dict[&#34;variables&#34;][&#34;__global__&#34;][f&#34;command{i}&#34;] = &#34;&#34;
                info_dict[&#34;variables&#34;][key] = newvalue
        return info_dict

    def _get_commands(self, user_input, nodes):
        #Send the request for commands for each device to openAI GPT.
        output_list = []
        command_function = deepcopy(self.__prompt[&#34;command_function&#34;])
        node_list = {}
        for key, value in nodes.items():
            tags = value.get(&#39;tags&#39;, {})
            try:
                if os_value := tags.get(&#39;os&#39;):
                    node_list[key] = os_value
                    output_list.append(f&#34;{os_value}&#34;)
                    command_function[&#34;parameters&#34;][&#34;properties&#34;][os_value] = {}
                    command_function[&#34;parameters&#34;][&#34;properties&#34;][os_value][&#34;type&#34;] = &#34;array&#34;
                    command_function[&#34;parameters&#34;][&#34;properties&#34;][os_value][&#34;description&#34;] = f&#34;OS: {os_value}&#34;
                    command_function[&#34;parameters&#34;][&#34;properties&#34;][os_value][&#34;items&#34;] = {}
                    command_function[&#34;parameters&#34;][&#34;properties&#34;][os_value][&#34;items&#34;][&#34;type&#34;] = &#34;string&#34; 
            except:
                pass
        output_str = &#34;\n&#34;.join(list(set(output_list)))
        command_input = f&#34;input: {user_input}\n\nOS:\n{output_str}&#34;
        message = []
        message.append({&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: dedent(self.__prompt[&#34;command_system&#34;]).strip()})
        message.append({&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: dedent(self.__prompt[&#34;command_user&#34;]).strip()})
        message.append({&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: None, &#34;function_call&#34;: self.__prompt[&#34;command_assistant&#34;]})
        message.append({&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: command_input})
        functions = [command_function]
        response = openai.ChatCompletion.create(
            model=self.model,
            messages=message,
            functions=functions,
            function_call={&#34;name&#34;: &#34;get_commands&#34;},
            temperature=self.temp
            )
        output = {}
        result = response[&#34;choices&#34;][0][&#34;message&#34;].to_dict()
        json_result = json.loads(result[&#34;function_call&#34;][&#34;arguments&#34;])
        output[&#34;response&#34;] = self._clean_command_response(json_result, node_list)
        return output

    def _get_filter(self, user_input, chat_history = None):
        #Send the request to identify the filter and other attributes from the user input to GPT.
        message = []
        message.append({&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: dedent(self.__prompt[&#34;original_system&#34;]).strip()})
        message.append({&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: dedent(self.__prompt[&#34;original_user&#34;]).strip()})
        message.append({&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: None, &#34;function_call&#34;: self.__prompt[&#34;original_assistant&#34;]})
        functions = [self.__prompt[&#34;original_function&#34;]]
        if not chat_history:
            chat_history = []
        chat_history.append({&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: user_input})
        message.extend(chat_history)
        response = openai.ChatCompletion.create(
            model=self.model,
            messages=message,
            functions=functions,
            function_call=&#34;auto&#34;,
            temperature=self.temp,
            top_p=1
            )

        def extract_quoted_strings(text):
            pattern = r&#39;[&#34;\&#39;](.*?)[&#34;\&#39;]&#39;
            matches = re.findall(pattern, text)
            return matches
        expected = extract_quoted_strings(user_input)
        output = {}
        result = response[&#34;choices&#34;][0][&#34;message&#34;].to_dict()
        if result[&#34;content&#34;]:
            output[&#34;app_related&#34;] = False
            chat_history.append({&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: result[&#34;content&#34;]})
            output[&#34;response&#34;] = result[&#34;content&#34;]
        else:
            json_result = json.loads(result[&#34;function_call&#34;][&#34;arguments&#34;])
            output[&#34;app_related&#34;] = True
            output[&#34;filter&#34;] = json_result[&#34;filter&#34;]
            output[&#34;type&#34;] = json_result[&#34;type&#34;]
            chat_history.append({&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: result[&#34;content&#34;], &#34;function_call&#34;: {&#34;name&#34;: result[&#34;function_call&#34;][&#34;name&#34;], &#34;arguments&#34;: json.dumps(json_result)}})
        output[&#34;expected&#34;] = expected
        output[&#34;chat_history&#34;] = chat_history
        return output
        
    def _get_confirmation(self, user_input):
        #Send the request to identify if user is confirming or denying the task
        message = []
        message.append({&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: user_input})
        functions = [self.__prompt[&#34;confirmation_function&#34;]]
        response = openai.ChatCompletion.create(
            model=self.model,
            messages=message,
            functions=functions,
            function_call={&#34;name&#34;: &#34;get_confirmation&#34;},
            temperature=self.temp,
            top_p=1
            )
        result = response[&#34;choices&#34;][0][&#34;message&#34;].to_dict()
        json_result = json.loads(result[&#34;function_call&#34;][&#34;arguments&#34;])
        output = {}
        if json_result[&#34;result&#34;] == &#34;true&#34;:
            output[&#34;result&#34;] = True
        elif json_result[&#34;result&#34;] == &#34;false&#34;:
            output[&#34;result&#34;] = False
        elif json_result[&#34;result&#34;] == &#34;none&#34;:
            output[&#34;result&#34;] = json_result[&#34;response&#34;]
        return output

    def confirm(self, user_input, max_retries=3, backoff_num=1):
        &#39;&#39;&#39;
        Send the user input to openAI GPT and verify if response is afirmative or negative.

        ### Parameters:  

            - user_input (str): User response confirming or denying.

        ### Optional Parameters:  

            - max_retries (int): Maximum number of retries for gpt api.
            - backoff_num (int): Backoff factor for exponential wait time
                                 between retries.

        ### Returns:  

            bool or str: True, False or str if AI coudn&#39;t understand the response
        &#39;&#39;&#39;
        result = self._retry_function(self._get_confirmation, max_retries, backoff_num, user_input)
        if result:
            output = result[&#34;result&#34;]
        else:
            output = f&#34;{self.model} api is not responding right now, please try again later.&#34;
        return output

    def ask(self, user_input, dryrun = False, chat_history = None,  max_retries=3, backoff_num=1):
        &#39;&#39;&#39;
        Send the user input to openAI GPT and parse the response to run an action in the application.

        ### Parameters:  

            - user_input (str): Request to send to openAI that will be parsed
                                and returned to execute on the application.
                                AI understands the following tasks:
                                - Run a command on a group of devices.
                                - List a group of devices.
                                - Test a command on a group of devices
                                  and verify if the output contain an
                                  expected value.

        ### Optional Parameters:  

            - dryrun       (bool): Set to true to get the arguments to use to
                                   run in the app. Default is false and it
                                   will run the actions directly.
            - chat_history (list): List in gpt api format for the chat history.
            - max_retries   (int): Maximum number of retries for gpt api.
            - backoff_num   (int): Backoff factor for exponential wait time
                                   between retries.

        ### Returns:  

            dict: Dictionary formed with the following keys:
                  - input: User input received
                  - app_related: True if GPT detected the request to be related
                    to the application.
                  - dryrun: True/False
                  - response: If the request is not related to the app. this
                    key will contain chatGPT answer.
                  - action: The action detected by the AI to run in the app.
                  - filter: If it was detected by the AI, the filter used
                    to get the list of nodes to work on.
                  - nodes: If it&#39;s not a dryrun, the list of nodes matched by
                    the filter.
                  - args: A dictionary of arguments required to run command(s)
                    on the nodes.
                  - result: A dictionary with the output of the commands or 
                    the test.
                  - chat_history: The chat history between user and chatbot.
                    It can be used as an attribute for next request.
                
                    

        &#39;&#39;&#39;
        output = {}
        output[&#34;dryrun&#34;] = dryrun
        output[&#34;input&#34;] = user_input
        original = self._retry_function(self._get_filter, max_retries, backoff_num, user_input, chat_history)
        if not original:
            output[&#34;app_related&#34;] = False
            output[&#34;response&#34;] = f&#34;{self.model} api is not responding right now, please try again later.&#34;
            return output
        output[&#34;app_related&#34;] = original[&#34;app_related&#34;]
        output[&#34;chat_history&#34;] = original[&#34;chat_history&#34;]
        if not output[&#34;app_related&#34;]:
            output[&#34;response&#34;] = original[&#34;response&#34;]
        else:
            type = original[&#34;type&#34;]
            if &#34;filter&#34; in original:
                output[&#34;filter&#34;] = original[&#34;filter&#34;]
                if not self.config.config[&#34;case&#34;]:
                    if isinstance(output[&#34;filter&#34;], list):
                        output[&#34;filter&#34;] = [item.lower() for item in output[&#34;filter&#34;]]
                    else:
                        output[&#34;filter&#34;] = output[&#34;filter&#34;].lower()
                if not dryrun or type == &#34;command&#34;:
                    thisnodes = self.config._getallnodesfull(output[&#34;filter&#34;])
                    output[&#34;nodes&#34;] = list(thisnodes.keys())
            if not type == &#34;command&#34;:
                output[&#34;action&#34;] = &#34;list_nodes&#34;
            else:
                if thisnodes:
                    commands = self._retry_function(self._get_commands, max_retries, backoff_num, user_input, thisnodes)
                else:
                    output[&#34;app_related&#34;] = False
                    filterlist = &#34;, &#34;.join(output[&#34;filter&#34;])
                    output[&#34;response&#34;] = f&#34;I&#39;m sorry, I coudn&#39;t find any device with filter{&#39;s&#39; if len(output[&#39;filter&#39;]) != 1 else &#39;&#39;}: {filterlist}.&#34;
                    return output
                if not commands:
                    output[&#34;app_related&#34;] = False
                    output[&#34;response&#34;] = f&#34;{self.model} api is not responding right now, please try again later.&#34;
                    return output
                output[&#34;args&#34;] = {}
                output[&#34;args&#34;][&#34;commands&#34;] = commands[&#34;response&#34;][&#34;commands&#34;]
                output[&#34;args&#34;][&#34;vars&#34;] = commands[&#34;response&#34;][&#34;variables&#34;]
                output[&#34;nodes&#34;] = [item for item in output[&#34;nodes&#34;] if output[&#34;args&#34;][&#34;vars&#34;].get(item)]
                if original.get(&#34;expected&#34;):
                    output[&#34;args&#34;][&#34;expected&#34;] = original[&#34;expected&#34;]
                    output[&#34;action&#34;] = &#34;test&#34;
                else:
                    output[&#34;action&#34;] = &#34;run&#34;
                if dryrun:
                    output[&#34;task&#34;] = []
                    if output[&#34;action&#34;] == &#34;test&#34;:
                        output[&#34;task&#34;].append({&#34;Task&#34;: &#34;Verify if expected value is in command(s) output&#34;})
                        output[&#34;task&#34;].append({&#34;Expected value to verify&#34;: output[&#34;args&#34;][&#34;expected&#34;]})
                    elif output[&#34;action&#34;] == &#34;run&#34;:
                        output[&#34;task&#34;].append({&#34;Task&#34;: &#34;Run command(s) on devices and return output&#34;})
                    varstocommands = deepcopy(output[&#34;args&#34;][&#34;vars&#34;])
                    del varstocommands[&#34;__global__&#34;]
                    output[&#34;task&#34;].append({&#34;Devices&#34;: varstocommands})
                if not dryrun:
                    mynodes = nodes(self.config.getitems(output[&#34;nodes&#34;]),config=self.config)
                    if output[&#34;action&#34;] == &#34;test&#34;:
                        output[&#34;result&#34;] = mynodes.test(**output[&#34;args&#34;])
                        output[&#34;logs&#34;] = mynodes.output
                    elif output[&#34;action&#34;] == &#34;run&#34;:
                        output[&#34;result&#34;] = mynodes.run(**output[&#34;args&#34;])
        return output</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="connpy.ai.ask"><code class="name flex">
<span>def <span class="ident">ask</span></span>(<span>self, user_input, dryrun=False, chat_history=None, max_retries=3, backoff_num=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Send the user input to openAI GPT and parse the response to run an action in the application.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- user_input (str): Request to send to openAI that will be parsed
                    and returned to execute on the application.
                    AI understands the following tasks:
                    - Run a command on a group of devices.
                    - List a group of devices.
                    - Test a command on a group of devices
                      and verify if the output contain an
                      expected value.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- dryrun       (bool): Set to true to get the arguments to use to
                       run in the app. Default is false and it
                       will run the actions directly.
- chat_history (list): List in gpt api format for the chat history.
- max_retries   (int): Maximum number of retries for gpt api.
- backoff_num   (int): Backoff factor for exponential wait time
                       between retries.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>dict: Dictionary formed with the following keys:
      - input: User input received
      - app_related: True if GPT detected the request to be related
        to the application.
      - dryrun: True/False
      - response: If the request is not related to the app. this
        key will contain chatGPT answer.
      - action: The action detected by the AI to run in the app.
      - filter: If it was detected by the AI, the filter used
        to get the list of nodes to work on.
      - nodes: If it's not a dryrun, the list of nodes matched by
        the filter.
      - args: A dictionary of arguments required to run command(s)
        on the nodes.
      - result: A dictionary with the output of the commands or 
        the test.
      - chat_history: The chat history between user and chatbot.
        It can be used as an attribute for next request.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ask(self, user_input, dryrun = False, chat_history = None,  max_retries=3, backoff_num=1):
    &#39;&#39;&#39;
    Send the user input to openAI GPT and parse the response to run an action in the application.

    ### Parameters:  

        - user_input (str): Request to send to openAI that will be parsed
                            and returned to execute on the application.
                            AI understands the following tasks:
                            - Run a command on a group of devices.
                            - List a group of devices.
                            - Test a command on a group of devices
                              and verify if the output contain an
                              expected value.

    ### Optional Parameters:  

        - dryrun       (bool): Set to true to get the arguments to use to
                               run in the app. Default is false and it
                               will run the actions directly.
        - chat_history (list): List in gpt api format for the chat history.
        - max_retries   (int): Maximum number of retries for gpt api.
        - backoff_num   (int): Backoff factor for exponential wait time
                               between retries.

    ### Returns:  

        dict: Dictionary formed with the following keys:
              - input: User input received
              - app_related: True if GPT detected the request to be related
                to the application.
              - dryrun: True/False
              - response: If the request is not related to the app. this
                key will contain chatGPT answer.
              - action: The action detected by the AI to run in the app.
              - filter: If it was detected by the AI, the filter used
                to get the list of nodes to work on.
              - nodes: If it&#39;s not a dryrun, the list of nodes matched by
                the filter.
              - args: A dictionary of arguments required to run command(s)
                on the nodes.
              - result: A dictionary with the output of the commands or 
                the test.
              - chat_history: The chat history between user and chatbot.
                It can be used as an attribute for next request.
            
                

    &#39;&#39;&#39;
    output = {}
    output[&#34;dryrun&#34;] = dryrun
    output[&#34;input&#34;] = user_input
    original = self._retry_function(self._get_filter, max_retries, backoff_num, user_input, chat_history)
    if not original:
        output[&#34;app_related&#34;] = False
        output[&#34;response&#34;] = f&#34;{self.model} api is not responding right now, please try again later.&#34;
        return output
    output[&#34;app_related&#34;] = original[&#34;app_related&#34;]
    output[&#34;chat_history&#34;] = original[&#34;chat_history&#34;]
    if not output[&#34;app_related&#34;]:
        output[&#34;response&#34;] = original[&#34;response&#34;]
    else:
        type = original[&#34;type&#34;]
        if &#34;filter&#34; in original:
            output[&#34;filter&#34;] = original[&#34;filter&#34;]
            if not self.config.config[&#34;case&#34;]:
                if isinstance(output[&#34;filter&#34;], list):
                    output[&#34;filter&#34;] = [item.lower() for item in output[&#34;filter&#34;]]
                else:
                    output[&#34;filter&#34;] = output[&#34;filter&#34;].lower()
            if not dryrun or type == &#34;command&#34;:
                thisnodes = self.config._getallnodesfull(output[&#34;filter&#34;])
                output[&#34;nodes&#34;] = list(thisnodes.keys())
        if not type == &#34;command&#34;:
            output[&#34;action&#34;] = &#34;list_nodes&#34;
        else:
            if thisnodes:
                commands = self._retry_function(self._get_commands, max_retries, backoff_num, user_input, thisnodes)
            else:
                output[&#34;app_related&#34;] = False
                filterlist = &#34;, &#34;.join(output[&#34;filter&#34;])
                output[&#34;response&#34;] = f&#34;I&#39;m sorry, I coudn&#39;t find any device with filter{&#39;s&#39; if len(output[&#39;filter&#39;]) != 1 else &#39;&#39;}: {filterlist}.&#34;
                return output
            if not commands:
                output[&#34;app_related&#34;] = False
                output[&#34;response&#34;] = f&#34;{self.model} api is not responding right now, please try again later.&#34;
                return output
            output[&#34;args&#34;] = {}
            output[&#34;args&#34;][&#34;commands&#34;] = commands[&#34;response&#34;][&#34;commands&#34;]
            output[&#34;args&#34;][&#34;vars&#34;] = commands[&#34;response&#34;][&#34;variables&#34;]
            output[&#34;nodes&#34;] = [item for item in output[&#34;nodes&#34;] if output[&#34;args&#34;][&#34;vars&#34;].get(item)]
            if original.get(&#34;expected&#34;):
                output[&#34;args&#34;][&#34;expected&#34;] = original[&#34;expected&#34;]
                output[&#34;action&#34;] = &#34;test&#34;
            else:
                output[&#34;action&#34;] = &#34;run&#34;
            if dryrun:
                output[&#34;task&#34;] = []
                if output[&#34;action&#34;] == &#34;test&#34;:
                    output[&#34;task&#34;].append({&#34;Task&#34;: &#34;Verify if expected value is in command(s) output&#34;})
                    output[&#34;task&#34;].append({&#34;Expected value to verify&#34;: output[&#34;args&#34;][&#34;expected&#34;]})
                elif output[&#34;action&#34;] == &#34;run&#34;:
                    output[&#34;task&#34;].append({&#34;Task&#34;: &#34;Run command(s) on devices and return output&#34;})
                varstocommands = deepcopy(output[&#34;args&#34;][&#34;vars&#34;])
                del varstocommands[&#34;__global__&#34;]
                output[&#34;task&#34;].append({&#34;Devices&#34;: varstocommands})
            if not dryrun:
                mynodes = nodes(self.config.getitems(output[&#34;nodes&#34;]),config=self.config)
                if output[&#34;action&#34;] == &#34;test&#34;:
                    output[&#34;result&#34;] = mynodes.test(**output[&#34;args&#34;])
                    output[&#34;logs&#34;] = mynodes.output
                elif output[&#34;action&#34;] == &#34;run&#34;:
                    output[&#34;result&#34;] = mynodes.run(**output[&#34;args&#34;])
    return output</code></pre>
</details>
</dd>
<dt id="connpy.ai.confirm"><code class="name flex">
<span>def <span class="ident">confirm</span></span>(<span>self, user_input, max_retries=3, backoff_num=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Send the user input to openAI GPT and verify if response is afirmative or negative.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- user_input (str): User response confirming or denying.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- max_retries (int): Maximum number of retries for gpt api.
- backoff_num (int): Backoff factor for exponential wait time
                     between retries.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>bool or str: True, False or str if AI coudn't understand the response
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def confirm(self, user_input, max_retries=3, backoff_num=1):
    &#39;&#39;&#39;
    Send the user input to openAI GPT and verify if response is afirmative or negative.

    ### Parameters:  

        - user_input (str): User response confirming or denying.

    ### Optional Parameters:  

        - max_retries (int): Maximum number of retries for gpt api.
        - backoff_num (int): Backoff factor for exponential wait time
                             between retries.

    ### Returns:  

        bool or str: True, False or str if AI coudn&#39;t understand the response
    &#39;&#39;&#39;
    result = self._retry_function(self._get_confirmation, max_retries, backoff_num, user_input)
    if result:
        output = result[&#34;result&#34;]
    else:
        output = f&#34;{self.model} api is not responding right now, please try again later.&#34;
    return output</code></pre>
</details>
</dd>
<dt id="connpy.ai.process_string"><code class="name flex">
<span>def <span class="ident">process_string</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_string(self, s):
    if s.startswith(&#39;[&#39;) and s.endswith(&#39;]&#39;) and not (s.startswith(&#34;[&#39;&#34;) and s.endswith(&#34;&#39;]&#34;)) and not (s.startswith(&#39;[&#34;&#39;) and s.endswith(&#39;&#34;]&#39;)):
        # Extract the content inside square brackets and split by comma
        content = s[1:-1].split(&#39;,&#39;)
        # Add single quotes around each item and join them back together with commas
        new_content = &#39;, &#39;.join(f&#34;&#39;{item.strip()}&#39;&#34; for item in content)
        # Replace the old content with the new content
        s = &#39;[&#39; + new_content + &#39;]&#39;
    return s</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="connpy.configfile"><code class="flex name class">
<span>class <span class="ident">configfile</span></span>
<span>(</span><span>conf=None, key=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class generates a configfile object. Containts a dictionary storing, config, nodes and profiles, normaly used by connection manager.</p>
<h3 id="attributes">Attributes:</h3>
<pre><code>- file         (str): Path/file to config file.

- key          (str): Path/file to RSA key file.

- config      (dict): Dictionary containing information of connection
                      manager configuration.

- connections (dict): Dictionary containing all the nodes added to
                      connection manager.

- profiles    (dict): Dictionary containing all the profiles added to
                      connection manager.

- privatekey   (obj): Object containing the private key to encrypt 
                      passwords.

- publickey    (obj): Object containing the public key to decrypt 
                      passwords.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- conf (str): Path/file to config file. If left empty default
              path is ~/.config/conn/config.json

- key  (str): Path/file to RSA key file. If left empty default
              path is ~/.config/conn/.osk
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class configfile:
    &#39;&#39;&#39; This class generates a configfile object. Containts a dictionary storing, config, nodes and profiles, normaly used by connection manager.

    ### Attributes:  

        - file         (str): Path/file to config file.

        - key          (str): Path/file to RSA key file.

        - config      (dict): Dictionary containing information of connection
                              manager configuration.

        - connections (dict): Dictionary containing all the nodes added to
                              connection manager.

        - profiles    (dict): Dictionary containing all the profiles added to
                              connection manager.

        - privatekey   (obj): Object containing the private key to encrypt 
                              passwords.

        - publickey    (obj): Object containing the public key to decrypt 
                              passwords.
        &#39;&#39;&#39;

    def __init__(self, conf = None, key = None):
        &#39;&#39;&#39; 
            
        ### Optional Parameters:  

            - conf (str): Path/file to config file. If left empty default
                          path is ~/.config/conn/config.json

            - key  (str): Path/file to RSA key file. If left empty default
                          path is ~/.config/conn/.osk

        &#39;&#39;&#39;
        home = os.path.expanduser(&#34;~&#34;)
        defaultdir = home + &#39;/.config/conn&#39;
        self.defaultdir = defaultdir
        Path(defaultdir).mkdir(parents=True, exist_ok=True)
        Path(f&#34;{defaultdir}/plugins&#34;).mkdir(parents=True, exist_ok=True)
        pathfile = defaultdir + &#39;/.folder&#39;
        try:
            with open(pathfile, &#34;r&#34;) as f:
                configdir = f.read().strip()
        except:
            with open(pathfile, &#34;w&#34;) as f:
                f.write(str(defaultdir))
            configdir = defaultdir
        defaultfile = configdir + &#39;/config.json&#39;
        defaultkey = configdir + &#39;/.osk&#39;
        if conf == None:
            self.file = defaultfile
        else:
            self.file = conf
        if key == None:
            self.key = defaultkey
        else:
            self.key = key
        if os.path.exists(self.file):
            config = self._loadconfig(self.file)
        else:
            config = self._createconfig(self.file)
        self.config = config[&#34;config&#34;]
        self.connections = config[&#34;connections&#34;]
        self.profiles = config[&#34;profiles&#34;]
        if not os.path.exists(self.key):
            self._createkey(self.key)
        with open(self.key) as f:
            self.privatekey = RSA.import_key(f.read())
            f.close()
        self.publickey = self.privatekey.publickey()


    def _loadconfig(self, conf):
        #Loads config file
        jsonconf = open(conf)
        jsondata = json.load(jsonconf)
        jsonconf.close()
        return jsondata

    def _createconfig(self, conf):
        #Create config file
        defaultconfig = {&#39;config&#39;: {&#39;case&#39;: False, &#39;idletime&#39;: 30, &#39;fzf&#39;: False}, &#39;connections&#39;: {}, &#39;profiles&#39;: { &#34;default&#34;: { &#34;host&#34;:&#34;&#34;, &#34;protocol&#34;:&#34;ssh&#34;, &#34;port&#34;:&#34;&#34;, &#34;user&#34;:&#34;&#34;, &#34;password&#34;:&#34;&#34;, &#34;options&#34;:&#34;&#34;, &#34;logs&#34;:&#34;&#34;, &#34;tags&#34;: &#34;&#34;, &#34;jumphost&#34;:&#34;&#34;}}}
        if not os.path.exists(conf):
            with open(conf, &#34;w&#34;) as f:
                json.dump(defaultconfig, f, indent = 4)
                f.close()
                os.chmod(conf, 0o600)
        jsonconf = open(conf)
        jsondata = json.load(jsonconf)
        jsonconf.close()
        return jsondata

    def _saveconfig(self, conf):
        #Save config file
        newconfig = {&#34;config&#34;:{}, &#34;connections&#34;: {}, &#34;profiles&#34;: {}}
        newconfig[&#34;config&#34;] = self.config
        newconfig[&#34;connections&#34;] = self.connections
        newconfig[&#34;profiles&#34;] = self.profiles
        with open(conf, &#34;w&#34;) as f:
            json.dump(newconfig, f, indent = 4)
            f.close()

    def _createkey(self, keyfile):
        #Create key file
        key = RSA.generate(2048)
        with open(keyfile,&#39;wb&#39;) as f:
            f.write(key.export_key(&#39;PEM&#39;))
            f.close()
            os.chmod(keyfile, 0o600)
        return key

    def _explode_unique(self, unique):
        #Divide unique name into folder, subfolder and id
        uniques = unique.split(&#34;@&#34;)
        if not unique.startswith(&#34;@&#34;):
            result = {&#34;id&#34;: uniques[0]}
        else:
            result = {}
        if len(uniques) == 2:
            result[&#34;folder&#34;] = uniques[1]
            if result[&#34;folder&#34;] == &#34;&#34;:
                return False
        elif len(uniques) == 3:
            result[&#34;folder&#34;] = uniques[2]
            result[&#34;subfolder&#34;] = uniques[1]
            if result[&#34;folder&#34;] == &#34;&#34; or result[&#34;subfolder&#34;] == &#34;&#34;:
                return False
        elif len(uniques) &gt; 3:
            return False
        return result

    def getitem(self, unique, keys = None):
        &#39;&#39;&#39;
        Get an node or a group of nodes from configfile which can be passed to node/nodes class

        ### Parameters:  

            - unique (str): Unique name of the node or folder in config using
                            connection manager style: node[@subfolder][@folder]
                            or [@subfolder]@folder

        ### Optional Parameters:  

            - keys (list): In case you pass a folder as unique, you can filter
                           nodes inside the folder passing a list.

        ### Returns:  

            dict: Dictionary containing information of node or multiple 
                  dictionaries of multiple nodes.

        &#39;&#39;&#39;
        uniques = self._explode_unique(unique)
        if unique.startswith(&#34;@&#34;):
            if uniques.keys() &gt;= {&#34;folder&#34;, &#34;subfolder&#34;}:
                folder = self.connections[uniques[&#34;folder&#34;]][uniques[&#34;subfolder&#34;]]
            else:
                folder = self.connections[uniques[&#34;folder&#34;]]
            newfolder = deepcopy(folder)
            newfolder.pop(&#34;type&#34;)
            for node in folder.keys():
                if node == &#34;type&#34;:
                    continue
                if &#34;type&#34; in newfolder[node].keys():
                    if newfolder[node][&#34;type&#34;] == &#34;subfolder&#34;:
                        newfolder.pop(node)
                    else:
                        newfolder[node].pop(&#34;type&#34;)
            if keys == None:
                newfolder = {&#34;{}{}&#34;.format(k,unique):v for k,v in newfolder.items()}
                return newfolder
            else:
                f_newfolder = dict((k, newfolder[k]) for k in keys)
                f_newfolder = {&#34;{}{}&#34;.format(k,unique):v for k,v in f_newfolder.items()}
                return f_newfolder
        else:
            if uniques.keys() &gt;= {&#34;folder&#34;, &#34;subfolder&#34;}:
                node = self.connections[uniques[&#34;folder&#34;]][uniques[&#34;subfolder&#34;]][uniques[&#34;id&#34;]]
            elif &#34;folder&#34; in uniques.keys():
                node = self.connections[uniques[&#34;folder&#34;]][uniques[&#34;id&#34;]]
            else:
                node = self.connections[uniques[&#34;id&#34;]]
            newnode = deepcopy(node)
            newnode.pop(&#34;type&#34;)
            return newnode

    def getitems(self, uniques):
        &#39;&#39;&#39;
        Get a group of nodes from configfile which can be passed to node/nodes class

        ### Parameters:  

            - uniques (str/list): String name that will match hostnames 
                                  from the connection manager. It can be a 
                                  list of strings.

        ### Returns:  

            dict: Dictionary containing information of node or multiple 
                  dictionaries of multiple nodes.

        &#39;&#39;&#39;
        nodes = {}
        if isinstance(uniques, str):
            uniques = [uniques]
        for i in uniques:
            if isinstance(i, dict):
                name = list(i.keys())[0]
                mylist = i[name]
                if not self.config[&#34;case&#34;]:
                    name = name.lower()
                    mylist = [item.lower() for item in mylist]
                this = self.getitem(name, mylist)
                nodes.update(this)
            elif i.startswith(&#34;@&#34;):
                if not self.config[&#34;case&#34;]:
                    i = i.lower()
                this = self.getitem(i)
                nodes.update(this)
            else:
                if not self.config[&#34;case&#34;]:
                    i = i.lower()
                this = self.getitem(i)
                nodes[i] = this
        return nodes


    def _connections_add(self,*, id, host, folder=&#39;&#39;, subfolder=&#39;&#39;, options=&#39;&#39;, logs=&#39;&#39;, password=&#39;&#39;, port=&#39;&#39;, protocol=&#39;&#39;, user=&#39;&#39;, tags=&#39;&#39;, jumphost=&#39;&#39;, type = &#34;connection&#34; ):
        #Add connection from config
        if folder == &#39;&#39;:
            self.connections[id] = {&#34;host&#34;: host, &#34;options&#34;: options, &#34;logs&#34;: logs, &#34;password&#34;: password, &#34;port&#34;: port, &#34;protocol&#34;: protocol, &#34;user&#34;: user, &#34;tags&#34;: tags,&#34;jumphost&#34;: jumphost,&#34;type&#34;: type}
        elif folder != &#39;&#39; and subfolder == &#39;&#39;:
            self.connections[folder][id] = {&#34;host&#34;: host, &#34;options&#34;: options, &#34;logs&#34;: logs, &#34;password&#34;: password, &#34;port&#34;: port, &#34;protocol&#34;: protocol, &#34;user&#34;: user, &#34;tags&#34;: tags, &#34;jumphost&#34;: jumphost, &#34;type&#34;: type}
        elif folder != &#39;&#39; and subfolder != &#39;&#39;:
            self.connections[folder][subfolder][id] = {&#34;host&#34;: host, &#34;options&#34;: options, &#34;logs&#34;: logs, &#34;password&#34;: password, &#34;port&#34;: port, &#34;protocol&#34;: protocol, &#34;user&#34;: user, &#34;tags&#34;: tags,  &#34;jumphost&#34;: jumphost, &#34;type&#34;: type}
            

    def _connections_del(self,*, id, folder=&#39;&#39;, subfolder=&#39;&#39;):
        #Delete connection from config
        if folder == &#39;&#39;:
            del self.connections[id]
        elif folder != &#39;&#39; and subfolder == &#39;&#39;:
            del self.connections[folder][id]
        elif folder != &#39;&#39; and subfolder != &#39;&#39;:
            del self.connections[folder][subfolder][id]

    def _folder_add(self,*, folder, subfolder = &#39;&#39;):
        #Add Folder from config
        if subfolder == &#39;&#39;:
            if folder not in self.connections:
                self.connections[folder] = {&#34;type&#34;: &#34;folder&#34;}
        else:
            if subfolder not in self.connections[folder]:
                self.connections[folder][subfolder] = {&#34;type&#34;: &#34;subfolder&#34;}

    def _folder_del(self,*, folder, subfolder=&#39;&#39;):
        #Delete folder from config
        if subfolder == &#39;&#39;:
            del self.connections[folder]
        else:
            del self.connections[folder][subfolder]


    def _profiles_add(self,*, id, host = &#39;&#39;, options=&#39;&#39;, logs=&#39;&#39;, password=&#39;&#39;, port=&#39;&#39;, protocol=&#39;&#39;, user=&#39;&#39;, tags=&#39;&#39;, jumphost=&#39;&#39; ):
        #Add profile from config
        self.profiles[id] = {&#34;host&#34;: host, &#34;options&#34;: options, &#34;logs&#34;: logs, &#34;password&#34;: password, &#34;port&#34;: port, &#34;protocol&#34;: protocol, &#34;user&#34;: user, &#34;tags&#34;: tags, &#34;jumphost&#34;: jumphost}
            

    def _profiles_del(self,*, id ):
        #Delete profile from config
        del self.profiles[id]
        
    def _getallnodes(self, filter = None):
        #get all nodes on configfile
        nodes = []
        layer1 = [k for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34;]
        folders = [k for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;folder&#34;]
        nodes.extend(layer1)
        for f in folders:
            layer2 = [k + &#34;@&#34; + f for k,v in self.connections[f].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34;]
            nodes.extend(layer2)
            subfolders = [k for k,v in self.connections[f].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;subfolder&#34;]
            for s in subfolders:
                layer3 = [k + &#34;@&#34; + s + &#34;@&#34; + f for k,v in self.connections[f][s].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34;]
                nodes.extend(layer3)
        if filter:
            if isinstance(filter, str):
                nodes = [item for item in nodes if re.search(filter, item)]
            elif isinstance(filter, list):
                nodes = [item for item in nodes if any(re.search(pattern, item) for pattern in filter)]
            else:
                raise ValueError(&#34;filter must be a string or a list of strings&#34;)
        return nodes

    def _getallnodesfull(self, filter = None, extract = True):
        #get all nodes on configfile with all their attributes.
        nodes = {}
        layer1 = {k:v for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34;}
        folders = [k for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;folder&#34;]
        nodes.update(layer1)
        for f in folders:
            layer2 = {k + &#34;@&#34; + f:v for k,v in self.connections[f].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34;}
            nodes.update(layer2)
            subfolders = [k for k,v in self.connections[f].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;subfolder&#34;]
            for s in subfolders:
                layer3 = {k + &#34;@&#34; + s + &#34;@&#34; + f:v for k,v in self.connections[f][s].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34;}
                nodes.update(layer3)
        if filter:
            if isinstance(filter, str):
                filter = &#34;^(?!.*@).+$&#34; if filter == &#34;@&#34; else filter
                nodes = {k: v for k, v in nodes.items() if re.search(filter, k)}
            elif isinstance(filter, list):
                filter = [&#34;^(?!.*@).+$&#34; if item == &#34;@&#34; else item for item in filter]
                nodes = {k: v for k, v in nodes.items() if any(re.search(pattern, k) for pattern in filter)}
            else:
                raise ValueError(&#34;filter must be a string or a list of strings&#34;)
        if extract:
            for node, keys in nodes.items():
                for key, value in keys.items():
                    profile = re.search(&#34;^@(.*)&#34;, str(value))
                    if profile:
                        try:
                            nodes[node][key] = self.profiles[profile.group(1)][key]
                        except:
                            nodes[node][key] = &#34;&#34;
                    elif value == &#39;&#39; and key == &#34;protocol&#34;:
                        try:
                            nodes[node][key] = config.profiles[&#34;default&#34;][key]
                        except:
                            nodes[node][key] = &#34;ssh&#34;
        return nodes


    def _getallfolders(self):
        #get all folders on configfile
        folders = [&#34;@&#34; + k for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;folder&#34;]
        subfolders = []
        for f in folders:
            s = [&#34;@&#34; + k + f for k,v in self.connections[f[1:]].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;subfolder&#34;]
            subfolders.extend(s)
        folders.extend(subfolders)
        return folders

    def _profileused(self, profile):
        #Check if profile is used before deleting it
        nodes = []
        layer1 = [k for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34; and (&#34;@&#34; + profile in v.values() or ( isinstance(v[&#34;password&#34;],list) and &#34;@&#34; + profile in v[&#34;password&#34;]))]
        folders = [k for k,v in self.connections.items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;folder&#34;]
        nodes.extend(layer1)
        for f in folders:
            layer2 = [k + &#34;@&#34; + f for k,v in self.connections[f].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34; and (&#34;@&#34; + profile in v.values() or ( isinstance(v[&#34;password&#34;],list) and &#34;@&#34; + profile in v[&#34;password&#34;]))]
            nodes.extend(layer2)
            subfolders = [k for k,v in self.connections[f].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;subfolder&#34;]
            for s in subfolders:
                layer3 = [k + &#34;@&#34; + s + &#34;@&#34; + f for k,v in self.connections[f][s].items() if isinstance(v, dict) and v[&#34;type&#34;] == &#34;connection&#34; and (&#34;@&#34; + profile in v.values() or ( isinstance(v[&#34;password&#34;],list) and &#34;@&#34; + profile in v[&#34;password&#34;]))]
                nodes.extend(layer3)
        return nodes</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="connpy.configfile.getitem"><code class="name flex">
<span>def <span class="ident">getitem</span></span>(<span>self, unique, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an node or a group of nodes from configfile which can be passed to node/nodes class</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- unique (str): Unique name of the node or folder in config using
                connection manager style: node[@subfolder][@folder]
                or [@subfolder]@folder
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- keys (list): In case you pass a folder as unique, you can filter
               nodes inside the folder passing a list.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>dict: Dictionary containing information of node or multiple 
      dictionaries of multiple nodes.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getitem(self, unique, keys = None):
    &#39;&#39;&#39;
    Get an node or a group of nodes from configfile which can be passed to node/nodes class

    ### Parameters:  

        - unique (str): Unique name of the node or folder in config using
                        connection manager style: node[@subfolder][@folder]
                        or [@subfolder]@folder

    ### Optional Parameters:  

        - keys (list): In case you pass a folder as unique, you can filter
                       nodes inside the folder passing a list.

    ### Returns:  

        dict: Dictionary containing information of node or multiple 
              dictionaries of multiple nodes.

    &#39;&#39;&#39;
    uniques = self._explode_unique(unique)
    if unique.startswith(&#34;@&#34;):
        if uniques.keys() &gt;= {&#34;folder&#34;, &#34;subfolder&#34;}:
            folder = self.connections[uniques[&#34;folder&#34;]][uniques[&#34;subfolder&#34;]]
        else:
            folder = self.connections[uniques[&#34;folder&#34;]]
        newfolder = deepcopy(folder)
        newfolder.pop(&#34;type&#34;)
        for node in folder.keys():
            if node == &#34;type&#34;:
                continue
            if &#34;type&#34; in newfolder[node].keys():
                if newfolder[node][&#34;type&#34;] == &#34;subfolder&#34;:
                    newfolder.pop(node)
                else:
                    newfolder[node].pop(&#34;type&#34;)
        if keys == None:
            newfolder = {&#34;{}{}&#34;.format(k,unique):v for k,v in newfolder.items()}
            return newfolder
        else:
            f_newfolder = dict((k, newfolder[k]) for k in keys)
            f_newfolder = {&#34;{}{}&#34;.format(k,unique):v for k,v in f_newfolder.items()}
            return f_newfolder
    else:
        if uniques.keys() &gt;= {&#34;folder&#34;, &#34;subfolder&#34;}:
            node = self.connections[uniques[&#34;folder&#34;]][uniques[&#34;subfolder&#34;]][uniques[&#34;id&#34;]]
        elif &#34;folder&#34; in uniques.keys():
            node = self.connections[uniques[&#34;folder&#34;]][uniques[&#34;id&#34;]]
        else:
            node = self.connections[uniques[&#34;id&#34;]]
        newnode = deepcopy(node)
        newnode.pop(&#34;type&#34;)
        return newnode</code></pre>
</details>
</dd>
<dt id="connpy.configfile.getitems"><code class="name flex">
<span>def <span class="ident">getitems</span></span>(<span>self, uniques)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a group of nodes from configfile which can be passed to node/nodes class</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- uniques (str/list): String name that will match hostnames 
                      from the connection manager. It can be a 
                      list of strings.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>dict: Dictionary containing information of node or multiple 
      dictionaries of multiple nodes.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getitems(self, uniques):
    &#39;&#39;&#39;
    Get a group of nodes from configfile which can be passed to node/nodes class

    ### Parameters:  

        - uniques (str/list): String name that will match hostnames 
                              from the connection manager. It can be a 
                              list of strings.

    ### Returns:  

        dict: Dictionary containing information of node or multiple 
              dictionaries of multiple nodes.

    &#39;&#39;&#39;
    nodes = {}
    if isinstance(uniques, str):
        uniques = [uniques]
    for i in uniques:
        if isinstance(i, dict):
            name = list(i.keys())[0]
            mylist = i[name]
            if not self.config[&#34;case&#34;]:
                name = name.lower()
                mylist = [item.lower() for item in mylist]
            this = self.getitem(name, mylist)
            nodes.update(this)
        elif i.startswith(&#34;@&#34;):
            if not self.config[&#34;case&#34;]:
                i = i.lower()
            this = self.getitem(i)
            nodes.update(this)
        else:
            if not self.config[&#34;case&#34;]:
                i = i.lower()
            this = self.getitem(i)
            nodes[i] = this
    return nodes</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="connpy.connapp"><code class="flex name class">
<span>class <span class="ident">connapp</span></span>
<span>(</span><span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>This class starts the connection manager app. It's normally used by connection manager but you can use it on a script to run the connection manager your way and use a different configfile and key.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- config (obj): Object generated with configfile class, it contains
                the nodes configuration and the methods to manage
                the config file.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class connapp:
    &#39;&#39;&#39; This class starts the connection manager app. It&#39;s normally used by connection manager but you can use it on a script to run the connection manager your way and use a different configfile and key.
        &#39;&#39;&#39;

    def __init__(self, config):
        &#39;&#39;&#39; 
            
        ### Parameters:  

            - config (obj): Object generated with configfile class, it contains
                            the nodes configuration and the methods to manage
                            the config file.

        &#39;&#39;&#39;
        self.node = node
        self.connnodes = nodes
        self.config = config
        self.nodes = self.config._getallnodes()
        self.folders = self.config._getallfolders()
        self.profiles = list(self.config.profiles.keys())
        self.case = self.config.config[&#34;case&#34;]
        try:
            self.fzf = self.config.config[&#34;fzf&#34;]
        except:
            self.fzf = False


    def start(self,argv = sys.argv[1:]):
        &#39;&#39;&#39; 
            
        ### Parameters:  

            - argv (list): List of arguments to pass to the app.
                           Default: sys.argv[1:]

        &#39;&#39;&#39; 
        #DEFAULTPARSER
        defaultparser = argparse.ArgumentParser(prog = &#34;conn&#34;, description = &#34;SSH and Telnet connection manager&#34;, formatter_class=argparse.RawTextHelpFormatter)
        subparsers = defaultparser.add_subparsers(title=&#34;Commands&#34;, dest=&#34;subcommand&#34;)
        #NODEPARSER
        nodeparser = subparsers.add_parser(&#34;node&#34;, formatter_class=argparse.RawTextHelpFormatter) 
        nodecrud = nodeparser.add_mutually_exclusive_group()
        nodeparser.add_argument(&#34;node&#34;, metavar=&#34;node|folder&#34;, nargs=&#39;?&#39;, default=None, action=self._store_type, help=self._help(&#34;node&#34;))
        nodecrud.add_argument(&#34;-v&#34;,&#34;--version&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Show version&#34;, const=&#34;version&#34;, default=&#34;connect&#34;)
        nodecrud.add_argument(&#34;-a&#34;,&#34;--add&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Add new node[@subfolder][@folder] or [@subfolder]@folder&#34;, const=&#34;add&#34;, default=&#34;connect&#34;)
        nodecrud.add_argument(&#34;-r&#34;,&#34;--del&#34;, &#34;--rm&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Delete node[@subfolder][@folder] or [@subfolder]@folder&#34;, const=&#34;del&#34;, default=&#34;connect&#34;)
        nodecrud.add_argument(&#34;-e&#34;,&#34;--mod&#34;, &#34;--edit&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Modify node[@subfolder][@folder]&#34;, const=&#34;mod&#34;, default=&#34;connect&#34;)
        nodecrud.add_argument(&#34;-s&#34;,&#34;--show&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Show node[@subfolder][@folder]&#34;, const=&#34;show&#34;, default=&#34;connect&#34;)
        nodecrud.add_argument(&#34;-d&#34;,&#34;--debug&#34;, dest=&#34;debug&#34;, action=&#34;store_true&#34;, help=&#34;Display all conections steps&#34;)
        nodeparser.add_argument(&#34;-t&#34;,&#34;--sftp&#34;, dest=&#34;sftp&#34;, action=&#34;store_true&#34;, help=&#34;Connects using sftp instead of ssh&#34;)
        nodeparser.set_defaults(func=self._func_node)
        #PROFILEPARSER
        profileparser = subparsers.add_parser(&#34;profile&#34;, description=&#34;Manage profiles&#34;) 
        profileparser.add_argument(&#34;profile&#34;, nargs=1, action=self._store_type, type=self._type_profile, help=&#34;Name of profile to manage&#34;)
        profilecrud = profileparser.add_mutually_exclusive_group(required=True)
        profilecrud.add_argument(&#34;-a&#34;, &#34;--add&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Add new profile&#34;, const=&#34;add&#34;)
        profilecrud.add_argument(&#34;-r&#34;, &#34;--del&#34;, &#34;--rm&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Delete profile&#34;, const=&#34;del&#34;)
        profilecrud.add_argument(&#34;-e&#34;, &#34;--mod&#34;, &#34;--edit&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Modify profile&#34;, const=&#34;mod&#34;)
        profilecrud.add_argument(&#34;-s&#34;, &#34;--show&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Show profile&#34;, const=&#34;show&#34;)
        profileparser.set_defaults(func=self._func_profile)
        #MOVEPARSER
        moveparser = subparsers.add_parser(&#34;move&#34;, aliases=[&#34;mv&#34;], description=&#34;Move node&#34;) 
        moveparser.add_argument(&#34;move&#34;, nargs=2, action=self._store_type, help=&#34;Move node[@subfolder][@folder] dest_node[@subfolder][@folder]&#34;, default=&#34;move&#34;, type=self._type_node)
        moveparser.set_defaults(func=self._func_others)
        #COPYPARSER
        copyparser = subparsers.add_parser(&#34;copy&#34;, aliases=[&#34;cp&#34;], description=&#34;Copy node&#34;) 
        copyparser.add_argument(&#34;cp&#34;, nargs=2, action=self._store_type, help=&#34;Copy node[@subfolder][@folder] new_node[@subfolder][@folder]&#34;, default=&#34;cp&#34;, type=self._type_node)
        copyparser.set_defaults(func=self._func_others)
        #LISTPARSER
        lsparser = subparsers.add_parser(&#34;list&#34;, aliases=[&#34;ls&#34;], description=&#34;List profiles, nodes or folders&#34;) 
        lsparser.add_argument(&#34;ls&#34;, action=self._store_type, choices=[&#34;profiles&#34;,&#34;nodes&#34;,&#34;folders&#34;], help=&#34;List profiles, nodes or folders&#34;, default=False)
        lsparser.add_argument(&#34;--filter&#34;, nargs=1, help=&#34;Filter results&#34;)
        lsparser.add_argument(&#34;--format&#34;, nargs=1, help=&#34;Format of the output of nodes using {name}, {NAME}, {location}, {LOCATION}, {host} and {HOST}&#34;)
        lsparser.set_defaults(func=self._func_others)
        #BULKPARSER
        bulkparser = subparsers.add_parser(&#34;bulk&#34;, description=&#34;Add nodes in bulk&#34;) 
        bulkparser.add_argument(&#34;bulk&#34;, const=&#34;bulk&#34;, nargs=0, action=self._store_type, help=&#34;Add nodes in bulk&#34;)
        bulkparser.set_defaults(func=self._func_others)
        # EXPORTPARSER
        exportparser = subparsers.add_parser(&#34;export&#34;, description=&#34;Export connection folder to Yaml file&#34;) 
        exportparser.add_argument(&#34;export&#34;, nargs=&#34;+&#34;, action=self._store_type, help=&#34;Export /path/to/file.yml [@subfolder1][@folder1] [@subfolderN][@folderN]&#34;)
        exportparser.set_defaults(func=self._func_export)
        # IMPORTPARSER
        importparser = subparsers.add_parser(&#34;import&#34;, description=&#34;Import connection folder to config from Yaml file&#34;) 
        importparser.add_argument(&#34;file&#34;, nargs=1, action=self._store_type, help=&#34;Import /path/to/file.yml&#34;)
        importparser.set_defaults(func=self._func_import)
        # AIPARSER
        aiparser = subparsers.add_parser(&#34;ai&#34;, description=&#34;Make request to an AI&#34;) 
        aiparser.add_argument(&#34;ask&#34;, nargs=&#39;*&#39;, help=&#34;Ask connpy AI something&#34;)
        aiparser.add_argument(&#34;--model&#34;, nargs=1, help=&#34;Set the OPENAI model id&#34;)
        aiparser.add_argument(&#34;--org&#34;, nargs=1, help=&#34;Set the OPENAI organization id&#34;)
        aiparser.add_argument(&#34;--api_key&#34;, nargs=1, help=&#34;Set the OPENAI API key&#34;)
        aiparser.set_defaults(func=self._func_ai)
        #RUNPARSER
        runparser = subparsers.add_parser(&#34;run&#34;, description=&#34;Run scripts or commands on nodes&#34;, formatter_class=argparse.RawTextHelpFormatter) 
        runparser.add_argument(&#34;run&#34;, nargs=&#39;+&#39;, action=self._store_type, help=self._help(&#34;run&#34;), default=&#34;run&#34;)
        runparser.add_argument(&#34;-g&#34;,&#34;--generate&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Generate yaml file template&#34;, const=&#34;generate&#34;, default=&#34;run&#34;)
        runparser.set_defaults(func=self._func_run)
        #APIPARSER
        apiparser = subparsers.add_parser(&#34;api&#34;, description=&#34;Start and stop connpy api&#34;) 
        apicrud = apiparser.add_mutually_exclusive_group(required=True)
        apicrud.add_argument(&#34;-s&#34;,&#34;--start&#34;, dest=&#34;start&#34;, nargs=&#34;?&#34;, action=self._store_type, help=&#34;Start conppy api&#34;, type=int, default=8048, metavar=&#34;PORT&#34;)
        apicrud.add_argument(&#34;-r&#34;,&#34;--restart&#34;, dest=&#34;restart&#34;, nargs=0, action=self._store_type, help=&#34;Restart conppy api&#34;)
        apicrud.add_argument(&#34;-x&#34;,&#34;--stop&#34;, dest=&#34;stop&#34;, nargs=0, action=self._store_type, help=&#34;Stop conppy api&#34;)
        apicrud.add_argument(&#34;-d&#34;, &#34;--debug&#34;, dest=&#34;debug&#34;, nargs=&#34;?&#34;, action=self._store_type, help=&#34;Run connpy server on debug mode&#34;, type=int, default=8048, metavar=&#34;PORT&#34;)
        apiparser.set_defaults(func=self._func_api)
        #PLUGINSPARSER
        pluginparser = subparsers.add_parser(&#34;plugin&#34;, description=&#34;Manage plugins&#34;) 
        plugincrud = pluginparser.add_mutually_exclusive_group(required=True)
        plugincrud.add_argument(&#34;--add&#34;, metavar=(&#34;PLUGIN&#34;, &#34;FILE&#34;), nargs=2, help=&#34;Add new plugin&#34;)
        plugincrud.add_argument(&#34;--del&#34;, dest=&#34;delete&#34;, metavar=&#34;PLUGIN&#34;, nargs=1, help=&#34;Delete plugin&#34;)
        plugincrud.add_argument(&#34;--enable&#34;, metavar=&#34;PLUGIN&#34;, nargs=1, help=&#34;Enable plugin&#34;)
        plugincrud.add_argument(&#34;--disable&#34;, metavar=&#34;PLUGIN&#34;, nargs=1, help=&#34;Disable plugin&#34;)
        plugincrud.add_argument(&#34;--list&#34;, dest=&#34;list&#34;, action=&#34;store_true&#34;, help=&#34;Disable plugin&#34;)
        pluginparser.set_defaults(func=self._func_plugin)
        #CONFIGPARSER
        configparser = subparsers.add_parser(&#34;config&#34;, description=&#34;Manage app config&#34;) 
        configcrud = configparser.add_mutually_exclusive_group(required=True)
        configcrud.add_argument(&#34;--allow-uppercase&#34;, dest=&#34;case&#34;, nargs=1, action=self._store_type, help=&#34;Allow case sensitive names&#34;, choices=[&#34;true&#34;,&#34;false&#34;])
        configcrud.add_argument(&#34;--fzf&#34;, dest=&#34;fzf&#34;, nargs=1, action=self._store_type, help=&#34;Use fzf for lists&#34;, choices=[&#34;true&#34;,&#34;false&#34;])
        configcrud.add_argument(&#34;--keepalive&#34;, dest=&#34;idletime&#34;, nargs=1, action=self._store_type, help=&#34;Set keepalive time in seconds, 0 to disable&#34;, type=int, metavar=&#34;INT&#34;)
        configcrud.add_argument(&#34;--completion&#34;, dest=&#34;completion&#34;, nargs=1, choices=[&#34;bash&#34;,&#34;zsh&#34;], action=self._store_type, help=&#34;Get terminal completion configuration for conn&#34;)
        configcrud.add_argument(&#34;--configfolder&#34;, dest=&#34;configfolder&#34;, nargs=1, action=self._store_type, help=&#34;Set the default location for config file&#34;, metavar=&#34;FOLDER&#34;)
        configcrud.add_argument(&#34;--openai-org&#34;, dest=&#34;organization&#34;, nargs=1, action=self._store_type, help=&#34;Set openai organization&#34;, metavar=&#34;ORGANIZATION&#34;)
        configcrud.add_argument(&#34;--openai-api-key&#34;, dest=&#34;api_key&#34;, nargs=1, action=self._store_type, help=&#34;Set openai api_key&#34;, metavar=&#34;API_KEY&#34;)
        configcrud.add_argument(&#34;--openai-model&#34;, dest=&#34;model&#34;, nargs=1, action=self._store_type, help=&#34;Set openai model&#34;, metavar=&#34;MODEL&#34;)
        configparser.set_defaults(func=self._func_others)
        #Add plugins
        file_path = self.config.defaultdir + &#34;/plugins&#34;
        self.plugins = Plugins()
        self.plugins._import_plugins_to_argparse(file_path, subparsers)
        #Generate helps
        nodeparser.usage = self._help(&#34;usage&#34;, subparsers)
        nodeparser.epilog = self._help(&#34;end&#34;, subparsers)
        nodeparser.help = self._help(&#34;node&#34;)
        #Manage sys arguments
        self.commands = list(subparsers.choices.keys())
        profilecmds = []
        for action in profileparser._actions:
            profilecmds.extend(action.option_strings)
        if len(argv) &gt;= 2 and argv[1] == &#34;profile&#34; and argv[0] in profilecmds:
            argv[1] = argv[0]
            argv[0] = &#34;profile&#34;
        if len(argv) &lt; 1 or argv[0] not in self.commands:
            argv.insert(0,&#34;node&#34;)
        args = defaultparser.parse_args(argv)
        if args.subcommand in self.plugins.plugins:
            self.plugins.plugins[args.subcommand].Entrypoint(args, self.plugins.plugin_parsers[args.subcommand].parser, self)
        else:
            return args.func(args)

    class _store_type(argparse.Action):
        #Custom store type for cli app.
        def __call__(self, parser, args, values, option_string=None):
            setattr(args, &#34;data&#34;, values)
            delattr(args,self.dest)
            setattr(args, &#34;command&#34;, self.dest)

    def _func_node(self, args):
        #Function called when connecting or managing nodes.
        if not self.case and args.data != None:
            args.data = args.data.lower()
        actions = {&#34;version&#34;: self._version, &#34;connect&#34;: self._connect, &#34;add&#34;: self._add, &#34;del&#34;: self._del, &#34;mod&#34;: self._mod, &#34;show&#34;: self._show}
        return actions.get(args.action)(args)

    def _version(self, args):
        print(__version__)

    def _connect(self, args):
        if args.data == None:
            matches = self.nodes
            if len(matches) == 0:
                print(&#34;There are no nodes created&#34;)
                print(&#34;try: conn --help&#34;)
                exit(9)
        else:
            if args.data.startswith(&#34;@&#34;):
                matches = list(filter(lambda k: args.data in k, self.nodes))
            else:
                matches = list(filter(lambda k: k.startswith(args.data), self.nodes))
        if len(matches) == 0:
            print(&#34;{} not found&#34;.format(args.data))
            exit(2)
        elif len(matches) &gt; 1:
            matches[0] = self._choose(matches,&#34;node&#34;, &#34;connect&#34;)
        if matches[0] == None:
            exit(7)
        node = self.config.getitem(matches[0])
        node = self.node(matches[0],**node, config = self.config)
        if args.sftp:
            node.protocol = &#34;sftp&#34;
        if args.debug:
            node.interact(debug = True)
        else:
            node.interact()

    def _del(self, args):
        if args.data == None:
            print(&#34;Missing argument node&#34;)
            exit(3)
        elif args.data.startswith(&#34;@&#34;):
            matches = list(filter(lambda k: k == args.data, self.folders))
        else:
            matches = self.config._getallnodes(args.data)
        if len(matches) == 0:
            print(&#34;{} not found&#34;.format(args.data))
            exit(2)
        print(&#34;Removing: {}&#34;.format(matches))
        question = [inquirer.Confirm(&#34;delete&#34;, message=&#34;Are you sure you want to continue?&#34;)]
        confirm = inquirer.prompt(question)
        if confirm == None:
            exit(7)
        if confirm[&#34;delete&#34;]:
            if args.data.startswith(&#34;@&#34;):
                uniques = self.config._explode_unique(matches[0])
                self.config._folder_del(**uniques)
            else:
                for node in matches:
                    nodeuniques = self.config._explode_unique(node)
                    self.config._connections_del(**nodeuniques)
            self.config._saveconfig(self.config.file)
            if len(matches) == 1:
                print(&#34;{} deleted succesfully&#34;.format(matches[0]))
            else:
                print(f&#34;{len(matches)} nodes deleted succesfully&#34;)

    def _add(self, args):
        args.data = self._type_node(args.data)
        if args.data == None:
            print(&#34;Missing argument node&#34;)
            exit(3)
        elif args.data.startswith(&#34;@&#34;):
            type = &#34;folder&#34;
            matches = list(filter(lambda k: k == args.data, self.folders))
            reversematches = list(filter(lambda k: &#34;@&#34; + k == args.data, self.nodes))
        else:
            type = &#34;node&#34;
            matches = list(filter(lambda k: k == args.data, self.nodes))
            reversematches = list(filter(lambda k: k == &#34;@&#34; + args.data, self.folders))
        if len(matches) &gt; 0:
            print(&#34;{} already exist&#34;.format(matches[0]))
            exit(4)
        if len(reversematches) &gt; 0:
            print(&#34;{} already exist&#34;.format(reversematches[0]))
            exit(4)
        else:
            if type == &#34;folder&#34;:
                uniques = self.config._explode_unique(args.data)
                if uniques == False:
                    print(&#34;Invalid folder {}&#34;.format(args.data))
                    exit(5)
                if &#34;subfolder&#34; in uniques.keys():
                    parent = &#34;@&#34; + uniques[&#34;folder&#34;]
                    if parent not in self.folders:
                        print(&#34;Folder {} not found&#34;.format(uniques[&#34;folder&#34;]))
                        exit(2)
                self.config._folder_add(**uniques)
                self.config._saveconfig(self.config.file)
                print(&#34;{} added succesfully&#34;.format(args.data))
            if type == &#34;node&#34;:
                nodefolder = args.data.partition(&#34;@&#34;)
                nodefolder = &#34;@&#34; + nodefolder[2]
                if nodefolder not in self.folders and nodefolder != &#34;@&#34;:
                    print(nodefolder + &#34; not found&#34;)
                    exit(2)
                uniques = self.config._explode_unique(args.data)
                if uniques == False:
                    print(&#34;Invalid node {}&#34;.format(args.data))
                    exit(5)
                print(&#34;You can use the configured setting in a profile using @profilename.&#34;)
                print(&#34;You can also leave empty any value except hostname/IP.&#34;)
                print(&#34;You can pass 1 or more passwords using comma separated @profiles&#34;)
                print(&#34;You can use this variables on logging file name: ${id} ${unique} ${host} ${port} ${user} ${protocol}&#34;)
                print(&#34;Some useful tags to set for automation are &#39;os&#39;, &#39;screen_length_command&#39;, and &#39;prompt&#39;.&#34;)
                newnode = self._questions_nodes(args.data, uniques)
                if newnode == False:
                    exit(7)
                self.config._connections_add(**newnode)
                self.config._saveconfig(self.config.file)
                print(&#34;{} added succesfully&#34;.format(args.data))

    def _show(self, args):
        if args.data == None:
            print(&#34;Missing argument node&#34;)
            exit(3)
        matches = list(filter(lambda k: k == args.data, self.nodes))
        if len(matches) == 0:
            print(&#34;{} not found&#34;.format(args.data))
            exit(2)
        node = self.config.getitem(matches[0])
        for k, v in node.items():
            if isinstance(v, str):
                print(k + &#34;: &#34; + v)
            elif isinstance(v, list):
                print(k + &#34;:&#34;)
                for i in v:
                    print(&#34;  - &#34; + i)
            elif isinstance(v, dict):
                print(k + &#34;:&#34;)
                for i,d in v.items():
                    print(&#34;  - &#34; + i + &#34;: &#34; + d)

    def _mod(self, args):
        if args.data == None:
            print(&#34;Missing argument node&#34;)
            exit(3)
        matches = self.config._getallnodes(args.data)
        if len(matches) == 0:
            print(&#34;No connection found with filter: {}&#34;.format(args.data))
            exit(2)
        elif len(matches) == 1:
            uniques = self.config._explode_unique(args.data)
            unique = matches[0]
        else:
            uniques = {&#34;id&#34;: None, &#34;folder&#34;: None}
            unique = None
        print(&#34;Editing: {}&#34;.format(matches))
        node = {}
        for i in matches:
            node[i] = self.config.getitem(i)
        edits = self._questions_edit()
        if edits == None:
            exit(7)
        updatenode = self._questions_nodes(unique, uniques, edit=edits)
        if not updatenode:
            exit(7)
        if len(matches) == 1:
            uniques.update(node[matches[0]])
            uniques[&#34;type&#34;] = &#34;connection&#34;
            if sorted(updatenode.items()) == sorted(uniques.items()):
                print(&#34;Nothing to do here&#34;)
                return
            else:
                self.config._connections_add(**updatenode)
                self.config._saveconfig(self.config.file)
                print(&#34;{} edited succesfully&#34;.format(args.data))
        else:
            for k in node:
                updatednode = self.config._explode_unique(k)
                updatednode[&#34;type&#34;] = &#34;connection&#34;
                updatednode.update(node[k])
                editcount = 0
                for key, should_edit in edits.items():
                    if should_edit:
                        editcount += 1
                        updatednode[key] = updatenode[key]
                if not editcount:
                    print(&#34;Nothing to do here&#34;)
                    return
                else:
                    self.config._connections_add(**updatednode)
            self.config._saveconfig(self.config.file)
            print(&#34;{} edited succesfully&#34;.format(matches))
            return


    def _func_profile(self, args):
        #Function called when managing profiles
        if not self.case:
            args.data[0] = args.data[0].lower()
        actions = {&#34;add&#34;: self._profile_add, &#34;del&#34;: self._profile_del, &#34;mod&#34;: self._profile_mod, &#34;show&#34;: self._profile_show}
        return actions.get(args.action)(args)

    def _profile_del(self, args):
        matches = list(filter(lambda k: k == args.data[0], self.profiles))
        if len(matches) == 0:
            print(&#34;{} not found&#34;.format(args.data[0]))
            exit(2)
        if matches[0] == &#34;default&#34;:
            print(&#34;Can&#39;t delete default profile&#34;)
            exit(6)
        usedprofile = self.config._profileused(matches[0])
        if len(usedprofile) &gt; 0:
            print(&#34;Profile {} used in the following nodes:&#34;.format(matches[0]))
            print(&#34;, &#34;.join(usedprofile))
            exit(8)
        question = [inquirer.Confirm(&#34;delete&#34;, message=&#34;Are you sure you want to delete {}?&#34;.format(matches[0]))]
        confirm = inquirer.prompt(question)
        if confirm[&#34;delete&#34;]:
            self.config._profiles_del(id = matches[0])
            self.config._saveconfig(self.config.file)
            print(&#34;{} deleted succesfully&#34;.format(matches[0]))

    def _profile_show(self, args):
        matches = list(filter(lambda k: k == args.data[0], self.profiles))
        if len(matches) == 0:
            print(&#34;{} not found&#34;.format(args.data[0]))
            exit(2)
        profile = self.config.profiles[matches[0]]
        for k, v in profile.items():
            if isinstance(v, str):
                print(k + &#34;: &#34; + v)
            elif isinstance(v, list):
                print(k + &#34;:&#34;)
                for i in v:
                    print(&#34;  - &#34; + i)
            elif isinstance(v, dict):
                print(k + &#34;:&#34;)
                for i,d in v.items():
                    print(&#34;  - &#34; + i + &#34;: &#34; + d)

    def _profile_add(self, args):
        matches = list(filter(lambda k: k == args.data[0], self.profiles))
        if len(matches) &gt; 0:
            print(&#34;Profile {} Already exist&#34;.format(matches[0]))
            exit(4)
        newprofile = self._questions_profiles(args.data[0])
        if newprofile == False:
            exit(7)
        self.config._profiles_add(**newprofile)
        self.config._saveconfig(self.config.file)
        print(&#34;{} added succesfully&#34;.format(args.data[0]))

    def _profile_mod(self, args):
        matches = list(filter(lambda k: k == args.data[0], self.profiles))
        if len(matches) == 0:
            print(&#34;{} not found&#34;.format(args.data[0]))
            exit(2)
        profile = self.config.profiles[matches[0]]
        oldprofile = {&#34;id&#34;: matches[0]}
        oldprofile.update(profile)
        edits = self._questions_edit()
        if edits == None:
            exit(7)
        updateprofile = self._questions_profiles(matches[0], edit=edits)
        if not updateprofile:
            exit(7)
        if sorted(updateprofile.items()) == sorted(oldprofile.items()):
            print(&#34;Nothing to do here&#34;)
            return
        else:
            self.config._profiles_add(**updateprofile)
            self.config._saveconfig(self.config.file)
            print(&#34;{} edited succesfully&#34;.format(args.data[0]))
    
    def _func_others(self, args):
        #Function called when using other commands
        actions = {&#34;ls&#34;: self._ls, &#34;move&#34;: self._mvcp, &#34;cp&#34;: self._mvcp, &#34;bulk&#34;: self._bulk, &#34;completion&#34;: self._completion, &#34;case&#34;: self._case, &#34;fzf&#34;: self._fzf, &#34;idletime&#34;: self._idletime, &#34;configfolder&#34;: self._configfolder, &#34;organization&#34;: self._openai, &#34;api_key&#34;: self._openai, &#34;model&#34;: self._openai}
        return actions.get(args.command)(args)

    def _ls(self, args):
        items = getattr(self, args.data)
        if args.filter:
            items = [ item for item in items if re.search(args.filter[0], item)]
        if args.format and args.data == &#34;nodes&#34;:
            newitems = []
            for i in items:
                formated = {}
                info = self.config.getitem(i)
                if &#34;@&#34; in i:
                    name_part, location_part = i.split(&#34;@&#34;, 1)
                    formated[&#34;location&#34;] = &#34;@&#34; + location_part
                else:
                    name_part = i
                    formated[&#34;location&#34;] = &#34;&#34;
                formated[&#34;name&#34;] = name_part
                formated[&#34;host&#34;] = info[&#34;host&#34;]
                items_copy = list(formated.items())
                for key, value in items_copy:
                    upper_key = key.upper()
                    upper_value = value.upper()
                    formated[upper_key] = upper_value
                newitems.append(args.format[0].format(**formated))
            items = newitems
        print(*items, sep=&#34;\n&#34;)

    def _mvcp(self, args):
        if not self.case:
            args.data[0] = args.data[0].lower()
            args.data[1] = args.data[1].lower()
        source = list(filter(lambda k: k == args.data[0], self.nodes))
        dest = list(filter(lambda k: k == args.data[1], self.nodes))
        if len(source) != 1:
            print(&#34;{} not found&#34;.format(args.data[0]))
            exit(2)
        if len(dest) &gt; 0:
            print(&#34;Node {} Already exist&#34;.format(args.data[1]))
            exit(4)
        nodefolder = args.data[1].partition(&#34;@&#34;)
        nodefolder = &#34;@&#34; + nodefolder[2]
        if nodefolder not in self.folders and nodefolder != &#34;@&#34;:
            print(&#34;{} not found&#34;.format(nodefolder))
            exit(2)
        olduniques = self.config._explode_unique(args.data[0])
        newuniques = self.config._explode_unique(args.data[1])
        if newuniques == False:
            print(&#34;Invalid node {}&#34;.format(args.data[1]))
            exit(5)
        node = self.config.getitem(source[0])
        newnode = {**newuniques, **node}
        self.config._connections_add(**newnode)
        if args.command == &#34;move&#34;:
           self.config._connections_del(**olduniques) 
        self.config._saveconfig(self.config.file)
        action = &#34;moved&#34; if args.command == &#34;move&#34; else &#34;copied&#34;
        print(&#34;{} {} succesfully to {}&#34;.format(args.data[0],action, args.data[1]))

    def _bulk(self, args):
        newnodes = self._questions_bulk()
        if newnodes == False:
            exit(7)
        if not self.case:
            newnodes[&#34;location&#34;] = newnodes[&#34;location&#34;].lower()
            newnodes[&#34;ids&#34;] = newnodes[&#34;ids&#34;].lower()
        ids = newnodes[&#34;ids&#34;].split(&#34;,&#34;)
        hosts = newnodes[&#34;host&#34;].split(&#34;,&#34;)
        count = 0
        for n in ids:
            unique = n + newnodes[&#34;location&#34;]
            matches = list(filter(lambda k: k == unique, self.nodes))
            reversematches = list(filter(lambda k: k == &#34;@&#34; + unique, self.folders))
            if len(matches) &gt; 0:
                print(&#34;Node {} already exist, ignoring it&#34;.format(unique))
                continue
            if len(reversematches) &gt; 0:
                print(&#34;Folder with name {} already exist, ignoring it&#34;.format(unique))
                continue
            newnode = {&#34;id&#34;: n}
            if newnodes[&#34;location&#34;] != &#34;&#34;:
                location = self.config._explode_unique(newnodes[&#34;location&#34;])
                newnode.update(location)
            if len(hosts) &gt; 1:
                index = ids.index(n)
                newnode[&#34;host&#34;] = hosts[index]
            else:
                newnode[&#34;host&#34;] = hosts[0]
            newnode[&#34;protocol&#34;] = newnodes[&#34;protocol&#34;]
            newnode[&#34;port&#34;] = newnodes[&#34;port&#34;]
            newnode[&#34;options&#34;] = newnodes[&#34;options&#34;]
            newnode[&#34;logs&#34;] = newnodes[&#34;logs&#34;]
            newnode[&#34;tags&#34;] = newnodes[&#34;tags&#34;]
            newnode[&#34;jumphost&#34;] = newnodes[&#34;jumphost&#34;]
            newnode[&#34;user&#34;] = newnodes[&#34;user&#34;]
            newnode[&#34;password&#34;] = newnodes[&#34;password&#34;]
            count +=1
            self.config._connections_add(**newnode)
            self.nodes = self.config._getallnodes()
        if count &gt; 0:
            self.config._saveconfig(self.config.file)
            print(&#34;Succesfully added {} nodes&#34;.format(count))
        else:
            print(&#34;0 nodes added&#34;)

    def _completion(self, args):
        if args.data[0] == &#34;bash&#34;:
            print(self._help(&#34;bashcompletion&#34;))
        elif args.data[0] == &#34;zsh&#34;:
            print(self._help(&#34;zshcompletion&#34;))

    def _case(self, args):
        if args.data[0] == &#34;true&#34;:
            args.data[0] = True
        elif args.data[0] == &#34;false&#34;:
            args.data[0] = False
        self._change_settings(args.command, args.data[0])

    def _fzf(self, args):
        if args.data[0] == &#34;true&#34;:
            args.data[0] = True
        elif args.data[0] == &#34;false&#34;:
            args.data[0] = False
        self._change_settings(args.command, args.data[0])

    def _idletime(self, args):
        if args.data[0] &lt; 0:
            args.data[0] = 0
        self._change_settings(args.command, args.data[0])

    def _configfolder(self, args):
        if not os.path.isdir(args.data[0]):
            raise argparse.ArgumentTypeError(f&#34;readable_dir:{args.data[0]} is not a valid path&#34;)
        else:
            pathfile = self.config.defaultdir + &#34;/.folder&#34;
            folder = os.path.abspath(args.data[0]).rstrip(&#39;/&#39;)
            with open(pathfile, &#34;w&#34;) as f:
                f.write(str(folder))
            print(&#34;Config saved&#34;)
        
    def _openai(self, args):
        if &#34;openai&#34; in self.config.config:
            openaikeys = self.config.config[&#34;openai&#34;]
        else:
            openaikeys = {}
        openaikeys[args.command] = args.data[0]
        self._change_settings(&#34;openai&#34;, openaikeys)


    def _change_settings(self, name, value):
        self.config.config[name] = value
        self.config._saveconfig(self.config.file)
        print(&#34;Config saved&#34;)

    def _func_plugin(self, args):
        if args.add:
            if not os.path.exists(args.add[1]):
                print(&#34;File {} dosn&#39;t exists.&#34;.format(args.add[1]))
                exit(14)
            if args.add[0].isalpha() and args.add[0].islower() and len(args.add[0]) &lt;= 15:
                disabled_dest_file = os.path.join(self.config.defaultdir + &#34;/plugins&#34;, args.add[0] + &#34;.py.bkp&#34;)
                if args.add[0] in self.commands or os.path.exists(disabled_dest_file):
                    print(&#34;Plugin name can&#39;t be the same as other commands.&#34;)
                    exit(15)
                else:
                    check_bad_script = self.plugins.verify_script(args.add[1])
                    if check_bad_script:
                        print(check_bad_script)
                        exit(16)
                    else:
                        try:
                            dest_file = os.path.join(self.config.defaultdir + &#34;/plugins&#34;, args.add[0] + &#34;.py&#34;)
                            shutil.copy2(args.add[1], dest_file)
                            print(f&#34;Plugin {args.add[0]} added succesfully.&#34;)
                        except:
                            print(&#34;Failed importing plugin file.&#34;)
                            exit(17)
            else:
                print(&#34;Plugin name should be lowercase letters up to 15 characters.&#34;)
                exit(15)
        elif args.delete:
            plugin_file = os.path.join(self.config.defaultdir + &#34;/plugins&#34;, args.delete[0] + &#34;.py&#34;)
            disabled_plugin_file = os.path.join(self.config.defaultdir + &#34;/plugins&#34;, args.delete[0] + &#34;.py.bkp&#34;)
            plugin_exist = os.path.exists(plugin_file)
            disabled_plugin_exist = os.path.exists(disabled_plugin_file)
            if not plugin_exist and not disabled_plugin_exist:
                print(&#34;Plugin {} dosn&#39;t exist.&#34;.format(args.delete[0]))
                exit(14)
            question = [inquirer.Confirm(&#34;delete&#34;, message=&#34;Are you sure you want to delete {} plugin?&#34;.format(args.delete[0]))]
            confirm = inquirer.prompt(question)
            if confirm == None:
                exit(7)
            if confirm[&#34;delete&#34;]:
                try:
                    if plugin_exist:
                        os.remove(plugin_file)
                    elif disabled_plugin_exist:
                        os.remove(disabled_plugin_file)
                    print(f&#34;plugin {args.delete[0]} deleted succesfully.&#34;)
                except:
                    print(&#34;Failed deleting plugin file.&#34;)
                    exit(17)
        elif args.disable:
            plugin_file = os.path.join(self.config.defaultdir + &#34;/plugins&#34;, args.disable[0] + &#34;.py&#34;)
            disabled_plugin_file = os.path.join(self.config.defaultdir + &#34;/plugins&#34;, args.disable[0] + &#34;.py.bkp&#34;)
            if not os.path.exists(plugin_file) or os.path.exists(disabled_plugin_file):
                print(&#34;Plugin {} dosn&#39;t exist or it&#39;s disabled.&#34;.format(args.disable[0]))
                exit(14)
            try:
                os.rename(plugin_file, disabled_plugin_file)
                print(f&#34;plugin {args.disable[0]} disabled succesfully.&#34;)
            except:
                print(&#34;Failed disabling plugin file.&#34;)
                exit(17)
        elif args.enable:
            plugin_file = os.path.join(self.config.defaultdir + &#34;/plugins&#34;, args.enable[0] + &#34;.py&#34;)
            disabled_plugin_file = os.path.join(self.config.defaultdir + &#34;/plugins&#34;, args.enable[0] + &#34;.py.bkp&#34;)
            if os.path.exists(plugin_file) or not os.path.exists(disabled_plugin_file):
                print(&#34;Plugin {} dosn&#39;t exist or it&#39;s enabled.&#34;.format(args.enable[0]))
                exit(14)
            try:
                os.rename(disabled_plugin_file, plugin_file)
                print(f&#34;plugin {args.enable[0]} enabled succesfully.&#34;)
            except:
                print(&#34;Failed enabling plugin file.&#34;)
                exit(17)
        elif args.list:
            enabled_files = []
            disabled_files = []
            plugins = {}
        
            # Iterate over all files in the specified folder
            for file in os.listdir(self.config.defaultdir + &#34;/plugins&#34;):
                # Check if the file is a Python file
                if file.endswith(&#39;.py&#39;):
                    enabled_files.append(os.path.splitext(file)[0])
                # Check if the file is a Python backup file
                elif file.endswith(&#39;.py.bkp&#39;):
                    disabled_files.append(os.path.splitext(os.path.splitext(file)[0])[0])
            if enabled_files:
                plugins[&#34;Enabled&#34;] = enabled_files
            if disabled_files:
                plugins[&#34;Disabled&#34;] = disabled_files
            if plugins:
                print(yaml.dump(plugins, sort_keys=False))
            else:
                print(&#34;There are no plugins added.&#34;)




    def _func_import(self, args):
        if not os.path.exists(args.data[0]):
            print(&#34;File {} dosn&#39;t exist&#34;.format(args.data[0]))
            exit(14)
        print(&#34;This could overwrite your current configuration!&#34;)
        question = [inquirer.Confirm(&#34;import&#34;, message=&#34;Are you sure you want to import {} file?&#34;.format(args.data[0]))]
        confirm = inquirer.prompt(question)
        if confirm == None:
            exit(7)
        if confirm[&#34;import&#34;]:
            try:
                with open(args.data[0]) as file:
                    imported = yaml.load(file, Loader=yaml.FullLoader)
            except:
                print(&#34;failed reading file {}&#34;.format(args.data[0]))
                exit(10)
            for k,v in imported.items():
                uniques = self.config._explode_unique(k)
                if &#34;folder&#34; in uniques:
                    folder = f&#34;@{uniques[&#39;folder&#39;]}&#34;
                    matches = list(filter(lambda k: k == folder, self.folders))
                    if len(matches) == 0:
                        uniquefolder = self.config._explode_unique(folder)
                        self.config._folder_add(**uniquefolder)
                if &#34;subfolder&#34; in uniques:
                    subfolder = f&#34;@{uniques[&#39;subfolder&#39;]}@{uniques[&#39;folder&#39;]}&#34;
                    matches = list(filter(lambda k: k == subfolder, self.folders))
                    if len(matches) == 0:
                        uniquesubfolder = self.config._explode_unique(subfolder)
                        self.config._folder_add(**uniquesubfolder)
                uniques.update(v)
                self.config._connections_add(**uniques)
            self.config._saveconfig(self.config.file)
            print(&#34;File {} imported succesfully&#34;.format(args.data[0]))
        return

    def _func_export(self, args):
        if os.path.exists(args.data[0]):
            print(&#34;File {} already exists&#34;.format(args.data[0]))
            exit(14)
        if len(args.data[1:]) == 0:
            foldercons = self.config._getallnodesfull(extract = False)
        else:
            for folder in args.data[1:]:
                matches = list(filter(lambda k: k == folder, self.folders))
                if len(matches) == 0 and folder != &#34;@&#34;:
                    print(&#34;{} folder not found&#34;.format(folder))
                    exit(2)
            foldercons = self.config._getallnodesfull(args.data[1:], extract = False)
        with open(args.data[0], &#34;w&#34;) as file:
            yaml.dump(foldercons, file, Dumper=NoAliasDumper, default_flow_style=False)
            file.close()
        print(&#34;File {} generated succesfully&#34;.format(args.data[0]))
        exit()
        return

    def _func_run(self, args):
        if len(args.data) &gt; 1:
            args.action = &#34;noderun&#34;
        actions = {&#34;noderun&#34;: self._node_run, &#34;generate&#34;: self._yaml_generate, &#34;run&#34;: self._yaml_run}
        return actions.get(args.action)(args)

    def _func_ai(self, args):
        arguments = {}
        if args.model:
            arguments[&#34;model&#34;] = args.model[0]
        if args.org:
            arguments[&#34;org&#34;] = args.org[0]
        if args.api_key:
            arguments[&#34;api_key&#34;] = args.api_key[0]
        self.myai = ai(self.config, **arguments)
        if args.ask:
            input = &#34; &#34;.join(args.ask)
            request = self.myai.ask(input, dryrun = True)
            if not request[&#34;app_related&#34;]:
                mdprint(Markdown(request[&#34;response&#34;]))
                print(&#34;\r&#34;)
            else:
                if request[&#34;action&#34;] == &#34;list_nodes&#34;:
                    if request[&#34;filter&#34;]:
                        nodes = self.config._getallnodes(request[&#34;filter&#34;])
                    else:
                        nodes = self.config._getallnodes()
                    list = &#34;\n&#34;.join(nodes)
                    print(list)
                else:
                    yaml_data = yaml.dump(request[&#34;task&#34;])
                    confirmation = f&#34;I&#39;m going to run the following task:\n```{yaml_data}```&#34;
                    mdprint(Markdown(confirmation))
                    question = [inquirer.Confirm(&#34;task&#34;, message=&#34;Are you sure you want to continue?&#34;)]
                    print(&#34;\r&#34;)
                    confirm = inquirer.prompt(question)
                    if confirm == None:
                        exit(7)
                    if confirm[&#34;task&#34;]:
                        script = {}
                        script[&#34;name&#34;] = &#34;RESULT&#34;
                        script[&#34;output&#34;] = &#34;stdout&#34;
                        script[&#34;nodes&#34;] = request[&#34;nodes&#34;]
                        script[&#34;action&#34;] = request[&#34;action&#34;]
                        if &#34;expected&#34; in request:
                            script[&#34;expected&#34;] = request[&#34;expected&#34;]
                        script.update(request[&#34;args&#34;])
                        self._cli_run(script)
        else:
            history = None
            mdprint(Markdown(&#34;**Chatbot**: Hi! How can I help you today?\n\n---&#34;))
            while True:
                questions = [
                        inquirer.Text(&#39;message&#39;, message=&#34;User&#34;, validate=self._ai_validation),
                    ]
                answers = inquirer.prompt(questions)
                if answers == None:
                    exit(7)
                response, history = self._process_input(answers[&#34;message&#34;], history)
                mdprint(Markdown(f&#34;&#34;&#34;**Chatbot**:\n{response}\n\n---&#34;&#34;&#34;))
        return


    def _ai_validation(self, answers, current, regex = &#34;^.+$&#34;):
        #Validate ai user chat.
        if not re.match(regex, current):
            raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Can&#39;t send empty messages&#34;)
        return True

    def _process_input(self, input, history):
        response = self.myai.ask(input , chat_history = history, dryrun = True)
        if not response[&#34;app_related&#34;]:
            try:
                if not history:
                    history = []
                history.extend(response[&#34;chat_history&#34;])
            except:
                if not history:
                    history = None
            return response[&#34;response&#34;], history
        else:
            history = None
            if response[&#34;action&#34;] == &#34;list_nodes&#34;:
                if response[&#34;filter&#34;]:
                    nodes = self.config._getallnodes(response[&#34;filter&#34;])
                else:
                    nodes = self.config._getallnodes()
                list = &#34;\n&#34;.join(nodes)
                response = f&#34;```{list}\n```&#34;
            else:
                yaml_data = yaml.dump(response[&#34;task&#34;])
                confirmresponse = f&#34;I&#39;m going to run the following task:\n```{yaml_data}```\nPlease confirm&#34;
                while True:
                    mdprint(Markdown(f&#34;&#34;&#34;**Chatbot**:\n{confirmresponse}&#34;&#34;&#34;))
                    questions = [
                            inquirer.Text(&#39;message&#39;, message=&#34;User&#34;, validate=self._ai_validation),
                        ]
                    answers = inquirer.prompt(questions)
                    if answers == None:
                        exit(7)
                    confirmation = self.myai.confirm(answers[&#34;message&#34;])
                    if isinstance(confirmation, bool):
                        if not confirmation:
                            response = &#34;Request cancelled&#34;
                        else:
                            nodes = self.connnodes(self.config.getitems(response[&#34;nodes&#34;]), config = self.config)
                            if response[&#34;action&#34;] == &#34;run&#34;:
                                output = nodes.run(**response[&#34;args&#34;])
                                response = &#34;&#34;
                            elif response[&#34;action&#34;] == &#34;test&#34;:
                                result = nodes.test(**response[&#34;args&#34;])
                                yaml_result = yaml.dump(result,default_flow_style=False, indent=4)
                                output = nodes.output
                                response = f&#34;This is the result for your test:\n```\n{yaml_result}\n```&#34;
                            for k,v in output.items():
                                response += f&#34;\n***{k}***:\n```\n{v}\n```\n&#34;
                        break
            return response, history

    def _func_api(self, args):
        if args.command == &#34;stop&#34; or args.command == &#34;restart&#34;:
            args.data = stop_api()
        if args.command == &#34;start&#34; or args.command == &#34;restart&#34;:
            if args.data:
                start_api(args.data)
            else:
                start_api()
        if args.command == &#34;debug&#34;:
            if args.data:
                debug_api(args.data)
            else:
                debug_api()
        return

    def _node_run(self, args):
        command = &#34; &#34;.join(args.data[1:])
        script = {}
        script[&#34;name&#34;] = &#34;Output&#34;
        script[&#34;action&#34;] = &#34;run&#34;
        script[&#34;nodes&#34;] = args.data[0]
        script[&#34;commands&#34;] = [command]
        script[&#34;output&#34;] = &#34;stdout&#34;
        self._cli_run(script)

    def _yaml_generate(self, args):
        if os.path.exists(args.data[0]):
            print(&#34;File {} already exists&#34;.format(args.data[0]))
            exit(14)
        else:
            with open(args.data[0], &#34;w&#34;) as file:
                file.write(self._help(&#34;generate&#34;))
                file.close()
            print(&#34;File {} generated succesfully&#34;.format(args.data[0]))
            exit()

    def _yaml_run(self, args):
        try:
            with open(args.data[0]) as file:
                scripts = yaml.load(file, Loader=yaml.FullLoader)
        except:
            print(&#34;failed reading file {}&#34;.format(args.data[0]))
            exit(10)
        for script in scripts[&#34;tasks&#34;]:
            self._cli_run(script)


    def _cli_run(self, script):
        args = {}
        try:
            action = script[&#34;action&#34;]
            nodelist = script[&#34;nodes&#34;]
            args[&#34;commands&#34;] = script[&#34;commands&#34;]
            output = script[&#34;output&#34;]
            if action == &#34;test&#34;:
                args[&#34;expected&#34;] = script[&#34;expected&#34;]
        except KeyError as e:
            print(&#34;&#39;{}&#39; is mandatory&#34;.format(e.args[0]))
            exit(11)
        nodes = self.config._getallnodes(nodelist)
        if len(nodes) == 0:
            print(&#34;{} don&#39;t match any node&#34;.format(nodelist))
            exit(2)
        nodes = self.connnodes(self.config.getitems(nodes), config = self.config)
        stdout = False
        if output is None:
            pass
        elif output == &#34;stdout&#34;:
            stdout = True
        elif isinstance(output, str) and action == &#34;run&#34;:
            args[&#34;folder&#34;] = output
        if &#34;variables&#34; in script:
            args[&#34;vars&#34;] = script[&#34;variables&#34;]
        if &#34;vars&#34; in script:
            args[&#34;vars&#34;] = script[&#34;vars&#34;]
        try:
            options = script[&#34;options&#34;]
            thisoptions = {k: v for k, v in options.items() if k in [&#34;prompt&#34;, &#34;parallel&#34;, &#34;timeout&#34;]}
            args.update(thisoptions)
        except:
            options = None
        try:
            size = str(os.get_terminal_size())
            p = re.search(r&#39;.*columns=([0-9]+)&#39;, size)
            columns = int(p.group(1))
        except:
            columns = 80
        if action == &#34;run&#34;:
            nodes.run(**args)
            print(script[&#34;name&#34;].upper() + &#34;-&#34; * (columns - len(script[&#34;name&#34;])))
            for i in nodes.status.keys():
                print(&#34;   &#34; + i + &#34; &#34; + &#34;-&#34; * (columns - len(i) - 13) + (&#34; PASS(0)&#34; if nodes.status[i] == 0 else &#34; FAIL({})&#34;.format(nodes.status[i])))
                if stdout:
                    for line in nodes.output[i].splitlines():
                        print(&#34;      &#34; + line)
        elif action == &#34;test&#34;:
            nodes.test(**args)
            print(script[&#34;name&#34;].upper() + &#34;-&#34; * (columns - len(script[&#34;name&#34;])))
            for i in nodes.status.keys():
                print(&#34;   &#34; + i + &#34; &#34; + &#34;-&#34; * (columns - len(i) - 13) + (&#34; PASS(0)&#34; if nodes.status[i] == 0 else &#34; FAIL({})&#34;.format(nodes.status[i])))
                if nodes.status[i] == 0:
                    max_length = max(len(s) for s in nodes.result[i].keys())
                    for k,v in nodes.result[i].items():
                        print(&#34;     TEST for &#39;{}&#39;&#34;.format(k) +  &#34; &#34;*(max_length - len(k) + 1) + &#34;--&gt; &#34; + str(v).upper())
                if stdout:
                    if nodes.status[i] == 0:
                        print(&#34;     &#34; + &#34;-&#34; * (max_length + 21))
                    for line in nodes.output[i].splitlines():
                        print(&#34;      &#34; + line)
        else:
            print(&#34;Wrong action &#39;{}&#39;&#34;.format(action))
            exit(13)

    def _choose(self, list, name, action):
        #Generates an inquirer list to pick
        if FzfPrompt and self.fzf:
            fzf = FzfPrompt(executable_path=&#34;fzf-tmux&#34;)
            if not self.case:
                fzf = FzfPrompt(executable_path=&#34;fzf-tmux -i&#34;)
            answer = fzf.prompt(list, fzf_options=&#34;-d 25%&#34;)
            if len(answer) == 0:
                return
            else:
                return answer[0]
        else:
            questions = [inquirer.List(name, message=&#34;Pick {} to {}:&#34;.format(name,action), choices=list, carousel=True)]
            answer = inquirer.prompt(questions)
            if answer == None:
                return
            else:
                return answer[name]

    def _host_validation(self, answers, current, regex = &#34;^.+$&#34;):
        #Validate hostname in inquirer when managing nodes
        if not re.match(regex, current):
            raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Host cannot be empty&#34;)
        if current.startswith(&#34;@&#34;):
            if current[1:] not in self.profiles:
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Profile {} don&#39;t exist&#34;.format(current))
        return True

    def _profile_protocol_validation(self, answers, current, regex = &#34;(^ssh$|^telnet$|^$)&#34;):
        #Validate protocol in inquirer when managing profiles
        if not re.match(regex, current):
            raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Pick between ssh, telnet or leave empty&#34;)
        return True

    def _protocol_validation(self, answers, current, regex = &#34;(^ssh$|^telnet$|^$|^@.+$)&#34;):
        #Validate protocol in inquirer when managing nodes
        if not re.match(regex, current):
            raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Pick between ssh, telnet, leave empty or @profile&#34;)
        if current.startswith(&#34;@&#34;):
            if current[1:] not in self.profiles:
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Profile {} don&#39;t exist&#34;.format(current))
        return True

    def _profile_port_validation(self, answers, current, regex = &#34;(^[0-9]*$)&#34;):
        #Validate port in inquirer when managing profiles
        if not re.match(regex, current):
            raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Pick a port between 1-65535, @profile o leave empty&#34;)
        try:
            port = int(current)
        except:
            port = 0
        if current != &#34;&#34; and not 1 &lt;= int(port) &lt;= 65535:
            raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Pick a port between 1-65535 or leave empty&#34;)
        return True

    def _port_validation(self, answers, current, regex = &#34;(^[0-9]*$|^@.+$)&#34;):
        #Validate port in inquirer when managing nodes
        if not re.match(regex, current):
            raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Pick a port between 1-65535, @profile or leave empty&#34;)
        try:
            port = int(current)
        except:
            port = 0
        if current.startswith(&#34;@&#34;):
            if current[1:] not in self.profiles:
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Profile {} don&#39;t exist&#34;.format(current))
        elif current != &#34;&#34; and not 1 &lt;= int(port) &lt;= 65535:
            raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Pick a port between 1-65535, @profile o leave empty&#34;)
        return True

    def _pass_validation(self, answers, current, regex = &#34;(^@.+$)&#34;):
        #Validate password in inquirer
        profiles = current.split(&#34;,&#34;)
        for i in profiles:
            if not re.match(regex, i) or i[1:] not in self.profiles:
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Profile {} don&#39;t exist&#34;.format(i))
        return True

    def _tags_validation(self, answers, current):
        #Validation for Tags in inquirer when managing nodes
        if current.startswith(&#34;@&#34;):
            if current[1:] not in self.profiles:
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Profile {} don&#39;t exist&#34;.format(current))
        elif current != &#34;&#34;:
            isdict = False
            try:
                isdict = ast.literal_eval(current)
            except:
                pass
            if not isinstance (isdict, dict):
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Tags should be a python dictionary.&#34;.format(current))
        return True

    def _profile_tags_validation(self, answers, current):
        #Validation for Tags in inquirer when managing profiles
        if current != &#34;&#34;:
            isdict = False
            try:
                isdict = ast.literal_eval(current)
            except:
                pass
            if not isinstance (isdict, dict):
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Tags should be a python dictionary.&#34;.format(current))
        return True

    def _jumphost_validation(self, answers, current):
        #Validation for Jumphost in inquirer when managing nodes
        if current.startswith(&#34;@&#34;):
            if current[1:] not in self.profiles:
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Profile {} don&#39;t exist&#34;.format(current))
        elif current != &#34;&#34;:
            if current not in self.nodes :
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Node {} don&#39;t exist.&#34;.format(current))
        return True

    def _profile_jumphost_validation(self, answers, current):
        #Validation for Jumphost in inquirer when managing profiles
        if current != &#34;&#34;:
            if current not in self.nodes :
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Node {} don&#39;t exist.&#34;.format(current))
        return True

    def _default_validation(self, answers, current):
        #Default validation type used in multiples questions in inquirer
        if current.startswith(&#34;@&#34;):
            if current[1:] not in self.profiles:
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Profile {} don&#39;t exist&#34;.format(current))
        return True

    def _bulk_node_validation(self, answers, current, regex = &#34;^[0-9a-zA-Z_.,$#-]+$&#34;):
        #Validation of nodes when running bulk command
        if not re.match(regex, current):
            raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Host cannot be empty&#34;)
        if current.startswith(&#34;@&#34;):
            if current[1:] not in self.profiles:
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Profile {} don&#39;t exist&#34;.format(current))
        return True

    def _bulk_folder_validation(self, answers, current):
        #Validation of folders when running bulk command
        if not self.case:
            current = current.lower()
        matches = list(filter(lambda k: k == current, self.folders))
        if current != &#34;&#34; and len(matches) == 0:
            raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Location {} don&#39;t exist&#34;.format(current))
        return True

    def _bulk_host_validation(self, answers, current, regex = &#34;^.+$&#34;):
        #Validate hostname when running bulk command
        if not re.match(regex, current):
            raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Host cannot be empty&#34;)
        if current.startswith(&#34;@&#34;):
            if current[1:] not in self.profiles:
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Profile {} don&#39;t exist&#34;.format(current))
        hosts = current.split(&#34;,&#34;)
        nodes = answers[&#34;ids&#34;].split(&#34;,&#34;)
        if len(hosts) &gt; 1 and len(hosts) != len(nodes):
                raise inquirer.errors.ValidationError(&#34;&#34;, reason=&#34;Hosts list should be the same length of nodes list&#34;)
        return True

    def _questions_edit(self):
        #Inquirer questions when editing nodes or profiles
        questions = []
        questions.append(inquirer.Confirm(&#34;host&#34;, message=&#34;Edit Hostname/IP?&#34;))
        questions.append(inquirer.Confirm(&#34;protocol&#34;, message=&#34;Edit Protocol?&#34;))
        questions.append(inquirer.Confirm(&#34;port&#34;, message=&#34;Edit Port?&#34;))
        questions.append(inquirer.Confirm(&#34;options&#34;, message=&#34;Edit Options?&#34;))
        questions.append(inquirer.Confirm(&#34;logs&#34;, message=&#34;Edit logging path/file?&#34;))
        questions.append(inquirer.Confirm(&#34;tags&#34;, message=&#34;Edit tags?&#34;))
        questions.append(inquirer.Confirm(&#34;jumphost&#34;, message=&#34;Edit jumphost?&#34;))
        questions.append(inquirer.Confirm(&#34;user&#34;, message=&#34;Edit User?&#34;))
        questions.append(inquirer.Confirm(&#34;password&#34;, message=&#34;Edit password?&#34;))
        answers = inquirer.prompt(questions)
        return answers

    def _questions_nodes(self, unique, uniques = None, edit = None):
        #Questions when adding or editing nodes
        try:
            defaults = self.config.getitem(unique)
            if &#34;tags&#34; not in defaults:
                defaults[&#34;tags&#34;] = &#34;&#34;
            if &#34;jumphost&#34; not in defaults:
                defaults[&#34;jumphost&#34;] = &#34;&#34;
        except:
            defaults = { &#34;host&#34;:&#34;&#34;, &#34;protocol&#34;:&#34;&#34;, &#34;port&#34;:&#34;&#34;, &#34;user&#34;:&#34;&#34;, &#34;options&#34;:&#34;&#34;, &#34;logs&#34;:&#34;&#34; , &#34;tags&#34;:&#34;&#34;, &#34;password&#34;:&#34;&#34;, &#34;jumphost&#34;:&#34;&#34;}
        node = {}
        if edit == None:
            edit = { &#34;host&#34;:True, &#34;protocol&#34;:True, &#34;port&#34;:True, &#34;user&#34;:True, &#34;password&#34;: True,&#34;options&#34;:True, &#34;logs&#34;:True, &#34;tags&#34;:True, &#34;jumphost&#34;:True }
        questions = []
        if edit[&#34;host&#34;]:
            questions.append(inquirer.Text(&#34;host&#34;, message=&#34;Add Hostname or IP&#34;, validate=self._host_validation, default=defaults[&#34;host&#34;]))
        else:
            node[&#34;host&#34;] = defaults[&#34;host&#34;]
        if edit[&#34;protocol&#34;]:
            questions.append(inquirer.Text(&#34;protocol&#34;, message=&#34;Select Protocol&#34;, validate=self._protocol_validation, default=defaults[&#34;protocol&#34;]))
        else:
            node[&#34;protocol&#34;] = defaults[&#34;protocol&#34;]
        if edit[&#34;port&#34;]:
            questions.append(inquirer.Text(&#34;port&#34;, message=&#34;Select Port Number&#34;, validate=self._port_validation, default=defaults[&#34;port&#34;]))
        else:
            node[&#34;port&#34;] = defaults[&#34;port&#34;]
        if edit[&#34;options&#34;]:
            questions.append(inquirer.Text(&#34;options&#34;, message=&#34;Pass extra options to protocol&#34;, validate=self._default_validation, default=defaults[&#34;options&#34;]))
        else:
            node[&#34;options&#34;] = defaults[&#34;options&#34;]
        if edit[&#34;logs&#34;]:
            questions.append(inquirer.Text(&#34;logs&#34;, message=&#34;Pick logging path/file &#34;,  validate=self._default_validation, default=defaults[&#34;logs&#34;].replace(&#34;{&#34;,&#34;{{&#34;).replace(&#34;}&#34;,&#34;}}&#34;)))
        else:
            node[&#34;logs&#34;] = defaults[&#34;logs&#34;]
        if edit[&#34;tags&#34;]:
            questions.append(inquirer.Text(&#34;tags&#34;, message=&#34;Add tags dictionary&#34;,  validate=self._tags_validation, default=str(defaults[&#34;tags&#34;]).replace(&#34;{&#34;,&#34;{{&#34;).replace(&#34;}&#34;,&#34;}}&#34;)))
        else:
            node[&#34;tags&#34;] = defaults[&#34;tags&#34;]
        if edit[&#34;jumphost&#34;]:
            questions.append(inquirer.Text(&#34;jumphost&#34;, message=&#34;Add Jumphost node&#34;,  validate=self._jumphost_validation, default=str(defaults[&#34;jumphost&#34;]).replace(&#34;{&#34;,&#34;{{&#34;).replace(&#34;}&#34;,&#34;}}&#34;)))
        else:
            node[&#34;jumphost&#34;] = defaults[&#34;jumphost&#34;]
        if edit[&#34;user&#34;]:
            questions.append(inquirer.Text(&#34;user&#34;, message=&#34;Pick username&#34;, validate=self._default_validation, default=defaults[&#34;user&#34;]))
        else:
            node[&#34;user&#34;] = defaults[&#34;user&#34;]
        if edit[&#34;password&#34;]:
            questions.append(inquirer.List(&#34;password&#34;, message=&#34;Password: Use a local password, no password or a list of profiles to reference?&#34;, choices=[&#34;Local Password&#34;, &#34;Profiles&#34;, &#34;No Password&#34;]))
        else:
            node[&#34;password&#34;] = defaults[&#34;password&#34;]
        answer = inquirer.prompt(questions)
        if answer == None:
            return False
        if &#34;password&#34; in answer.keys():
            if answer[&#34;password&#34;] == &#34;Local Password&#34;:
                passq = [inquirer.Password(&#34;password&#34;, message=&#34;Set Password&#34;)]
                passa = inquirer.prompt(passq)
                if passa == None:
                    return False
                answer[&#34;password&#34;] = self.encrypt(passa[&#34;password&#34;])
            elif answer[&#34;password&#34;] == &#34;Profiles&#34;:
                passq = [(inquirer.Text(&#34;password&#34;, message=&#34;Set a @profile or a comma separated list of @profiles&#34;, validate=self._pass_validation))]
                passa = inquirer.prompt(passq)
                if passa == None:
                    return False
                answer[&#34;password&#34;] = passa[&#34;password&#34;].split(&#34;,&#34;)
            elif answer[&#34;password&#34;] == &#34;No Password&#34;:
                answer[&#34;password&#34;] = &#34;&#34;
        if &#34;tags&#34; in answer.keys() and not answer[&#34;tags&#34;].startswith(&#34;@&#34;) and answer[&#34;tags&#34;]:
            answer[&#34;tags&#34;] = ast.literal_eval(answer[&#34;tags&#34;])
        result = {**uniques, **answer, **node}
        result[&#34;type&#34;] = &#34;connection&#34;
        return result

    def _questions_profiles(self, unique, edit = None):
        #Questions when adding or editing profiles
        try:
            defaults = self.config.profiles[unique]
            if &#34;tags&#34; not in defaults:
                defaults[&#34;tags&#34;] = &#34;&#34;
            if &#34;jumphost&#34; not in defaults:
                defaults[&#34;jumphost&#34;] = &#34;&#34;
        except:
            defaults = { &#34;host&#34;:&#34;&#34;, &#34;protocol&#34;:&#34;&#34;, &#34;port&#34;:&#34;&#34;, &#34;user&#34;:&#34;&#34;, &#34;options&#34;:&#34;&#34;, &#34;logs&#34;:&#34;&#34;, &#34;tags&#34;: &#34;&#34;, &#34;jumphost&#34;: &#34;&#34;}
        profile = {}
        if edit == None:
            edit = { &#34;host&#34;:True, &#34;protocol&#34;:True, &#34;port&#34;:True, &#34;user&#34;:True, &#34;password&#34;: True,&#34;options&#34;:True, &#34;logs&#34;:True, &#34;tags&#34;:True, &#34;jumphost&#34;:True }
        questions = []
        if edit[&#34;host&#34;]:
            questions.append(inquirer.Text(&#34;host&#34;, message=&#34;Add Hostname or IP&#34;, default=defaults[&#34;host&#34;]))
        else:
            profile[&#34;host&#34;] = defaults[&#34;host&#34;]
        if edit[&#34;protocol&#34;]:
            questions.append(inquirer.Text(&#34;protocol&#34;, message=&#34;Select Protocol&#34;, validate=self._profile_protocol_validation, default=defaults[&#34;protocol&#34;]))
        else:
            profile[&#34;protocol&#34;] = defaults[&#34;protocol&#34;]
        if edit[&#34;port&#34;]:
            questions.append(inquirer.Text(&#34;port&#34;, message=&#34;Select Port Number&#34;, validate=self._profile_port_validation, default=defaults[&#34;port&#34;]))
        else:
            profile[&#34;port&#34;] = defaults[&#34;port&#34;]
        if edit[&#34;options&#34;]:
            questions.append(inquirer.Text(&#34;options&#34;, message=&#34;Pass extra options to protocol&#34;, default=defaults[&#34;options&#34;]))
        else:
            profile[&#34;options&#34;] = defaults[&#34;options&#34;]
        if edit[&#34;logs&#34;]:
            questions.append(inquirer.Text(&#34;logs&#34;, message=&#34;Pick logging path/file &#34;, default=defaults[&#34;logs&#34;].replace(&#34;{&#34;,&#34;{{&#34;).replace(&#34;}&#34;,&#34;}}&#34;)))
        else:
            profile[&#34;logs&#34;] = defaults[&#34;logs&#34;]
        if edit[&#34;tags&#34;]:
            questions.append(inquirer.Text(&#34;tags&#34;, message=&#34;Add tags dictionary&#34;,  validate=self._profile_tags_validation, default=str(defaults[&#34;tags&#34;]).replace(&#34;{&#34;,&#34;{{&#34;).replace(&#34;}&#34;,&#34;}}&#34;)))
        else:
            profile[&#34;tags&#34;] = defaults[&#34;tags&#34;]
        if edit[&#34;jumphost&#34;]:
            questions.append(inquirer.Text(&#34;jumphost&#34;, message=&#34;Add Jumphost node&#34;,  validate=self._profile_jumphost_validation, default=str(defaults[&#34;jumphost&#34;]).replace(&#34;{&#34;,&#34;{{&#34;).replace(&#34;}&#34;,&#34;}}&#34;)))
        else:
            profile[&#34;jumphost&#34;] = defaults[&#34;jumphost&#34;]
        if edit[&#34;user&#34;]:
            questions.append(inquirer.Text(&#34;user&#34;, message=&#34;Pick username&#34;, default=defaults[&#34;user&#34;]))
        else:
            profile[&#34;user&#34;] = defaults[&#34;user&#34;]
        if edit[&#34;password&#34;]:
            questions.append(inquirer.Password(&#34;password&#34;, message=&#34;Set Password&#34;))
        else:
            profile[&#34;password&#34;] = defaults[&#34;password&#34;]
        answer = inquirer.prompt(questions)
        if answer == None:
            return False
        if &#34;password&#34; in answer.keys():
            if answer[&#34;password&#34;] != &#34;&#34;:
                answer[&#34;password&#34;] = self.encrypt(answer[&#34;password&#34;])
        if &#34;tags&#34; in answer.keys() and answer[&#34;tags&#34;]:
            answer[&#34;tags&#34;] = ast.literal_eval(answer[&#34;tags&#34;])
        result = {**answer, **profile}
        result[&#34;id&#34;] = unique
        return result

    def _questions_bulk(self):
        #Questions when using bulk command
        questions = []
        questions.append(inquirer.Text(&#34;ids&#34;, message=&#34;add a comma separated list of nodes to add&#34;, validate=self._bulk_node_validation))
        questions.append(inquirer.Text(&#34;location&#34;, message=&#34;Add a @folder, @subfolder@folder or leave empty&#34;, validate=self._bulk_folder_validation))
        questions.append(inquirer.Text(&#34;host&#34;, message=&#34;Add comma separated list of Hostnames or IPs&#34;, validate=self._bulk_host_validation))
        questions.append(inquirer.Text(&#34;protocol&#34;, message=&#34;Select Protocol&#34;, validate=self._protocol_validation))
        questions.append(inquirer.Text(&#34;port&#34;, message=&#34;Select Port Number&#34;, validate=self._port_validation))
        questions.append(inquirer.Text(&#34;options&#34;, message=&#34;Pass extra options to protocol&#34;, validate=self._default_validation))
        questions.append(inquirer.Text(&#34;logs&#34;, message=&#34;Pick logging path/file &#34;, validate=self._default_validation))
        questions.append(inquirer.Text(&#34;tags&#34;, message=&#34;Add tags dictionary&#34;,  validate=self._tags_validation))
        questions.append(inquirer.Text(&#34;jumphost&#34;, message=&#34;Add Jumphost node&#34;,  validate=self._jumphost_validation))
        questions.append(inquirer.Text(&#34;user&#34;, message=&#34;Pick username&#34;, validate=self._default_validation))
        questions.append(inquirer.List(&#34;password&#34;, message=&#34;Password: Use a local password, no password or a list of profiles to reference?&#34;, choices=[&#34;Local Password&#34;, &#34;Profiles&#34;, &#34;No Password&#34;]))
        answer = inquirer.prompt(questions)
        if answer == None:
            return False
        if &#34;password&#34; in answer.keys():
            if answer[&#34;password&#34;] == &#34;Local Password&#34;:
                passq = [inquirer.Password(&#34;password&#34;, message=&#34;Set Password&#34;)]
                passa = inquirer.prompt(passq)
                answer[&#34;password&#34;] = self.encrypt(passa[&#34;password&#34;])
            elif answer[&#34;password&#34;] == &#34;Profiles&#34;:
                passq = [(inquirer.Text(&#34;password&#34;, message=&#34;Set a @profile or a comma separated list of @profiles&#34;, validate=self._pass_validation))]
                passa = inquirer.prompt(passq)
                answer[&#34;password&#34;] = passa[&#34;password&#34;].split(&#34;,&#34;)
            elif answer[&#34;password&#34;] == &#34;No Password&#34;:
                answer[&#34;password&#34;] = &#34;&#34;
        answer[&#34;type&#34;] = &#34;connection&#34;
        if &#34;tags&#34; in answer.keys() and not answer[&#34;tags&#34;].startswith(&#34;@&#34;) and answer[&#34;tags&#34;]:
            answer[&#34;tags&#34;] = ast.literal_eval(answer[&#34;tags&#34;])
        return answer

    def _type_node(self, arg_value, pat=re.compile(r&#34;^[0-9a-zA-Z_.$@#-]+$&#34;)):
        if arg_value == None:
            raise ValueError(&#34;Missing argument node&#34;)
        if not pat.match(arg_value):
            raise ValueError(f&#34;Argument error: {arg_value}&#34;)
        return arg_value
    
    def _type_profile(self, arg_value, pat=re.compile(r&#34;^[0-9a-zA-Z_.$#-]+$&#34;)):
        if not pat.match(arg_value):
            raise ValueError
        return arg_value

    def _help(self, type, parsers = None):
        #Store text for help and other commands
        if type == &#34;node&#34;:
            return &#34;node[@subfolder][@folder]\nConnect to specific node or show all matching nodes\n[@subfolder][@folder]\nShow all available connections globally or in specified path&#34;
        if type == &#34;usage&#34;:
            commands = []
            for subcommand, subparser in parsers.choices.items():
                if subparser.description != None:
                    commands.append(subcommand)
            commands = &#34;,&#34;.join(commands)
            usage_help = f&#34;conn [-h] [--add | --del | --mod | --show | --debug] [node|folder] [--sftp]\n       conn {{{commands}}} ...&#34;
            return usage_help
        if type == &#34;end&#34;:
            help_dict = {}
            for subcommand, subparser in parsers.choices.items():
                if subparser.description == None and help_dict:
                    previous_key = next(reversed(help_dict.keys()))
                    help_dict[f&#34;{previous_key}({subcommand})&#34;] = help_dict.pop(previous_key)
                else:
                    help_dict[subcommand] = subparser.description
                subparser.description = None
            commands_help = &#34;Commands:\n&#34;
            commands_help += &#34;\n&#34;.join([f&#34;  {cmd:&lt;15} {help_text}&#34; for cmd, help_text in help_dict.items() if help_text != None])
            return commands_help
        if type == &#34;bashcompletion&#34;:
            return &#39;&#39;&#39;
#Here starts bash completion for conn
_conn()
{
        mapfile -t strings &lt; &lt;(connpy-completion-helper &#34;bash&#34; &#34;${#COMP_WORDS[@]}&#34; &#34;${COMP_WORDS[@]}&#34;)
        local IFS=$&#39;\t\n&#39;
        local home_dir=$(eval echo ~)
        local last_word=${COMP_WORDS[-1]/\~/$home_dir}
        COMPREPLY=($(compgen -W &#34;$(printf &#39;%s&#39; &#34;${strings[@]}&#34;)&#34; -- &#34;$last_word&#34;))
        if [ &#34;$last_word&#34; != &#34;${COMP_WORDS[-1]}&#34; ]; then
            COMPREPLY=(${COMPREPLY[@]/$home_dir/\~})
        fi
}

complete -o nospace -o nosort -F _conn conn
complete -o nospace -o nosort -F _conn connpy
#Here ends bash completion for conn
        &#39;&#39;&#39;
        if type == &#34;zshcompletion&#34;:
            return &#39;&#39;&#39;
#Here starts zsh completion for conn
autoload -U compinit &amp;&amp; compinit
_conn()
{
    local home_dir=$(eval echo ~)
    last_word=${words[-1]/\~/$home_dir}
    strings=($(connpy-completion-helper &#34;zsh&#34; ${#words} $words[1,-2] $last_word))
    for string in &#34;${strings[@]}&#34;; do
        #Replace the expanded home directory with ~
        if [ &#34;$last_word&#34; != &#34;$words[-1]&#34; ]; then
            string=${string/$home_dir/\~}
        fi
        if [[ &#34;${string}&#34; =~ .*/$ ]]; then
            # If the string ends with a &#39;/&#39;, do not append a space
            compadd -Q -S &#39;&#39; -- &#34;$string&#34;
        else
            # If the string does not end with a &#39;/&#39;, append a space
            compadd -Q -S &#39; &#39; -- &#34;$string&#34;
        fi
    done
}
compdef _conn conn
compdef _conn connpy
#Here ends zsh completion for conn
            &#39;&#39;&#39;
        if type == &#34;run&#34;:
            return &#34;node[@subfolder][@folder] commmand to run\nRun the specific command on the node and print output\n/path/to/file.yaml\nUse a yaml file to run an automation script&#34;
        if type == &#34;generate&#34;:
            return &#39;&#39;&#39;---
tasks:
- name: &#34;Config&#34;

  action: &#39;run&#39; #Action can be test or run. Mandatory

  nodes: #List of nodes to work on. Mandatory
  - &#39;router1@office&#39; #You can add specific nodes
  - &#39;@aws&#39;  #entire folders or subfolders
  - &#39;@office&#39;:   #or filter inside a folder or subfolder
    - &#39;router2&#39;
    - &#39;router7&#39;

  commands: #List of commands to send, use {name} to pass variables
  - &#39;term len 0&#39;
  - &#39;conf t&#39;
  - &#39;interface {if}&#39;
  - &#39;ip address 10.100.100.{id} 255.255.255.255&#39;
  - &#39;{commit}&#39;
  - &#39;end&#39;

  variables: #Variables to use on commands and expected. Optional
    __global__: #Global variables to use on all nodes, fallback if missing in the node.
      commit: &#39;&#39;
      if: &#39;loopback100&#39;
    router1@office:
      id: 1
    router2@office:
      id: 2
      commit: &#39;commit&#39;
    router3@office:
      id: 3
    vrouter1@aws:
      id: 4
    vrouterN@aws:
      id: 5
  
  output: /home/user/logs #Type of output, if null you only get Connection and test result. Choices are: null,stdout,/path/to/folder. Folder path only works on &#39;run&#39; action.
  
  options:
    prompt: r&#39;&gt;$|#$|\$$|&gt;.$|#.$|\$.$&#39; #Optional prompt to check on your devices, default should work on most devices.
    parallel: 10 #Optional number of nodes to run commands on parallel. Default 10.
    timeout: 20 #Optional time to wait in seconds for prompt, expected or EOF. Default 20. 

- name: &#34;TestConfig&#34;
  action: &#39;test&#39;
  nodes:
  - &#39;router1@office&#39;
  - &#39;@aws&#39;
  - &#39;@office&#39;:
    - &#39;router2&#39;
    - &#39;router7&#39;
  commands:
  - &#39;ping 10.100.100.{id}&#39;
  expected: &#39;!&#39; #Expected text to find when running test action. Mandatory for &#39;test&#39;
  variables:
    router1@office:
      id: 1
    router2@office:
      id: 2
      commit: &#39;commit&#39;
    router3@office:
      id: 3
    vrouter1@aws:
      id: 4
    vrouterN@aws:
      id: 5
  output: null
...&#39;&#39;&#39;

    def encrypt(self, password, keyfile=None):
        &#39;&#39;&#39;
        Encrypts password using RSA keyfile

        ### Parameters:  

            - password (str): Plaintext password to encrypt.

        ### Optional Parameters:  

            - keyfile  (str): Path/file to keyfile. Default is config keyfile.
                              

        ### Returns:  

            str: Encrypted password.

        &#39;&#39;&#39;
        if keyfile is None:
            keyfile = self.config.key
        with open(keyfile) as f:
            key = RSA.import_key(f.read())
            f.close()
        publickey = key.publickey()
        encryptor = PKCS1_OAEP.new(publickey)
        password = encryptor.encrypt(password.encode(&#34;utf-8&#34;))
        return str(password)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="connpy.connapp.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>self, password, keyfile=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypts password using RSA keyfile</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- password (str): Plaintext password to encrypt.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- keyfile  (str): Path/file to keyfile. Default is config keyfile.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>str: Encrypted password.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt(self, password, keyfile=None):
    &#39;&#39;&#39;
    Encrypts password using RSA keyfile

    ### Parameters:  

        - password (str): Plaintext password to encrypt.

    ### Optional Parameters:  

        - keyfile  (str): Path/file to keyfile. Default is config keyfile.
                          

    ### Returns:  

        str: Encrypted password.

    &#39;&#39;&#39;
    if keyfile is None:
        keyfile = self.config.key
    with open(keyfile) as f:
        key = RSA.import_key(f.read())
        f.close()
    publickey = key.publickey()
    encryptor = PKCS1_OAEP.new(publickey)
    password = encryptor.encrypt(password.encode(&#34;utf-8&#34;))
    return str(password)</code></pre>
</details>
</dd>
<dt id="connpy.connapp.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self, argv=['--html', 'connpy', '-o', 'docs', '--force'])</span>
</code></dt>
<dd>
<div class="desc"><h3 id="parameters">Parameters:</h3>
<pre><code>- argv (list): List of arguments to pass to the app.
               Default: sys.argv[1:]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self,argv = sys.argv[1:]):
    &#39;&#39;&#39; 
        
    ### Parameters:  

        - argv (list): List of arguments to pass to the app.
                       Default: sys.argv[1:]

    &#39;&#39;&#39; 
    #DEFAULTPARSER
    defaultparser = argparse.ArgumentParser(prog = &#34;conn&#34;, description = &#34;SSH and Telnet connection manager&#34;, formatter_class=argparse.RawTextHelpFormatter)
    subparsers = defaultparser.add_subparsers(title=&#34;Commands&#34;, dest=&#34;subcommand&#34;)
    #NODEPARSER
    nodeparser = subparsers.add_parser(&#34;node&#34;, formatter_class=argparse.RawTextHelpFormatter) 
    nodecrud = nodeparser.add_mutually_exclusive_group()
    nodeparser.add_argument(&#34;node&#34;, metavar=&#34;node|folder&#34;, nargs=&#39;?&#39;, default=None, action=self._store_type, help=self._help(&#34;node&#34;))
    nodecrud.add_argument(&#34;-v&#34;,&#34;--version&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Show version&#34;, const=&#34;version&#34;, default=&#34;connect&#34;)
    nodecrud.add_argument(&#34;-a&#34;,&#34;--add&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Add new node[@subfolder][@folder] or [@subfolder]@folder&#34;, const=&#34;add&#34;, default=&#34;connect&#34;)
    nodecrud.add_argument(&#34;-r&#34;,&#34;--del&#34;, &#34;--rm&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Delete node[@subfolder][@folder] or [@subfolder]@folder&#34;, const=&#34;del&#34;, default=&#34;connect&#34;)
    nodecrud.add_argument(&#34;-e&#34;,&#34;--mod&#34;, &#34;--edit&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Modify node[@subfolder][@folder]&#34;, const=&#34;mod&#34;, default=&#34;connect&#34;)
    nodecrud.add_argument(&#34;-s&#34;,&#34;--show&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Show node[@subfolder][@folder]&#34;, const=&#34;show&#34;, default=&#34;connect&#34;)
    nodecrud.add_argument(&#34;-d&#34;,&#34;--debug&#34;, dest=&#34;debug&#34;, action=&#34;store_true&#34;, help=&#34;Display all conections steps&#34;)
    nodeparser.add_argument(&#34;-t&#34;,&#34;--sftp&#34;, dest=&#34;sftp&#34;, action=&#34;store_true&#34;, help=&#34;Connects using sftp instead of ssh&#34;)
    nodeparser.set_defaults(func=self._func_node)
    #PROFILEPARSER
    profileparser = subparsers.add_parser(&#34;profile&#34;, description=&#34;Manage profiles&#34;) 
    profileparser.add_argument(&#34;profile&#34;, nargs=1, action=self._store_type, type=self._type_profile, help=&#34;Name of profile to manage&#34;)
    profilecrud = profileparser.add_mutually_exclusive_group(required=True)
    profilecrud.add_argument(&#34;-a&#34;, &#34;--add&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Add new profile&#34;, const=&#34;add&#34;)
    profilecrud.add_argument(&#34;-r&#34;, &#34;--del&#34;, &#34;--rm&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Delete profile&#34;, const=&#34;del&#34;)
    profilecrud.add_argument(&#34;-e&#34;, &#34;--mod&#34;, &#34;--edit&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Modify profile&#34;, const=&#34;mod&#34;)
    profilecrud.add_argument(&#34;-s&#34;, &#34;--show&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Show profile&#34;, const=&#34;show&#34;)
    profileparser.set_defaults(func=self._func_profile)
    #MOVEPARSER
    moveparser = subparsers.add_parser(&#34;move&#34;, aliases=[&#34;mv&#34;], description=&#34;Move node&#34;) 
    moveparser.add_argument(&#34;move&#34;, nargs=2, action=self._store_type, help=&#34;Move node[@subfolder][@folder] dest_node[@subfolder][@folder]&#34;, default=&#34;move&#34;, type=self._type_node)
    moveparser.set_defaults(func=self._func_others)
    #COPYPARSER
    copyparser = subparsers.add_parser(&#34;copy&#34;, aliases=[&#34;cp&#34;], description=&#34;Copy node&#34;) 
    copyparser.add_argument(&#34;cp&#34;, nargs=2, action=self._store_type, help=&#34;Copy node[@subfolder][@folder] new_node[@subfolder][@folder]&#34;, default=&#34;cp&#34;, type=self._type_node)
    copyparser.set_defaults(func=self._func_others)
    #LISTPARSER
    lsparser = subparsers.add_parser(&#34;list&#34;, aliases=[&#34;ls&#34;], description=&#34;List profiles, nodes or folders&#34;) 
    lsparser.add_argument(&#34;ls&#34;, action=self._store_type, choices=[&#34;profiles&#34;,&#34;nodes&#34;,&#34;folders&#34;], help=&#34;List profiles, nodes or folders&#34;, default=False)
    lsparser.add_argument(&#34;--filter&#34;, nargs=1, help=&#34;Filter results&#34;)
    lsparser.add_argument(&#34;--format&#34;, nargs=1, help=&#34;Format of the output of nodes using {name}, {NAME}, {location}, {LOCATION}, {host} and {HOST}&#34;)
    lsparser.set_defaults(func=self._func_others)
    #BULKPARSER
    bulkparser = subparsers.add_parser(&#34;bulk&#34;, description=&#34;Add nodes in bulk&#34;) 
    bulkparser.add_argument(&#34;bulk&#34;, const=&#34;bulk&#34;, nargs=0, action=self._store_type, help=&#34;Add nodes in bulk&#34;)
    bulkparser.set_defaults(func=self._func_others)
    # EXPORTPARSER
    exportparser = subparsers.add_parser(&#34;export&#34;, description=&#34;Export connection folder to Yaml file&#34;) 
    exportparser.add_argument(&#34;export&#34;, nargs=&#34;+&#34;, action=self._store_type, help=&#34;Export /path/to/file.yml [@subfolder1][@folder1] [@subfolderN][@folderN]&#34;)
    exportparser.set_defaults(func=self._func_export)
    # IMPORTPARSER
    importparser = subparsers.add_parser(&#34;import&#34;, description=&#34;Import connection folder to config from Yaml file&#34;) 
    importparser.add_argument(&#34;file&#34;, nargs=1, action=self._store_type, help=&#34;Import /path/to/file.yml&#34;)
    importparser.set_defaults(func=self._func_import)
    # AIPARSER
    aiparser = subparsers.add_parser(&#34;ai&#34;, description=&#34;Make request to an AI&#34;) 
    aiparser.add_argument(&#34;ask&#34;, nargs=&#39;*&#39;, help=&#34;Ask connpy AI something&#34;)
    aiparser.add_argument(&#34;--model&#34;, nargs=1, help=&#34;Set the OPENAI model id&#34;)
    aiparser.add_argument(&#34;--org&#34;, nargs=1, help=&#34;Set the OPENAI organization id&#34;)
    aiparser.add_argument(&#34;--api_key&#34;, nargs=1, help=&#34;Set the OPENAI API key&#34;)
    aiparser.set_defaults(func=self._func_ai)
    #RUNPARSER
    runparser = subparsers.add_parser(&#34;run&#34;, description=&#34;Run scripts or commands on nodes&#34;, formatter_class=argparse.RawTextHelpFormatter) 
    runparser.add_argument(&#34;run&#34;, nargs=&#39;+&#39;, action=self._store_type, help=self._help(&#34;run&#34;), default=&#34;run&#34;)
    runparser.add_argument(&#34;-g&#34;,&#34;--generate&#34;, dest=&#34;action&#34;, action=&#34;store_const&#34;, help=&#34;Generate yaml file template&#34;, const=&#34;generate&#34;, default=&#34;run&#34;)
    runparser.set_defaults(func=self._func_run)
    #APIPARSER
    apiparser = subparsers.add_parser(&#34;api&#34;, description=&#34;Start and stop connpy api&#34;) 
    apicrud = apiparser.add_mutually_exclusive_group(required=True)
    apicrud.add_argument(&#34;-s&#34;,&#34;--start&#34;, dest=&#34;start&#34;, nargs=&#34;?&#34;, action=self._store_type, help=&#34;Start conppy api&#34;, type=int, default=8048, metavar=&#34;PORT&#34;)
    apicrud.add_argument(&#34;-r&#34;,&#34;--restart&#34;, dest=&#34;restart&#34;, nargs=0, action=self._store_type, help=&#34;Restart conppy api&#34;)
    apicrud.add_argument(&#34;-x&#34;,&#34;--stop&#34;, dest=&#34;stop&#34;, nargs=0, action=self._store_type, help=&#34;Stop conppy api&#34;)
    apicrud.add_argument(&#34;-d&#34;, &#34;--debug&#34;, dest=&#34;debug&#34;, nargs=&#34;?&#34;, action=self._store_type, help=&#34;Run connpy server on debug mode&#34;, type=int, default=8048, metavar=&#34;PORT&#34;)
    apiparser.set_defaults(func=self._func_api)
    #PLUGINSPARSER
    pluginparser = subparsers.add_parser(&#34;plugin&#34;, description=&#34;Manage plugins&#34;) 
    plugincrud = pluginparser.add_mutually_exclusive_group(required=True)
    plugincrud.add_argument(&#34;--add&#34;, metavar=(&#34;PLUGIN&#34;, &#34;FILE&#34;), nargs=2, help=&#34;Add new plugin&#34;)
    plugincrud.add_argument(&#34;--del&#34;, dest=&#34;delete&#34;, metavar=&#34;PLUGIN&#34;, nargs=1, help=&#34;Delete plugin&#34;)
    plugincrud.add_argument(&#34;--enable&#34;, metavar=&#34;PLUGIN&#34;, nargs=1, help=&#34;Enable plugin&#34;)
    plugincrud.add_argument(&#34;--disable&#34;, metavar=&#34;PLUGIN&#34;, nargs=1, help=&#34;Disable plugin&#34;)
    plugincrud.add_argument(&#34;--list&#34;, dest=&#34;list&#34;, action=&#34;store_true&#34;, help=&#34;Disable plugin&#34;)
    pluginparser.set_defaults(func=self._func_plugin)
    #CONFIGPARSER
    configparser = subparsers.add_parser(&#34;config&#34;, description=&#34;Manage app config&#34;) 
    configcrud = configparser.add_mutually_exclusive_group(required=True)
    configcrud.add_argument(&#34;--allow-uppercase&#34;, dest=&#34;case&#34;, nargs=1, action=self._store_type, help=&#34;Allow case sensitive names&#34;, choices=[&#34;true&#34;,&#34;false&#34;])
    configcrud.add_argument(&#34;--fzf&#34;, dest=&#34;fzf&#34;, nargs=1, action=self._store_type, help=&#34;Use fzf for lists&#34;, choices=[&#34;true&#34;,&#34;false&#34;])
    configcrud.add_argument(&#34;--keepalive&#34;, dest=&#34;idletime&#34;, nargs=1, action=self._store_type, help=&#34;Set keepalive time in seconds, 0 to disable&#34;, type=int, metavar=&#34;INT&#34;)
    configcrud.add_argument(&#34;--completion&#34;, dest=&#34;completion&#34;, nargs=1, choices=[&#34;bash&#34;,&#34;zsh&#34;], action=self._store_type, help=&#34;Get terminal completion configuration for conn&#34;)
    configcrud.add_argument(&#34;--configfolder&#34;, dest=&#34;configfolder&#34;, nargs=1, action=self._store_type, help=&#34;Set the default location for config file&#34;, metavar=&#34;FOLDER&#34;)
    configcrud.add_argument(&#34;--openai-org&#34;, dest=&#34;organization&#34;, nargs=1, action=self._store_type, help=&#34;Set openai organization&#34;, metavar=&#34;ORGANIZATION&#34;)
    configcrud.add_argument(&#34;--openai-api-key&#34;, dest=&#34;api_key&#34;, nargs=1, action=self._store_type, help=&#34;Set openai api_key&#34;, metavar=&#34;API_KEY&#34;)
    configcrud.add_argument(&#34;--openai-model&#34;, dest=&#34;model&#34;, nargs=1, action=self._store_type, help=&#34;Set openai model&#34;, metavar=&#34;MODEL&#34;)
    configparser.set_defaults(func=self._func_others)
    #Add plugins
    file_path = self.config.defaultdir + &#34;/plugins&#34;
    self.plugins = Plugins()
    self.plugins._import_plugins_to_argparse(file_path, subparsers)
    #Generate helps
    nodeparser.usage = self._help(&#34;usage&#34;, subparsers)
    nodeparser.epilog = self._help(&#34;end&#34;, subparsers)
    nodeparser.help = self._help(&#34;node&#34;)
    #Manage sys arguments
    self.commands = list(subparsers.choices.keys())
    profilecmds = []
    for action in profileparser._actions:
        profilecmds.extend(action.option_strings)
    if len(argv) &gt;= 2 and argv[1] == &#34;profile&#34; and argv[0] in profilecmds:
        argv[1] = argv[0]
        argv[0] = &#34;profile&#34;
    if len(argv) &lt; 1 or argv[0] not in self.commands:
        argv.insert(0,&#34;node&#34;)
    args = defaultparser.parse_args(argv)
    if args.subcommand in self.plugins.plugins:
        self.plugins.plugins[args.subcommand].Entrypoint(args, self.plugins.plugin_parsers[args.subcommand].parser, self)
    else:
        return args.func(args)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="connpy.node"><code class="flex name class">
<span>class <span class="ident">node</span></span>
<span>(</span><span>unique, host, options='', logs='', password='', port='', protocol='', user='', config='', tags='', jumphost='')</span>
</code></dt>
<dd>
<div class="desc"><p>This class generates a node object. Containts all the information and methods to connect and interact with a device using ssh or telnet.</p>
<h3 id="attributes">Attributes:</h3>
<pre><code>- output (str): Output of the commands you ran with run or test 
                method.

- result(bool): True if expected value is found after running 
                the commands using test method.

- status (int): 0 if the method run or test run succesfully.
                1 if connection failed.
                2 if expect timeouts without prompt or EOF.
</code></pre>
<h3 id="parameters">Parameters:</h3>
<pre><code>- unique (str): Unique name to assign to the node.

- host   (str): IP address or hostname of the node.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- options  (str): Additional options to pass the ssh/telnet for
                  connection.

- logs     (str): Path/file for storing the logs. You can use 
                  ${unique},${host}, ${port}, ${user}, ${protocol} 
                  as variables.

- password (str): Encrypted or plaintext password.

- port     (str): Port to connect to node, default 22 for ssh and 23 
                  for telnet.

- protocol (str): Select ssh or telnet. Default is ssh.

- user     (str): Username to of the node.

- config   (obj): Pass the object created with class configfile with 
                  key for decryption and extra configuration if you 
                  are using connection manager.

- tags   (dict) : Tags useful for automation and personal porpuse
                  like "os", "prompt" and "screenleght_command"

- jumphost (str): Reference another node to be used as a jumphost
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class node:
    &#39;&#39;&#39; This class generates a node object. Containts all the information and methods to connect and interact with a device using ssh or telnet.

    ### Attributes:  

        - output (str): Output of the commands you ran with run or test 
                        method.  

        - result(bool): True if expected value is found after running 
                        the commands using test method.

        - status (int): 0 if the method run or test run succesfully.
                        1 if connection failed.
                        2 if expect timeouts without prompt or EOF.

        &#39;&#39;&#39;
    
    def __init__(self, unique, host, options=&#39;&#39;, logs=&#39;&#39;, password=&#39;&#39;, port=&#39;&#39;, protocol=&#39;&#39;, user=&#39;&#39;, config=&#39;&#39;, tags=&#39;&#39;, jumphost=&#39;&#39;):
        &#39;&#39;&#39; 
            
        ### Parameters:  

            - unique (str): Unique name to assign to the node.

            - host   (str): IP address or hostname of the node.

        ### Optional Parameters:  

            - options  (str): Additional options to pass the ssh/telnet for
                              connection.  

            - logs     (str): Path/file for storing the logs. You can use 
                              ${unique},${host}, ${port}, ${user}, ${protocol} 
                              as variables.  

            - password (str): Encrypted or plaintext password.  

            - port     (str): Port to connect to node, default 22 for ssh and 23 
                              for telnet.  

            - protocol (str): Select ssh or telnet. Default is ssh.  

            - user     (str): Username to of the node.  

            - config   (obj): Pass the object created with class configfile with 
                              key for decryption and extra configuration if you 
                              are using connection manager.  

            - tags   (dict) : Tags useful for automation and personal porpuse
                              like &#34;os&#34;, &#34;prompt&#34; and &#34;screenleght_command&#34;
                              
            - jumphost (str): Reference another node to be used as a jumphost
        &#39;&#39;&#39;
        if config == &#39;&#39;:
            self.idletime = 0
            self.key = None
        else:
            self.idletime = config.config[&#34;idletime&#34;]
            self.key = config.key
        self.unique = unique
        attr = {&#34;host&#34;: host, &#34;logs&#34;: logs, &#34;options&#34;:options, &#34;port&#34;: port, &#34;protocol&#34;: protocol, &#34;user&#34;: user, &#34;tags&#34;: tags, &#34;jumphost&#34;: jumphost}
        for key in attr:
            profile = re.search(&#34;^@(.*)&#34;, str(attr[key]))
            if profile and config != &#39;&#39;:
                try:
                    setattr(self,key,config.profiles[profile.group(1)][key])
                except:
                    setattr(self,key,&#34;&#34;)
            elif attr[key] == &#39;&#39; and key == &#34;protocol&#34;:
                try:
                    setattr(self,key,config.profiles[&#34;default&#34;][key])
                except:
                    setattr(self,key,&#34;ssh&#34;)
            else: 
                setattr(self,key,attr[key])
        if isinstance(password,list):
            self.password = []
            for i, s in enumerate(password):
                profile = re.search(&#34;^@(.*)&#34;, password[i])
                if profile and config != &#39;&#39;:
                    self.password.append(config.profiles[profile.group(1)][&#34;password&#34;])
        else:
            self.password = [password]
        if self.jumphost != &#34;&#34; and config != &#39;&#39;:
            self.jumphost = config.getitem(self.jumphost)
            for key in self.jumphost:
                profile = re.search(&#34;^@(.*)&#34;, str(self.jumphost[key]))
                if profile:
                    try:
                        self.jumphost[key] = config.profiles[profile.group(1)][key]
                    except:
                        self.jumphost[key] = &#34;&#34;
                elif self.jumphost[key] == &#39;&#39; and key == &#34;protocol&#34;:
                    try:
                        self.jumphost[key] = config.profiles[&#34;default&#34;][key]
                    except:
                        self.jumphost[key] = &#34;ssh&#34;
            if isinstance(self.jumphost[&#34;password&#34;],list):
                jumphost_password = []
                for i, s in enumerate(self.jumphost[&#34;password&#34;]):
                    profile = re.search(&#34;^@(.*)&#34;, self.jumphost[&#34;password&#34;][i])
                    if profile:
                        jumphost_password.append(config.profiles[profile.group(1)][&#34;password&#34;])
                self.jumphost[&#34;password&#34;] = jumphost_password
            else:
                self.jumphost[&#34;password&#34;] = [self.jumphost[&#34;password&#34;]]
            if self.jumphost[&#34;password&#34;] != [&#34;&#34;]:
                self.password = self.jumphost[&#34;password&#34;] + self.password

            if self.jumphost[&#34;protocol&#34;] == &#34;ssh&#34;:
                jumphost_cmd = self.jumphost[&#34;protocol&#34;] + &#34; -W %h:%p&#34;
                if self.jumphost[&#34;port&#34;] != &#39;&#39;:
                    jumphost_cmd = jumphost_cmd + &#34; -p &#34; + self.jumphost[&#34;port&#34;]
                if self.jumphost[&#34;options&#34;] != &#39;&#39;:
                    jumphost_cmd = jumphost_cmd + &#34; &#34; + self.jumphost[&#34;options&#34;]
                if self.jumphost[&#34;user&#34;] == &#39;&#39;:
                    jumphost_cmd = jumphost_cmd + &#34; {}&#34;.format(self.jumphost[&#34;host&#34;])
                else:
                    jumphost_cmd = jumphost_cmd + &#34; {}&#34;.format(&#34;@&#34;.join([self.jumphost[&#34;user&#34;],self.jumphost[&#34;host&#34;]]))
                self.jumphost = f&#34;-o ProxyCommand=\&#34;{jumphost_cmd}\&#34;&#34;
            else:
                self.jumphost = &#34;&#34;

    def _passtx(self, passwords, *, keyfile=None):
        # decrypts passwords, used by other methdos.
        dpass = []
        if keyfile is None:
            keyfile = self.key
        if keyfile is not None:
            with open(keyfile) as f:
                key = RSA.import_key(f.read())
            decryptor = PKCS1_OAEP.new(key)
        for passwd in passwords:
            if not re.match(&#39;^b[\&#34;\&#39;].+[\&#34;\&#39;]$&#39;, passwd):
                dpass.append(passwd)
            else:
                try:
                    decrypted = decryptor.decrypt(ast.literal_eval(passwd)).decode(&#34;utf-8&#34;)
                    dpass.append(decrypted)
                except:
                    raise ValueError(&#34;Missing or corrupted key&#34;)
        return dpass

    

    def _logfile(self, logfile = None):
        # translate logs variables and generate logs path.
        if logfile == None:
            logfile = self.logs
        logfile = logfile.replace(&#34;${unique}&#34;, self.unique)
        logfile = logfile.replace(&#34;${host}&#34;, self.host)
        logfile = logfile.replace(&#34;${port}&#34;, self.port)
        logfile = logfile.replace(&#34;${user}&#34;, self.user)
        logfile = logfile.replace(&#34;${protocol}&#34;, self.protocol)
        now = datetime.datetime.now()
        dateconf = re.search(r&#39;\$\{date \&#39;(.*)\&#39;}&#39;, logfile)
        if dateconf:
            logfile = re.sub(r&#39;\$\{date (.*)}&#39;,now.strftime(dateconf.group(1)), logfile)
        return logfile

    def _logclean(self, logfile, var = False):
        #Remove special ascii characters and other stuff from logfile.
        if var == False:
            t = open(logfile, &#34;r&#34;).read()
        else:
            t = logfile
        while t.find(&#34;\b&#34;) != -1:
            t = re.sub(&#39;[^\b]\b&#39;, &#39;&#39;, t)
        t = t.replace(&#34;\n&#34;,&#34;&#34;,1)
        t = t.replace(&#34;\a&#34;,&#34;&#34;)
        t = t.replace(&#39;\n\n&#39;, &#39;\n&#39;)
        t = re.sub(r&#39;.\[K&#39;, &#39;&#39;, t)
        ansi_escape = re.compile(r&#39;\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/ ]*[@-~])&#39;)
        t = ansi_escape.sub(&#39;&#39;, t)
        t = t.lstrip(&#34; \n\r&#34;)
        t = t.replace(&#34;\r&#34;,&#34;&#34;)
        t = t.replace(&#34;\x0E&#34;,&#34;&#34;)
        t = t.replace(&#34;\x0F&#34;,&#34;&#34;)
        if var == False:
            d = open(logfile, &#34;w&#34;)
            d.write(t)
            d.close()
            return
        else:
            return t

    def _savelog(self):
        &#39;&#39;&#39;Save the log buffer to the file at regular intervals if there are changes.&#39;&#39;&#39;
        t = threading.current_thread()
        prev_size = 0  # Store the previous size of the buffer

        while getattr(t, &#34;do_run&#34;, True):  # Check if thread is signaled to stop
            current_size = self.mylog.tell()  # Current size of the buffer

            # Only save if the buffer size has changed
            if current_size != prev_size:
                with open(self.logfile, &#34;w&#34;) as f:  # Use &#34;w&#34; to overwrite the file
                    f.write(self._logclean(self.mylog.getvalue().decode(), True))
                prev_size = current_size  # Update the previous size
            sleep(5)

    def _filter(self, a):
        #Set time for last input when using interact
        self.lastinput = time()
        return a

    def _keepalive(self):
        #Send keepalive ctrl+e when idletime passed without new inputs on interact
        self.lastinput = time()
        t = threading.current_thread()
        while True:
            if time() - self.lastinput &gt;= self.idletime:
                self.child.sendcontrol(&#34;e&#34;)
                self.lastinput = time()
            sleep(1)


    def interact(self, debug = False):
        &#39;&#39;&#39;
        Allow user to interact with the node directly, mostly used by connection manager.

        ### Optional Parameters:  

            - debug (bool): If True, display all the connecting information 
                            before interact. Default False.  
        &#39;&#39;&#39;
        connect = self._connect(debug = debug)
        if connect == True:
            size = re.search(&#39;columns=([0-9]+).*lines=([0-9]+)&#39;,str(os.get_terminal_size()))
            self.child.setwinsize(int(size.group(2)),int(size.group(1)))
            print(&#34;Connected to &#34; + self.unique + &#34; at &#34; + self.host + (&#34;:&#34; if self.port != &#39;&#39; else &#39;&#39;) + self.port + &#34; via: &#34; + self.protocol)
            if &#39;logfile&#39; in dir(self):
                # Initialize self.mylog
                if not &#39;mylog&#39; in dir(self):
                    self.mylog = io.BytesIO()
                self.child.logfile_read = self.mylog
                
                # Start the _savelog thread
                log_thread = threading.Thread(target=self._savelog)
                log_thread.daemon = True
                log_thread.start()
            if &#39;missingtext&#39; in dir(self):
                print(self.child.after.decode(), end=&#39;&#39;)
            if self.idletime &gt; 0:
                x = threading.Thread(target=self._keepalive)
                x.daemon = True
                x.start()
            if debug:
                print(self.mylog.getvalue().decode())
            self.child.interact(input_filter=self._filter)
            if &#39;logfile&#39; in dir(self):
                with open(self.logfile, &#34;w&#34;) as f:
                    f.write(self._logclean(self.mylog.getvalue().decode(), True))

        else:
            print(connect)
            exit(1)

    def run(self, commands, vars = None,*, folder = &#39;&#39;, prompt = r&#39;&gt;$|#$|\$$|&gt;.$|#.$|\$.$&#39;, stdout = False, timeout = 10):
        &#39;&#39;&#39;
        Run a command or list of commands on the node and return the output.

        ### Parameters:  

            - commands (str/list): Commands to run on the node. Should be 
                                   str or a list of str. You can use variables
                                   as {varname} and defining them in optional
                                   parameter vars.

        ### Optional Parameters:  

            - vars  (dict): Dictionary containing the definition of variables
                            used in commands parameter.
                            Keys: Variable names.
                            Values: strings.

        ### Optional Named Parameters:  

            - folder (str): Path where output log should be stored, leave 
                            empty to disable logging.  

            - prompt (str): Prompt to be expected after a command is finished 
                            running. Usually linux uses  &#34;&gt;&#34; or EOF while 
                            routers use &#34;&gt;&#34; or &#34;#&#34;. The default value should 
                            work for most nodes. Change it if your connection 
                            need some special symbol.  

            - stdout (bool):Set True to send the command output to stdout. 
                            default False.

            - timeout (int):Time in seconds for expect to wait for prompt/EOF.
                            default 10.

        ### Returns:  

            str: Output of the commands you ran on the node.

        &#39;&#39;&#39;
        connect = self._connect(timeout = timeout)
        now = datetime.datetime.now().strftime(&#39;%Y-%m-%d_%H%M%S&#39;)
        if connect == True:
            if &#34;prompt&#34; in self.tags:
                prompt = self.tags[&#34;prompt&#34;]
            expects = [prompt, pexpect.EOF, pexpect.TIMEOUT]
            output = &#39;&#39;
            status = &#39;&#39;
            if not isinstance(commands, list):
                commands = [commands]
            if &#34;screen_length_command&#34; in self.tags:
                commands.insert(0, self.tags[&#34;screen_length_command&#34;])
            self.mylog = io.BytesIO()
            self.child.logfile_read = self.mylog
            for c in commands:
                if vars is not None:
                    c = c.format(**vars)
                result = self.child.expect(expects, timeout = timeout)
                self.child.sendline(c)
                if result == 2:
                    break
            if not result == 2:
                result = self.child.expect(expects, timeout = timeout)
            self.child.close()
            output = self._logclean(self.mylog.getvalue().decode(), True)
            if stdout == True:
                print(output)
            if folder != &#39;&#39;:
                with open(folder + &#34;/&#34; + self.unique + &#34;_&#34; + now + &#34;.txt&#34;, &#34;w&#34;) as f:
                    f.write(output)
                    f.close()
            self.output = output
            if result == 2:
                self.status = 2
            else:
                self.status = 0
            return output
        else:
            self.output = connect
            self.status = 1
            if stdout == True:
                print(connect)
            if folder != &#39;&#39;:
                with open(folder + &#34;/&#34; + self.unique + &#34;_&#34; + now + &#34;.txt&#34;, &#34;w&#34;) as f:
                    f.write(connect)
                    f.close()
            return connect

    def test(self, commands, expected, vars = None,*, prompt = r&#39;&gt;$|#$|\$$|&gt;.$|#.$|\$.$&#39;, timeout = 10):
        &#39;&#39;&#39;
        Run a command or list of commands on the node, then check if expected value appears on the output after the last command.

        ### Parameters:  

            - commands (str/list): Commands to run on the node. Should be
                                   str or a list of str. You can use variables
                                   as {varname} and defining them in optional
                                   parameter vars.

            - expected (str)     : Expected text to appear after running 
                                   all the commands on the node.You can use
                                   variables as {varname} and defining them
                                   in optional parameter vars.

        ### Optional Parameters:  

            - vars  (dict): Dictionary containing the definition of variables
                            used in commands and expected parameters.
                            Keys: Variable names.
                            Values: strings.

        ### Optional Named Parameters: 

            - prompt (str): Prompt to be expected after a command is finished
                            running. Usually linux uses  &#34;&gt;&#34; or EOF while 
                            routers use &#34;&gt;&#34; or &#34;#&#34;. The default value should 
                            work for most nodes. Change it if your connection 
                            need some special symbol.

            - timeout (int):Time in seconds for expect to wait for prompt/EOF.
                            default 10.

        ### Returns: 
            bool: true if expected value is found after running the commands 
                  false if prompt is found before.

        &#39;&#39;&#39;
        connect = self._connect(timeout = timeout)
        if connect == True:
            if &#34;prompt&#34; in self.tags:
                prompt = self.tags[&#34;prompt&#34;]
            expects = [prompt, pexpect.EOF, pexpect.TIMEOUT]
            output = &#39;&#39;
            if not isinstance(commands, list):
                commands = [commands]
            if not isinstance(expected, list):
                expected = [expected]
            if &#34;screen_length_command&#34; in self.tags:
                commands.insert(0, self.tags[&#34;screen_length_command&#34;])
            self.mylog = io.BytesIO()
            self.child.logfile_read = self.mylog
            for c in commands:
                if vars is not None:
                    c = c.format(**vars)
                result = self.child.expect(expects, timeout = timeout)
                self.child.sendline(c)
                if result == 2:
                    break
            if not result == 2:
                result = self.child.expect(expects, timeout = timeout)
            self.child.close()
            output = self._logclean(self.mylog.getvalue().decode(), True)
            self.output = output
            if result in [0, 1]:
                # lastcommand = commands[-1]
                # if vars is not None:
                    # lastcommand = lastcommand.format(**vars)
                # last_command_index = output.rfind(lastcommand)
                # cleaned_output = output[last_command_index + len(lastcommand):].strip()
                self.result = {}
                for e in expected:
                    if vars is not None:
                        e = e.format(**vars)
                    updatedprompt = re.sub(r&#39;(?&lt;!\\)\$&#39;, &#39;&#39;, prompt)
                    newpattern = f&#34;.*({updatedprompt}).*{e}.*&#34;
                    cleaned_output = output
                    cleaned_output = re.sub(newpattern, &#39;&#39;, cleaned_output)
                    if e in cleaned_output:
                        self.result[e] = True
                    else:
                        self.result[e]= False
                self.status = 0
                return self.result
            if result == 2:
                self.result = None
                self.status = 2
                return output
        else:
            self.result = None
            self.output = connect
            self.status = 1
            return connect

    def _connect(self, debug = False, timeout = 10, max_attempts = 3):
        # Method to connect to the node, it parse all the information, create the ssh/telnet command and login to the node.
        if self.protocol in [&#34;ssh&#34;, &#34;sftp&#34;]:
            cmd = self.protocol
            if self.idletime &gt; 0:
                cmd = cmd + &#34; -o ServerAliveInterval=&#34; + str(self.idletime)
            if self.port != &#39;&#39;:
                if self.protocol == &#34;ssh&#34;:
                    cmd = cmd + &#34; -p &#34; + self.port
                elif self.protocol == &#34;sftp&#34;:
                    cmd = cmd + &#34; -P &#34; + self.port
            if self.options != &#39;&#39;:
                cmd = cmd + &#34; &#34; + self.options
            if self.logs != &#39;&#39;:
                self.logfile = self._logfile()
            if self.jumphost != &#39;&#39;:
                cmd = cmd + &#34; &#34; + self.jumphost
            if self.password[0] != &#39;&#39;:
                passwords = self._passtx(self.password)
            else:
                passwords = []
            if self.user == &#39;&#39;:
                cmd = cmd + &#34; {}&#34;.format(self.host)
            else:
                cmd = cmd + &#34; {}&#34;.format(&#34;@&#34;.join([self.user,self.host]))
            expects = [&#39;yes/no&#39;, &#39;refused&#39;, &#39;supported&#39;, &#39;Invalid|[u|U]sage: (ssh|sftp)&#39;, &#39;ssh-keygen.*\&#34;&#39;, &#39;timeout|timed.out&#39;, &#39;unavailable&#39;, &#39;closed&#39;, &#39;[p|P]assword:|[u|U]sername:&#39;, r&#39;&gt;$|#$|\$$|&gt;.$|#.$|\$.$&#39;, &#39;suspend&#39;, pexpect.EOF, pexpect.TIMEOUT, &#34;No route to host&#34;, &#34;resolve hostname&#34;, &#34;no matching&#34;, &#34;[b|B]ad (owner|permissions)&#34;]
        elif self.protocol == &#34;telnet&#34;:
            cmd = &#34;telnet &#34; + self.host
            if self.port != &#39;&#39;:
                cmd = cmd + &#34; &#34; + self.port
            if self.options != &#39;&#39;:
                cmd = cmd + &#34; &#34; + self.options
            if self.logs != &#39;&#39;:
                self.logfile = self._logfile()
            if self.password[0] != &#39;&#39;:
                passwords = self._passtx(self.password)
            else:
                passwords = []
            expects = [&#39;[u|U]sername:&#39;, &#39;refused&#39;, &#39;supported&#39;, &#39;invalid option&#39;, &#39;ssh-keygen.*\&#34;&#39;, &#39;timeout|timed.out&#39;, &#39;unavailable&#39;, &#39;closed&#39;, &#39;[p|P]assword:&#39;, r&#39;&gt;$|#$|\$$|&gt;.$|#.$|\$.$&#39;, &#39;suspend&#39;, pexpect.EOF, pexpect.TIMEOUT, &#34;No route to host&#34;, &#34;resolve hostname&#34;, &#34;no matching&#34;, &#34;[b|B]ad (owner|permissions)&#34;]
        else:
            raise ValueError(&#34;Invalid protocol: &#34; + self.protocol)
        attempts = 1
        while attempts &lt;= max_attempts:
            child = pexpect.spawn(cmd)
            if debug:
                print(cmd)
                self.mylog = io.BytesIO()
                child.logfile_read = self.mylog
            if len(passwords) &gt; 0:
                loops = len(passwords)
            else:
                loops = 1
            endloop = False
            for i in range(0, loops):
                while True:
                    results = child.expect(expects, timeout=timeout)
                    if results == 0:
                        if self.protocol in [&#34;ssh&#34;, &#34;sftp&#34;]:
                            child.sendline(&#39;yes&#39;)
                        elif self.protocol == &#34;telnet&#34;:
                            if self.user != &#39;&#39;:
                                child.sendline(self.user)
                            else:
                                self.missingtext = True
                                break
                    if results in  [1, 2, 3, 4, 5, 6, 7, 12, 13, 14, 15, 16]:
                        child.terminate()
                        if results == 12 and attempts != max_attempts:
                            attempts += 1
                            endloop = True
                            break
                        else:
                            if results == 12:
                                after = &#34;Connection timeout&#34;
                            else:
                                after = child.after.decode()
                        return (&#34;Connection failed code:&#34; + str(results) + &#34;\n&#34; + child.before.decode().lstrip() + after + child.readline().decode()).rstrip()
                    if results == 8:
                        if len(passwords) &gt; 0:
                            child.sendline(passwords[i])
                        else:
                            self.missingtext = True
                        break
                    if results in [9, 11]:
                        endloop = True
                        child.sendline()
                        break
                    if results == 10:
                        child.sendline(&#34;\r&#34;)
                        sleep(2)
                if endloop:
                    break
            if results == 12:
                continue
            else:
                break
        child.readline(0)
        self.child = child
        return True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="connpy.node.interact"><code class="name flex">
<span>def <span class="ident">interact</span></span>(<span>self, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Allow user to interact with the node directly, mostly used by connection manager.</p>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- debug (bool): If True, display all the connecting information 
                before interact. Default False.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interact(self, debug = False):
    &#39;&#39;&#39;
    Allow user to interact with the node directly, mostly used by connection manager.

    ### Optional Parameters:  

        - debug (bool): If True, display all the connecting information 
                        before interact. Default False.  
    &#39;&#39;&#39;
    connect = self._connect(debug = debug)
    if connect == True:
        size = re.search(&#39;columns=([0-9]+).*lines=([0-9]+)&#39;,str(os.get_terminal_size()))
        self.child.setwinsize(int(size.group(2)),int(size.group(1)))
        print(&#34;Connected to &#34; + self.unique + &#34; at &#34; + self.host + (&#34;:&#34; if self.port != &#39;&#39; else &#39;&#39;) + self.port + &#34; via: &#34; + self.protocol)
        if &#39;logfile&#39; in dir(self):
            # Initialize self.mylog
            if not &#39;mylog&#39; in dir(self):
                self.mylog = io.BytesIO()
            self.child.logfile_read = self.mylog
            
            # Start the _savelog thread
            log_thread = threading.Thread(target=self._savelog)
            log_thread.daemon = True
            log_thread.start()
        if &#39;missingtext&#39; in dir(self):
            print(self.child.after.decode(), end=&#39;&#39;)
        if self.idletime &gt; 0:
            x = threading.Thread(target=self._keepalive)
            x.daemon = True
            x.start()
        if debug:
            print(self.mylog.getvalue().decode())
        self.child.interact(input_filter=self._filter)
        if &#39;logfile&#39; in dir(self):
            with open(self.logfile, &#34;w&#34;) as f:
                f.write(self._logclean(self.mylog.getvalue().decode(), True))

    else:
        print(connect)
        exit(1)</code></pre>
</details>
</dd>
<dt id="connpy.node.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, commands, vars=None, *, folder='', prompt=&#x27;&gt;$|#$|\\$$|&gt;.$|#.$|\\$.$&#x27;, stdout=False, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a command or list of commands on the node and return the output.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- commands (str/list): Commands to run on the node. Should be 
                       str or a list of str. You can use variables
                       as {varname} and defining them in optional
                       parameter vars.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- vars  (dict): Dictionary containing the definition of variables
                used in commands parameter.
                Keys: Variable names.
                Values: strings.
</code></pre>
<h3 id="optional-named-parameters">Optional Named Parameters:</h3>
<pre><code>- folder (str): Path where output log should be stored, leave 
                empty to disable logging.

- prompt (str): Prompt to be expected after a command is finished 
                running. Usually linux uses  "&gt;" or EOF while 
                routers use "&gt;" or "#". The default value should 
                work for most nodes. Change it if your connection 
                need some special symbol.

- stdout (bool):Set True to send the command output to stdout. 
                default False.

- timeout (int):Time in seconds for expect to wait for prompt/EOF.
                default 10.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>str: Output of the commands you ran on the node.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, commands, vars = None,*, folder = &#39;&#39;, prompt = r&#39;&gt;$|#$|\$$|&gt;.$|#.$|\$.$&#39;, stdout = False, timeout = 10):
    &#39;&#39;&#39;
    Run a command or list of commands on the node and return the output.

    ### Parameters:  

        - commands (str/list): Commands to run on the node. Should be 
                               str or a list of str. You can use variables
                               as {varname} and defining them in optional
                               parameter vars.

    ### Optional Parameters:  

        - vars  (dict): Dictionary containing the definition of variables
                        used in commands parameter.
                        Keys: Variable names.
                        Values: strings.

    ### Optional Named Parameters:  

        - folder (str): Path where output log should be stored, leave 
                        empty to disable logging.  

        - prompt (str): Prompt to be expected after a command is finished 
                        running. Usually linux uses  &#34;&gt;&#34; or EOF while 
                        routers use &#34;&gt;&#34; or &#34;#&#34;. The default value should 
                        work for most nodes. Change it if your connection 
                        need some special symbol.  

        - stdout (bool):Set True to send the command output to stdout. 
                        default False.

        - timeout (int):Time in seconds for expect to wait for prompt/EOF.
                        default 10.

    ### Returns:  

        str: Output of the commands you ran on the node.

    &#39;&#39;&#39;
    connect = self._connect(timeout = timeout)
    now = datetime.datetime.now().strftime(&#39;%Y-%m-%d_%H%M%S&#39;)
    if connect == True:
        if &#34;prompt&#34; in self.tags:
            prompt = self.tags[&#34;prompt&#34;]
        expects = [prompt, pexpect.EOF, pexpect.TIMEOUT]
        output = &#39;&#39;
        status = &#39;&#39;
        if not isinstance(commands, list):
            commands = [commands]
        if &#34;screen_length_command&#34; in self.tags:
            commands.insert(0, self.tags[&#34;screen_length_command&#34;])
        self.mylog = io.BytesIO()
        self.child.logfile_read = self.mylog
        for c in commands:
            if vars is not None:
                c = c.format(**vars)
            result = self.child.expect(expects, timeout = timeout)
            self.child.sendline(c)
            if result == 2:
                break
        if not result == 2:
            result = self.child.expect(expects, timeout = timeout)
        self.child.close()
        output = self._logclean(self.mylog.getvalue().decode(), True)
        if stdout == True:
            print(output)
        if folder != &#39;&#39;:
            with open(folder + &#34;/&#34; + self.unique + &#34;_&#34; + now + &#34;.txt&#34;, &#34;w&#34;) as f:
                f.write(output)
                f.close()
        self.output = output
        if result == 2:
            self.status = 2
        else:
            self.status = 0
        return output
    else:
        self.output = connect
        self.status = 1
        if stdout == True:
            print(connect)
        if folder != &#39;&#39;:
            with open(folder + &#34;/&#34; + self.unique + &#34;_&#34; + now + &#34;.txt&#34;, &#34;w&#34;) as f:
                f.write(connect)
                f.close()
        return connect</code></pre>
</details>
</dd>
<dt id="connpy.node.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>self, commands, expected, vars=None, *, prompt=&#x27;&gt;$|#$|\\$$|&gt;.$|#.$|\\$.$&#x27;, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a command or list of commands on the node, then check if expected value appears on the output after the last command.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- commands (str/list): Commands to run on the node. Should be
                       str or a list of str. You can use variables
                       as {varname} and defining them in optional
                       parameter vars.

- expected (str)     : Expected text to appear after running 
                       all the commands on the node.You can use
                       variables as {varname} and defining them
                       in optional parameter vars.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- vars  (dict): Dictionary containing the definition of variables
                used in commands and expected parameters.
                Keys: Variable names.
                Values: strings.
</code></pre>
<h3 id="optional-named-parameters">Optional Named Parameters:</h3>
<pre><code>- prompt (str): Prompt to be expected after a command is finished
                running. Usually linux uses  "&gt;" or EOF while 
                routers use "&gt;" or "#". The default value should 
                work for most nodes. Change it if your connection 
                need some special symbol.

- timeout (int):Time in seconds for expect to wait for prompt/EOF.
                default 10.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>bool: true if expected value is found after running the commands 
      false if prompt is found before.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test(self, commands, expected, vars = None,*, prompt = r&#39;&gt;$|#$|\$$|&gt;.$|#.$|\$.$&#39;, timeout = 10):
    &#39;&#39;&#39;
    Run a command or list of commands on the node, then check if expected value appears on the output after the last command.

    ### Parameters:  

        - commands (str/list): Commands to run on the node. Should be
                               str or a list of str. You can use variables
                               as {varname} and defining them in optional
                               parameter vars.

        - expected (str)     : Expected text to appear after running 
                               all the commands on the node.You can use
                               variables as {varname} and defining them
                               in optional parameter vars.

    ### Optional Parameters:  

        - vars  (dict): Dictionary containing the definition of variables
                        used in commands and expected parameters.
                        Keys: Variable names.
                        Values: strings.

    ### Optional Named Parameters: 

        - prompt (str): Prompt to be expected after a command is finished
                        running. Usually linux uses  &#34;&gt;&#34; or EOF while 
                        routers use &#34;&gt;&#34; or &#34;#&#34;. The default value should 
                        work for most nodes. Change it if your connection 
                        need some special symbol.

        - timeout (int):Time in seconds for expect to wait for prompt/EOF.
                        default 10.

    ### Returns: 
        bool: true if expected value is found after running the commands 
              false if prompt is found before.

    &#39;&#39;&#39;
    connect = self._connect(timeout = timeout)
    if connect == True:
        if &#34;prompt&#34; in self.tags:
            prompt = self.tags[&#34;prompt&#34;]
        expects = [prompt, pexpect.EOF, pexpect.TIMEOUT]
        output = &#39;&#39;
        if not isinstance(commands, list):
            commands = [commands]
        if not isinstance(expected, list):
            expected = [expected]
        if &#34;screen_length_command&#34; in self.tags:
            commands.insert(0, self.tags[&#34;screen_length_command&#34;])
        self.mylog = io.BytesIO()
        self.child.logfile_read = self.mylog
        for c in commands:
            if vars is not None:
                c = c.format(**vars)
            result = self.child.expect(expects, timeout = timeout)
            self.child.sendline(c)
            if result == 2:
                break
        if not result == 2:
            result = self.child.expect(expects, timeout = timeout)
        self.child.close()
        output = self._logclean(self.mylog.getvalue().decode(), True)
        self.output = output
        if result in [0, 1]:
            # lastcommand = commands[-1]
            # if vars is not None:
                # lastcommand = lastcommand.format(**vars)
            # last_command_index = output.rfind(lastcommand)
            # cleaned_output = output[last_command_index + len(lastcommand):].strip()
            self.result = {}
            for e in expected:
                if vars is not None:
                    e = e.format(**vars)
                updatedprompt = re.sub(r&#39;(?&lt;!\\)\$&#39;, &#39;&#39;, prompt)
                newpattern = f&#34;.*({updatedprompt}).*{e}.*&#34;
                cleaned_output = output
                cleaned_output = re.sub(newpattern, &#39;&#39;, cleaned_output)
                if e in cleaned_output:
                    self.result[e] = True
                else:
                    self.result[e]= False
            self.status = 0
            return self.result
        if result == 2:
            self.result = None
            self.status = 2
            return output
    else:
        self.result = None
        self.output = connect
        self.status = 1
        return connect</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="connpy.nodes"><code class="flex name class">
<span>class <span class="ident">nodes</span></span>
<span>(</span><span>nodes:Â dict, config='')</span>
</code></dt>
<dd>
<div class="desc"><p>This class generates a nodes object. Contains a list of node class objects and methods to run multiple tasks on nodes simultaneously.</p>
<h3 id="attributes">Attributes:</h3>
<pre><code>- nodelist (list): List of node class objects passed to the init 
                   function.

- output   (dict): Dictionary formed by nodes unique as keys, 
                   output of the commands you ran on the node as 
                   value. Created after running methods run or test.

- result   (dict): Dictionary formed by nodes unique as keys, value 
                   is True if expected value is found after running 
                   the commands, False if prompt is found before. 
                   Created after running method test.

- status   (dict): Dictionary formed by nodes unique as keys, value: 
                   0 if method run or test ended succesfully.
                   1 if connection failed.
                   2 if expect timeouts without prompt or EOF.

- &lt;unique&gt; (obj):  For each item in nodelist, there is an attribute
                   generated with the node unique.
</code></pre>
<h3 id="parameters">Parameters:</h3>
<pre><code>- nodes (dict): Dictionary formed by node information:  
                Keys: Unique name for each node.  
                Mandatory Subkeys: host(str).  
                Optional Subkeys: options(str), logs(str), password(str),
                port(str), protocol(str), user(str).  
                For reference on subkeys check node class.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- config (obj): Pass the object created with class configfile with key 
                for decryption and extra configuration if you are using 
                connection manager.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodes:
    &#39;&#39;&#39; This class generates a nodes object. Contains a list of node class objects and methods to run multiple tasks on nodes simultaneously.

    ### Attributes:  

        - nodelist (list): List of node class objects passed to the init 
                           function.  

        - output   (dict): Dictionary formed by nodes unique as keys, 
                           output of the commands you ran on the node as 
                           value. Created after running methods run or test.  

        - result   (dict): Dictionary formed by nodes unique as keys, value 
                           is True if expected value is found after running 
                           the commands, False if prompt is found before. 
                           Created after running method test.  

        - status   (dict): Dictionary formed by nodes unique as keys, value: 
                           0 if method run or test ended succesfully.
                           1 if connection failed.
                           2 if expect timeouts without prompt or EOF.

        - &lt;unique&gt; (obj):  For each item in nodelist, there is an attribute
                           generated with the node unique.
        &#39;&#39;&#39;

    def __init__(self, nodes: dict, config = &#39;&#39;):
        &#39;&#39;&#39; 
        ### Parameters:  

            - nodes (dict): Dictionary formed by node information:  
                            Keys: Unique name for each node.  
                            Mandatory Subkeys: host(str).  
                            Optional Subkeys: options(str), logs(str), password(str),
                            port(str), protocol(str), user(str).  
                            For reference on subkeys check node class.

        ### Optional Parameters:  

            - config (obj): Pass the object created with class configfile with key 
                            for decryption and extra configuration if you are using 
                            connection manager.
        &#39;&#39;&#39;
        self.nodelist = []
        self.config = config
        for n in nodes:
            this = node(n, **nodes[n], config = config)
            self.nodelist.append(this)
            setattr(self,n,this)

    
    def _splitlist(self, lst, n):
        #split a list in lists of n members.
        for i in range(0, len(lst), n):
            yield lst[i:i + n]


    def run(self, commands, vars = None,*, folder = None, prompt = None, stdout = None, parallel = 10, timeout = None):
        &#39;&#39;&#39;
        Run a command or list of commands on all the nodes in nodelist.

        ### Parameters:  

            - commands (str/list): Commands to run on the nodes. Should be str or 
                                   list of str. You can use variables as {varname}
                                   and defining them in optional parameter vars.

        ### Optional Parameters:  

            - vars  (dict): Dictionary containing the definition of variables for
                            each node, used in commands parameter.
                            Keys should be formed by nodes unique names. Use
                            special key name __global__ for global variables.
                            Subkeys: Variable names.
                            Values: strings.

        ### Optional Named Parameters:  

            - folder   (str): Path where output log should be stored, leave empty 
                              to disable logging.  

            - prompt   (str): Prompt to be expected after a command is finished 
                              running. Usually linux uses  &#34;&gt;&#34; or EOF while routers 
                              use &#34;&gt;&#34; or &#34;#&#34;. The default value should work for 
                              most nodes. Change it if your connection need some 
                              special symbol.  

            - stdout  (bool): Set True to send the command output to stdout. 
                              Default False.  

            - parallel (int): Number of nodes to run the commands simultaneously. 
                              Default is 10, if there are more nodes that this 
                              value, nodes are groups in groups with max this 
                              number of members.
            
            - timeout  (int): Time in seconds for expect to wait for prompt/EOF.
                              default 10.

        ###Returns:  

            dict: Dictionary formed by nodes unique as keys, Output of the 
                  commands you ran on the node as value.

        &#39;&#39;&#39;
        args = {}
        nodesargs = {}
        args[&#34;commands&#34;] = commands
        if folder != None:
            args[&#34;folder&#34;] = folder
            Path(folder).mkdir(parents=True, exist_ok=True)
        if prompt != None:
            args[&#34;prompt&#34;] = prompt
        if stdout != None:
            args[&#34;stdout&#34;] = stdout
        if timeout != None:
            args[&#34;timeout&#34;] = timeout
        output = {}
        status = {}
        tasks = []
        for n in self.nodelist:
            nodesargs[n.unique] = deepcopy(args)
            if vars != None:
                nodesargs[n.unique][&#34;vars&#34;] = {}
                if &#34;__global__&#34; in vars.keys():
                    nodesargs[n.unique][&#34;vars&#34;].update(vars[&#34;__global__&#34;])
                if n.unique in vars.keys():
                    nodesargs[n.unique][&#34;vars&#34;].update(vars[n.unique])
            tasks.append(threading.Thread(target=n.run, kwargs=nodesargs[n.unique]))
        taskslist = list(self._splitlist(tasks, parallel))
        for t in taskslist:
            for i in t:
                i.start()
            for i in t:
                i.join()
        for i in self.nodelist:
            output[i.unique] = i.output
            status[i.unique] = i.status
        self.output = output
        self.status = status
        return output

    def test(self, commands, expected, vars = None,*, prompt = None, parallel = 10, timeout = None):
        &#39;&#39;&#39;
        Run a command or list of commands on all the nodes in nodelist, then check if expected value appears on the output after the last command.

        ### Parameters:  

            - commands (str/list): Commands to run on the node. Should be str or 
                                   list of str.  

            - expected (str)     : Expected text to appear after running all the 
                                   commands on the node.

        ### Optional Parameters:  

            - vars  (dict): Dictionary containing the definition of variables for
                            each node, used in commands and expected parameters.
                            Keys should be formed by nodes unique names. Use
                            special key name __global__ for global variables.
                            Subkeys: Variable names.
                            Values: strings.

        ### Optional Named Parameters:  

            - prompt   (str): Prompt to be expected after a command is finished 
                              running. Usually linux uses  &#34;&gt;&#34; or EOF while 
                              routers use &#34;&gt;&#34; or &#34;#&#34;. The default value should 
                              work for most nodes. Change it if your connection 
                              need some special symbol.


            - parallel (int): Number of nodes to run the commands simultaneously. 
                              Default is 10, if there are more nodes that this 
                              value, nodes are groups in groups with max this 
                              number of members.

            - timeout  (int): Time in seconds for expect to wait for prompt/EOF.
                              default 10.

        ### Returns:  

            dict: Dictionary formed by nodes unique as keys, value is True if 
                  expected value is found after running the commands, False 
                  if prompt is found before.

        &#39;&#39;&#39;
        args = {}
        nodesargs = {}
        args[&#34;commands&#34;] = commands
        args[&#34;expected&#34;] = expected
        if prompt != None:
            args[&#34;prompt&#34;] = prompt
        if timeout != None:
            args[&#34;timeout&#34;] = timeout
        output = {}
        result = {}
        status = {}
        tasks = []
        for n in self.nodelist:
            nodesargs[n.unique] = deepcopy(args)
            if vars != None:
                nodesargs[n.unique][&#34;vars&#34;] = {}
                if &#34;__global__&#34; in vars.keys():
                    nodesargs[n.unique][&#34;vars&#34;].update(vars[&#34;__global__&#34;])
                if n.unique in vars.keys():
                    nodesargs[n.unique][&#34;vars&#34;].update(vars[n.unique])
            tasks.append(threading.Thread(target=n.test, kwargs=nodesargs[n.unique]))
        taskslist = list(self._splitlist(tasks, parallel))
        for t in taskslist:
            for i in t:
                i.start()
            for i in t:
                i.join()
        for i in self.nodelist:
            result[i.unique] = i.result
            output[i.unique] = i.output
            status[i.unique] = i.status
        self.output = output
        self.result = result
        self.status = status
        return result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="connpy.nodes.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, commands, vars=None, *, folder=None, prompt=None, stdout=None, parallel=10, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a command or list of commands on all the nodes in nodelist.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- commands (str/list): Commands to run on the nodes. Should be str or 
                       list of str. You can use variables as {varname}
                       and defining them in optional parameter vars.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- vars  (dict): Dictionary containing the definition of variables for
                each node, used in commands parameter.
                Keys should be formed by nodes unique names. Use
                special key name __global__ for global variables.
                Subkeys: Variable names.
                Values: strings.
</code></pre>
<h3 id="optional-named-parameters">Optional Named Parameters:</h3>
<pre><code>- folder   (str): Path where output log should be stored, leave empty 
                  to disable logging.

- prompt   (str): Prompt to be expected after a command is finished 
                  running. Usually linux uses  "&gt;" or EOF while routers 
                  use "&gt;" or "#". The default value should work for 
                  most nodes. Change it if your connection need some 
                  special symbol.

- stdout  (bool): Set True to send the command output to stdout. 
                  Default False.

- parallel (int): Number of nodes to run the commands simultaneously. 
                  Default is 10, if there are more nodes that this 
                  value, nodes are groups in groups with max this 
                  number of members.

- timeout  (int): Time in seconds for expect to wait for prompt/EOF.
                  default 10.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>dict: Dictionary formed by nodes unique as keys, Output of the 
      commands you ran on the node as value.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, commands, vars = None,*, folder = None, prompt = None, stdout = None, parallel = 10, timeout = None):
    &#39;&#39;&#39;
    Run a command or list of commands on all the nodes in nodelist.

    ### Parameters:  

        - commands (str/list): Commands to run on the nodes. Should be str or 
                               list of str. You can use variables as {varname}
                               and defining them in optional parameter vars.

    ### Optional Parameters:  

        - vars  (dict): Dictionary containing the definition of variables for
                        each node, used in commands parameter.
                        Keys should be formed by nodes unique names. Use
                        special key name __global__ for global variables.
                        Subkeys: Variable names.
                        Values: strings.

    ### Optional Named Parameters:  

        - folder   (str): Path where output log should be stored, leave empty 
                          to disable logging.  

        - prompt   (str): Prompt to be expected after a command is finished 
                          running. Usually linux uses  &#34;&gt;&#34; or EOF while routers 
                          use &#34;&gt;&#34; or &#34;#&#34;. The default value should work for 
                          most nodes. Change it if your connection need some 
                          special symbol.  

        - stdout  (bool): Set True to send the command output to stdout. 
                          Default False.  

        - parallel (int): Number of nodes to run the commands simultaneously. 
                          Default is 10, if there are more nodes that this 
                          value, nodes are groups in groups with max this 
                          number of members.
        
        - timeout  (int): Time in seconds for expect to wait for prompt/EOF.
                          default 10.

    ###Returns:  

        dict: Dictionary formed by nodes unique as keys, Output of the 
              commands you ran on the node as value.

    &#39;&#39;&#39;
    args = {}
    nodesargs = {}
    args[&#34;commands&#34;] = commands
    if folder != None:
        args[&#34;folder&#34;] = folder
        Path(folder).mkdir(parents=True, exist_ok=True)
    if prompt != None:
        args[&#34;prompt&#34;] = prompt
    if stdout != None:
        args[&#34;stdout&#34;] = stdout
    if timeout != None:
        args[&#34;timeout&#34;] = timeout
    output = {}
    status = {}
    tasks = []
    for n in self.nodelist:
        nodesargs[n.unique] = deepcopy(args)
        if vars != None:
            nodesargs[n.unique][&#34;vars&#34;] = {}
            if &#34;__global__&#34; in vars.keys():
                nodesargs[n.unique][&#34;vars&#34;].update(vars[&#34;__global__&#34;])
            if n.unique in vars.keys():
                nodesargs[n.unique][&#34;vars&#34;].update(vars[n.unique])
        tasks.append(threading.Thread(target=n.run, kwargs=nodesargs[n.unique]))
    taskslist = list(self._splitlist(tasks, parallel))
    for t in taskslist:
        for i in t:
            i.start()
        for i in t:
            i.join()
    for i in self.nodelist:
        output[i.unique] = i.output
        status[i.unique] = i.status
    self.output = output
    self.status = status
    return output</code></pre>
</details>
</dd>
<dt id="connpy.nodes.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>self, commands, expected, vars=None, *, prompt=None, parallel=10, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a command or list of commands on all the nodes in nodelist, then check if expected value appears on the output after the last command.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>- commands (str/list): Commands to run on the node. Should be str or 
                       list of str.

- expected (str)     : Expected text to appear after running all the 
                       commands on the node.
</code></pre>
<h3 id="optional-parameters">Optional Parameters:</h3>
<pre><code>- vars  (dict): Dictionary containing the definition of variables for
                each node, used in commands and expected parameters.
                Keys should be formed by nodes unique names. Use
                special key name __global__ for global variables.
                Subkeys: Variable names.
                Values: strings.
</code></pre>
<h3 id="optional-named-parameters">Optional Named Parameters:</h3>
<pre><code>- prompt   (str): Prompt to be expected after a command is finished 
                  running. Usually linux uses  "&gt;" or EOF while 
                  routers use "&gt;" or "#". The default value should 
                  work for most nodes. Change it if your connection 
                  need some special symbol.


- parallel (int): Number of nodes to run the commands simultaneously. 
                  Default is 10, if there are more nodes that this 
                  value, nodes are groups in groups with max this 
                  number of members.

- timeout  (int): Time in seconds for expect to wait for prompt/EOF.
                  default 10.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>dict: Dictionary formed by nodes unique as keys, value is True if 
      expected value is found after running the commands, False 
      if prompt is found before.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test(self, commands, expected, vars = None,*, prompt = None, parallel = 10, timeout = None):
    &#39;&#39;&#39;
    Run a command or list of commands on all the nodes in nodelist, then check if expected value appears on the output after the last command.

    ### Parameters:  

        - commands (str/list): Commands to run on the node. Should be str or 
                               list of str.  

        - expected (str)     : Expected text to appear after running all the 
                               commands on the node.

    ### Optional Parameters:  

        - vars  (dict): Dictionary containing the definition of variables for
                        each node, used in commands and expected parameters.
                        Keys should be formed by nodes unique names. Use
                        special key name __global__ for global variables.
                        Subkeys: Variable names.
                        Values: strings.

    ### Optional Named Parameters:  

        - prompt   (str): Prompt to be expected after a command is finished 
                          running. Usually linux uses  &#34;&gt;&#34; or EOF while 
                          routers use &#34;&gt;&#34; or &#34;#&#34;. The default value should 
                          work for most nodes. Change it if your connection 
                          need some special symbol.


        - parallel (int): Number of nodes to run the commands simultaneously. 
                          Default is 10, if there are more nodes that this 
                          value, nodes are groups in groups with max this 
                          number of members.

        - timeout  (int): Time in seconds for expect to wait for prompt/EOF.
                          default 10.

    ### Returns:  

        dict: Dictionary formed by nodes unique as keys, value is True if 
              expected value is found after running the commands, False 
              if prompt is found before.

    &#39;&#39;&#39;
    args = {}
    nodesargs = {}
    args[&#34;commands&#34;] = commands
    args[&#34;expected&#34;] = expected
    if prompt != None:
        args[&#34;prompt&#34;] = prompt
    if timeout != None:
        args[&#34;timeout&#34;] = timeout
    output = {}
    result = {}
    status = {}
    tasks = []
    for n in self.nodelist:
        nodesargs[n.unique] = deepcopy(args)
        if vars != None:
            nodesargs[n.unique][&#34;vars&#34;] = {}
            if &#34;__global__&#34; in vars.keys():
                nodesargs[n.unique][&#34;vars&#34;].update(vars[&#34;__global__&#34;])
            if n.unique in vars.keys():
                nodesargs[n.unique][&#34;vars&#34;].update(vars[n.unique])
        tasks.append(threading.Thread(target=n.test, kwargs=nodesargs[n.unique]))
    taskslist = list(self._splitlist(tasks, parallel))
    for t in taskslist:
        for i in t:
            i.start()
        for i in t:
            i.join()
    for i in self.nodelist:
        result[i.unique] = i.result
        output[i.unique] = i.output
        status[i.unique] = i.status
    self.output = output
    self.result = result
    self.status = status
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#connection-manager">Connection manager</a><ul>
<li><a href="#features">Features</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#manage-profiles">Manage profiles</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</li>
<li><a href="#plugin-requirements-for-connpy">Plugin Requirements for Connpy</a><ul>
<li><a href="#general-structure">General Structure</a></li>
<li><a href="#specific-class-requirements">Specific Class Requirements</a></li>
<li><a href="#executable-block">Executable Block</a></li>
<li><a href="#script-verification">Script Verification</a></li>
<li><a href="#example-script">Example Script</a></li>
</ul>
</li>
<li><a href="#http-api">http API</a><ul>
<li><a href="#1-list-nodes">1. List Nodes</a><ul>
<li><a href="#request-body">Request Body:</a></li>
<li><a href="#response">Response:</a></li>
</ul>
</li>
<li><a href="#2-get-nodes">2. Get Nodes</a><ul>
<li><a href="#request-body_1">Request Body:</a></li>
<li><a href="#response_1">Response:</a></li>
</ul>
</li>
<li><a href="#3-run-commands">3. Run Commands</a><ul>
<li><a href="#request-body_2">Request Body:</a></li>
<li><a href="#response_2">Response:</a></li>
</ul>
</li>
<li><a href="#4-ask-ai">4. Ask AI</a><ul>
<li><a href="#request-body_3">Request Body:</a></li>
<li><a href="#response_3">Response:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#automation-module">Automation module</a><ul>
<li><a href="#standalone-module">Standalone module</a></li>
<li><a href="#using-manager-configuration">Using manager configuration</a></li>
<li><a href="#running-parallel-tasks">Running parallel tasks</a></li>
<li><a href="#using-variables">Using variables</a></li>
<li><a href="#using-ai">Using AI</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="connpy.Plugins" href="#connpy.Plugins">Plugins</a></code></h4>
<ul class="">
<li><code><a title="connpy.Plugins.verify_script" href="#connpy.Plugins.verify_script">verify_script</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="connpy.ai" href="#connpy.ai">ai</a></code></h4>
<ul class="">
<li><code><a title="connpy.ai.ask" href="#connpy.ai.ask">ask</a></code></li>
<li><code><a title="connpy.ai.confirm" href="#connpy.ai.confirm">confirm</a></code></li>
<li><code><a title="connpy.ai.process_string" href="#connpy.ai.process_string">process_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="connpy.configfile" href="#connpy.configfile">configfile</a></code></h4>
<ul class="">
<li><code><a title="connpy.configfile.getitem" href="#connpy.configfile.getitem">getitem</a></code></li>
<li><code><a title="connpy.configfile.getitems" href="#connpy.configfile.getitems">getitems</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="connpy.connapp" href="#connpy.connapp">connapp</a></code></h4>
<ul class="">
<li><code><a title="connpy.connapp.encrypt" href="#connpy.connapp.encrypt">encrypt</a></code></li>
<li><code><a title="connpy.connapp.start" href="#connpy.connapp.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="connpy.node" href="#connpy.node">node</a></code></h4>
<ul class="">
<li><code><a title="connpy.node.interact" href="#connpy.node.interact">interact</a></code></li>
<li><code><a title="connpy.node.run" href="#connpy.node.run">run</a></code></li>
<li><code><a title="connpy.node.test" href="#connpy.node.test">test</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="connpy.nodes" href="#connpy.nodes">nodes</a></code></h4>
<ul class="">
<li><code><a title="connpy.nodes.run" href="#connpy.nodes.run">run</a></code></li>
<li><code><a title="connpy.nodes.test" href="#connpy.nodes.test">test</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>